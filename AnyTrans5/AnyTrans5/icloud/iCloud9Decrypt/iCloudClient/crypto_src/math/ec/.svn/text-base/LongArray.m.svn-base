//
//  LongArray.m
//  
//
//  Created by Pallas on 5/10/16.
//
//  Complete

#import "LongArray.h"
#import "BigInteger.h"
#import "CategoryExtend.h"

NSString * const ZEROES = @"0000000000000000000000000000000000000000000000000000000000000000";      // For toString(); must have length 64

@interface LongArray ()

@property (nonatomic, readwrite, retain) NSMutableArray *m_ints; // long[]

@end

@implementation LongArray
@synthesize m_ints = _m_ints;

/*
 * This expands 8 bit indices into 16 bit contents (high bit 14), by inserting 0s between bits.
 * In a binary field, this operation is the same as squaring an 8 bit number.
 */
// return == ushort[]
+ (NSArray*)INTERLEAVE2_TABLE {
    static NSArray *_interleave2_table = nil;
    @synchronized(self) {
        if (_interleave2_table == nil) {
            @autoreleasepool {
                _interleave2_table = [[NSArray alloc] initWithObjects:
                                      @((ushort)(0x0000)), @((ushort)(0x0001)), @((ushort)(0x0004)), @((ushort)(0x0005)), @((ushort)(0x0010)), @((ushort)(0x0011)), @((ushort)(0x0014)), @((ushort)(0x0015)),
                                      @((ushort)(0x0040)), @((ushort)(0x0041)), @((ushort)(0x0044)), @((ushort)(0x0045)), @((ushort)(0x0050)), @((ushort)(0x0051)), @((ushort)(0x0054)), @((ushort)(0x0055)),
                                      @((ushort)(0x0100)), @((ushort)(0x0101)), @((ushort)(0x0104)), @((ushort)(0x0105)), @((ushort)(0x0110)), @((ushort)(0x0111)), @((ushort)(0x0114)), @((ushort)(0x0115)),
                                      @((ushort)(0x0140)), @((ushort)(0x0141)), @((ushort)(0x0144)), @((ushort)(0x0145)), @((ushort)(0x0150)), @((ushort)(0x0151)), @((ushort)(0x0154)), @((ushort)(0x0155)),
                                      @((ushort)(0x0400)), @((ushort)(0x0401)), @((ushort)(0x0404)), @((ushort)(0x0405)), @((ushort)(0x0410)), @((ushort)(0x0411)), @((ushort)(0x0414)), @((ushort)(0x0415)),
                                      @((ushort)(0x0440)), @((ushort)(0x0441)), @((ushort)(0x0444)), @((ushort)(0x0445)), @((ushort)(0x0450)), @((ushort)(0x0451)), @((ushort)(0x0454)), @((ushort)(0x0455)),
                                      @((ushort)(0x0500)), @((ushort)(0x0501)), @((ushort)(0x0504)), @((ushort)(0x0505)), @((ushort)(0x0510)), @((ushort)(0x0511)), @((ushort)(0x0514)), @((ushort)(0x0515)),
                                      @((ushort)(0x0540)), @((ushort)(0x0541)), @((ushort)(0x0544)), @((ushort)(0x0545)), @((ushort)(0x0550)), @((ushort)(0x0551)), @((ushort)(0x0554)), @((ushort)(0x0555)),
                                      @((ushort)(0x1000)), @((ushort)(0x1001)), @((ushort)(0x1004)), @((ushort)(0x1005)), @((ushort)(0x1010)), @((ushort)(0x1011)), @((ushort)(0x1014)), @((ushort)(0x1015)),
                                      @((ushort)(0x1040)), @((ushort)(0x1041)), @((ushort)(0x1044)), @((ushort)(0x1045)), @((ushort)(0x1050)), @((ushort)(0x1051)), @((ushort)(0x1054)), @((ushort)(0x1055)),
                                      @((ushort)(0x1100)), @((ushort)(0x1101)), @((ushort)(0x1104)), @((ushort)(0x1105)), @((ushort)(0x1110)), @((ushort)(0x1111)), @((ushort)(0x1114)), @((ushort)(0x1115)),
                                      @((ushort)(0x1140)), @((ushort)(0x1141)), @((ushort)(0x1144)), @((ushort)(0x1145)), @((ushort)(0x1150)), @((ushort)(0x1151)), @((ushort)(0x1154)), @((ushort)(0x1155)),
                                      @((ushort)(0x1400)), @((ushort)(0x1401)), @((ushort)(0x1404)), @((ushort)(0x1405)), @((ushort)(0x1410)), @((ushort)(0x1411)), @((ushort)(0x1414)), @((ushort)(0x1415)),
                                      @((ushort)(0x1440)), @((ushort)(0x1441)), @((ushort)(0x1444)), @((ushort)(0x1445)), @((ushort)(0x1450)), @((ushort)(0x1451)), @((ushort)(0x1454)), @((ushort)(0x1455)),
                                      @((ushort)(0x1500)), @((ushort)(0x1501)), @((ushort)(0x1504)), @((ushort)(0x1505)), @((ushort)(0x1510)), @((ushort)(0x1511)), @((ushort)(0x1514)), @((ushort)(0x1515)),
                                      @((ushort)(0x1540)), @((ushort)(0x1541)), @((ushort)(0x1544)), @((ushort)(0x1545)), @((ushort)(0x1550)), @((ushort)(0x1551)), @((ushort)(0x1554)), @((ushort)(0x1555)),
                                      @((ushort)(0x4000)), @((ushort)(0x4001)), @((ushort)(0x4004)), @((ushort)(0x4005)), @((ushort)(0x4010)), @((ushort)(0x4011)), @((ushort)(0x4014)), @((ushort)(0x4015)),
                                      @((ushort)(0x4040)), @((ushort)(0x4041)), @((ushort)(0x4044)), @((ushort)(0x4045)), @((ushort)(0x4050)), @((ushort)(0x4051)), @((ushort)(0x4054)), @((ushort)(0x4055)),
                                      @((ushort)(0x4100)), @((ushort)(0x4101)), @((ushort)(0x4104)), @((ushort)(0x4105)), @((ushort)(0x4110)), @((ushort)(0x4111)), @((ushort)(0x4114)), @((ushort)(0x4115)),
                                      @((ushort)(0x4140)), @((ushort)(0x4141)), @((ushort)(0x4144)), @((ushort)(0x4145)), @((ushort)(0x4150)), @((ushort)(0x4151)), @((ushort)(0x4154)), @((ushort)(0x4155)),
                                      @((ushort)(0x4400)), @((ushort)(0x4401)), @((ushort)(0x4404)), @((ushort)(0x4405)), @((ushort)(0x4410)), @((ushort)(0x4411)), @((ushort)(0x4414)), @((ushort)(0x4415)),
                                      @((ushort)(0x4440)), @((ushort)(0x4441)), @((ushort)(0x4444)), @((ushort)(0x4445)), @((ushort)(0x4450)), @((ushort)(0x4451)), @((ushort)(0x4454)), @((ushort)(0x4455)),
                                      @((ushort)(0x4500)), @((ushort)(0x4501)), @((ushort)(0x4504)), @((ushort)(0x4505)), @((ushort)(0x4510)), @((ushort)(0x4511)), @((ushort)(0x4514)), @((ushort)(0x4515)),
                                      @((ushort)(0x4540)), @((ushort)(0x4541)), @((ushort)(0x4544)), @((ushort)(0x4545)), @((ushort)(0x4550)), @((ushort)(0x4551)), @((ushort)(0x4554)), @((ushort)(0x4555)),
                                      @((ushort)(0x5000)), @((ushort)(0x5001)), @((ushort)(0x5004)), @((ushort)(0x5005)), @((ushort)(0x5010)), @((ushort)(0x5011)), @((ushort)(0x5014)), @((ushort)(0x5015)),
                                      @((ushort)(0x5040)), @((ushort)(0x5041)), @((ushort)(0x5044)), @((ushort)(0x5045)), @((ushort)(0x5050)), @((ushort)(0x5051)), @((ushort)(0x5054)), @((ushort)(0x5055)),
                                      @((ushort)(0x5100)), @((ushort)(0x5101)), @((ushort)(0x5104)), @((ushort)(0x5105)), @((ushort)(0x5110)), @((ushort)(0x5111)), @((ushort)(0x5114)), @((ushort)(0x5115)),
                                      @((ushort)(0x5140)), @((ushort)(0x5141)), @((ushort)(0x5144)), @((ushort)(0x5145)), @((ushort)(0x5150)), @((ushort)(0x5151)), @((ushort)(0x5154)), @((ushort)(0x5155)),
                                      @((ushort)(0x5400)), @((ushort)(0x5401)), @((ushort)(0x5404)), @((ushort)(0x5405)), @((ushort)(0x5410)), @((ushort)(0x5411)), @((ushort)(0x5414)), @((ushort)(0x5415)),
                                      @((ushort)(0x5440)), @((ushort)(0x5441)), @((ushort)(0x5444)), @((ushort)(0x5445)), @((ushort)(0x5450)), @((ushort)(0x5451)), @((ushort)(0x5454)), @((ushort)(0x5455)),
                                      @((ushort)(0x5500)), @((ushort)(0x5501)), @((ushort)(0x5504)), @((ushort)(0x5505)), @((ushort)(0x5510)), @((ushort)(0x5511)), @((ushort)(0x5514)), @((ushort)(0x5515)),
                                      @((ushort)(0x5540)), @((ushort)(0x5541)), @((ushort)(0x5544)), @((ushort)(0x5545)), @((ushort)(0x5550)), @((ushort)(0x5551)), @((ushort)(0x5554)), @((ushort)(0x5555)), nil];
            }
        }
    }
    return _interleave2_table;
}

/*
 * This expands 7 bit indices into 21 bit contents (high bit 18), by inserting 0s between bits.
 */
// return == int[]
+ (NSArray*)INTERLEAVE3_TABLE {
    static NSArray *_interleave3_table = nil;
    @synchronized(self) {
        if (_interleave3_table == nil) {
            @autoreleasepool {
                _interleave3_table = [[NSArray alloc] initWithObjects:
                                      @((int)(0x00000)), @((int)(0x00001)), @((int)(0x00008)), @((int)(0x00009)), @((int)(0x00040)), @((int)(0x00041)), @((int)(0x00048)), @((int)(0x00049)),
                                      @((int)(0x00200)), @((int)(0x00201)), @((int)(0x00208)), @((int)(0x00209)), @((int)(0x00240)), @((int)(0x00241)), @((int)(0x00248)), @((int)(0x00249)),
                                      @((int)(0x01000)), @((int)(0x01001)), @((int)(0x01008)), @((int)(0x01009)), @((int)(0x01040)), @((int)(0x01041)), @((int)(0x01048)), @((int)(0x01049)),
                                      @((int)(0x01200)), @((int)(0x01201)), @((int)(0x01208)), @((int)(0x01209)), @((int)(0x01240)), @((int)(0x01241)), @((int)(0x01248)), @((int)(0x01249)),
                                      @((int)(0x08000)), @((int)(0x08001)), @((int)(0x08008)), @((int)(0x08009)), @((int)(0x08040)), @((int)(0x08041)), @((int)(0x08048)), @((int)(0x08049)),
                                      @((int)(0x08200)), @((int)(0x08201)), @((int)(0x08208)), @((int)(0x08209)), @((int)(0x08240)), @((int)(0x08241)), @((int)(0x08248)), @((int)(0x08249)),
                                      @((int)(0x09000)), @((int)(0x09001)), @((int)(0x09008)), @((int)(0x09009)), @((int)(0x09040)), @((int)(0x09041)), @((int)(0x09048)), @((int)(0x09049)),
                                      @((int)(0x09200)), @((int)(0x09201)), @((int)(0x09208)), @((int)(0x09209)), @((int)(0x09240)), @((int)(0x09241)), @((int)(0x09248)), @((int)(0x09249)),
                                      @((int)(0x40000)), @((int)(0x40001)), @((int)(0x40008)), @((int)(0x40009)), @((int)(0x40040)), @((int)(0x40041)), @((int)(0x40048)), @((int)(0x40049)),
                                      @((int)(0x40200)), @((int)(0x40201)), @((int)(0x40208)), @((int)(0x40209)), @((int)(0x40240)), @((int)(0x40241)), @((int)(0x40248)), @((int)(0x40249)),
                                      @((int)(0x41000)), @((int)(0x41001)), @((int)(0x41008)), @((int)(0x41009)), @((int)(0x41040)), @((int)(0x41041)), @((int)(0x41048)), @((int)(0x41049)),
                                      @((int)(0x41200)), @((int)(0x41201)), @((int)(0x41208)), @((int)(0x41209)), @((int)(0x41240)), @((int)(0x41241)), @((int)(0x41248)), @((int)(0x41249)),
                                      @((int)(0x48000)), @((int)(0x48001)), @((int)(0x48008)), @((int)(0x48009)), @((int)(0x48040)), @((int)(0x48041)), @((int)(0x48048)), @((int)(0x48049)),
                                      @((int)(0x48200)), @((int)(0x48201)), @((int)(0x48208)), @((int)(0x48209)), @((int)(0x48240)), @((int)(0x48241)), @((int)(0x48248)), @((int)(0x48249)),
                                      @((int)(0x49000)), @((int)(0x49001)), @((int)(0x49008)), @((int)(0x49009)), @((int)(0x49040)), @((int)(0x49041)), @((int)(0x49048)), @((int)(0x49049)),
                                      @((int)(0x49200)), @((int)(0x49201)), @((int)(0x49208)), @((int)(0x49209)), @((int)(0x49240)), @((int)(0x49241)), @((int)(0x49248)), @((int)(0x49249)), nil];
            }
        }
    }
    return _interleave3_table;
}

/*
 * This expands 8 bit indices into 32 bit contents (high bit 28), by inserting 0s between bits.
 */
// return == int[]
+ (NSArray*)INTERLEAVE4_TABLE {
    static NSArray *_interleave4_table = nil;
    @synchronized(self) {
        if (_interleave4_table == nil) {
            @autoreleasepool {
                _interleave4_table = [[NSArray alloc] initWithObjects:
                                      @((int)(0x00000000)), @((int)(0x00000001)), @((int)(0x00000010)), @((int)(0x00000011)), @((int)(0x00000100)), @((int)(0x00000101)), @((int)(0x00000110)), @((int)(0x00000111)),
                                      @((int)(0x00001000)), @((int)(0x00001001)), @((int)(0x00001010)), @((int)(0x00001011)), @((int)(0x00001100)), @((int)(0x00001101)), @((int)(0x00001110)), @((int)(0x00001111)),
                                      @((int)(0x00010000)), @((int)(0x00010001)), @((int)(0x00010010)), @((int)(0x00010011)), @((int)(0x00010100)), @((int)(0x00010101)), @((int)(0x00010110)), @((int)(0x00010111)),
                                      @((int)(0x00011000)), @((int)(0x00011001)), @((int)(0x00011010)), @((int)(0x00011011)), @((int)(0x00011100)), @((int)(0x00011101)), @((int)(0x00011110)), @((int)(0x00011111)),
                                      @((int)(0x00100000)), @((int)(0x00100001)), @((int)(0x00100010)), @((int)(0x00100011)), @((int)(0x00100100)), @((int)(0x00100101)), @((int)(0x00100110)), @((int)(0x00100111)),
                                      @((int)(0x00101000)), @((int)(0x00101001)), @((int)(0x00101010)), @((int)(0x00101011)), @((int)(0x00101100)), @((int)(0x00101101)), @((int)(0x00101110)), @((int)(0x00101111)),
                                      @((int)(0x00110000)), @((int)(0x00110001)), @((int)(0x00110010)), @((int)(0x00110011)), @((int)(0x00110100)), @((int)(0x00110101)), @((int)(0x00110110)), @((int)(0x00110111)),
                                      @((int)(0x00111000)), @((int)(0x00111001)), @((int)(0x00111010)), @((int)(0x00111011)), @((int)(0x00111100)), @((int)(0x00111101)), @((int)(0x00111110)), @((int)(0x00111111)),
                                      @((int)(0x01000000)), @((int)(0x01000001)), @((int)(0x01000010)), @((int)(0x01000011)), @((int)(0x01000100)), @((int)(0x01000101)), @((int)(0x01000110)), @((int)(0x01000111)),
                                      @((int)(0x01001000)), @((int)(0x01001001)), @((int)(0x01001010)), @((int)(0x01001011)), @((int)(0x01001100)), @((int)(0x01001101)), @((int)(0x01001110)), @((int)(0x01001111)),
                                      @((int)(0x01010000)), @((int)(0x01010001)), @((int)(0x01010010)), @((int)(0x01010011)), @((int)(0x01010100)), @((int)(0x01010101)), @((int)(0x01010110)), @((int)(0x01010111)),
                                      @((int)(0x01011000)), @((int)(0x01011001)), @((int)(0x01011010)), @((int)(0x01011011)), @((int)(0x01011100)), @((int)(0x01011101)), @((int)(0x01011110)), @((int)(0x01011111)),
                                      @((int)(0x01100000)), @((int)(0x01100001)), @((int)(0x01100010)), @((int)(0x01100011)), @((int)(0x01100100)), @((int)(0x01100101)), @((int)(0x01100110)), @((int)(0x01100111)),
                                      @((int)(0x01101000)), @((int)(0x01101001)), @((int)(0x01101010)), @((int)(0x01101011)), @((int)(0x01101100)), @((int)(0x01101101)), @((int)(0x01101110)), @((int)(0x01101111)),
                                      @((int)(0x01110000)), @((int)(0x01110001)), @((int)(0x01110010)), @((int)(0x01110011)), @((int)(0x01110100)), @((int)(0x01110101)), @((int)(0x01110110)), @((int)(0x01110111)),
                                      @((int)(0x01111000)), @((int)(0x01111001)), @((int)(0x01111010)), @((int)(0x01111011)), @((int)(0x01111100)), @((int)(0x01111101)), @((int)(0x01111110)), @((int)(0x01111111)),
                                      @((int)(0x10000000)), @((int)(0x10000001)), @((int)(0x10000010)), @((int)(0x10000011)), @((int)(0x10000100)), @((int)(0x10000101)), @((int)(0x10000110)), @((int)(0x10000111)),
                                      @((int)(0x10001000)), @((int)(0x10001001)), @((int)(0x10001010)), @((int)(0x10001011)), @((int)(0x10001100)), @((int)(0x10001101)), @((int)(0x10001110)), @((int)(0x10001111)),
                                      @((int)(0x10010000)), @((int)(0x10010001)), @((int)(0x10010010)), @((int)(0x10010011)), @((int)(0x10010100)), @((int)(0x10010101)), @((int)(0x10010110)), @((int)(0x10010111)),
                                      @((int)(0x10011000)), @((int)(0x10011001)), @((int)(0x10011010)), @((int)(0x10011011)), @((int)(0x10011100)), @((int)(0x10011101)), @((int)(0x10011110)), @((int)(0x10011111)),
                                      @((int)(0x10100000)), @((int)(0x10100001)), @((int)(0x10100010)), @((int)(0x10100011)), @((int)(0x10100100)), @((int)(0x10100101)), @((int)(0x10100110)), @((int)(0x10100111)),
                                      @((int)(0x10101000)), @((int)(0x10101001)), @((int)(0x10101010)), @((int)(0x10101011)), @((int)(0x10101100)), @((int)(0x10101101)), @((int)(0x10101110)), @((int)(0x10101111)),
                                      @((int)(0x10110000)), @((int)(0x10110001)), @((int)(0x10110010)), @((int)(0x10110011)), @((int)(0x10110100)), @((int)(0x10110101)), @((int)(0x10110110)), @((int)(0x10110111)),
                                      @((int)(0x10111000)), @((int)(0x10111001)), @((int)(0x10111010)), @((int)(0x10111011)), @((int)(0x10111100)), @((int)(0x10111101)), @((int)(0x10111110)), @((int)(0x10111111)),
                                      @((int)(0x11000000)), @((int)(0x11000001)), @((int)(0x11000010)), @((int)(0x11000011)), @((int)(0x11000100)), @((int)(0x11000101)), @((int)(0x11000110)), @((int)(0x11000111)),
                                      @((int)(0x11001000)), @((int)(0x11001001)), @((int)(0x11001010)), @((int)(0x11001011)), @((int)(0x11001100)), @((int)(0x11001101)), @((int)(0x11001110)), @((int)(0x11001111)),
                                      @((int)(0x11010000)), @((int)(0x11010001)), @((int)(0x11010010)), @((int)(0x11010011)), @((int)(0x11010100)), @((int)(0x11010101)), @((int)(0x11010110)), @((int)(0x11010111)),
                                      @((int)(0x11011000)), @((int)(0x11011001)), @((int)(0x11011010)), @((int)(0x11011011)), @((int)(0x11011100)), @((int)(0x11011101)), @((int)(0x11011110)), @((int)(0x11011111)),
                                      @((int)(0x11100000)), @((int)(0x11100001)), @((int)(0x11100010)), @((int)(0x11100011)), @((int)(0x11100100)), @((int)(0x11100101)), @((int)(0x11100110)), @((int)(0x11100111)),
                                      @((int)(0x11101000)), @((int)(0x11101001)), @((int)(0x11101010)), @((int)(0x11101011)), @((int)(0x11101100)), @((int)(0x11101101)), @((int)(0x11101110)), @((int)(0x11101111)),
                                      @((int)(0x11110000)), @((int)(0x11110001)), @((int)(0x11110010)), @((int)(0x11110011)), @((int)(0x11110100)), @((int)(0x11110101)), @((int)(0x11110110)), @((int)(0x11110111)),
                                      @((int)(0x11111000)), @((int)(0x11111001)), @((int)(0x11111010)), @((int)(0x11111011)), @((int)(0x11111100)), @((int)(0x11111101)), @((int)(0x11111110)), @((int)(0x11111111)), nil];
            }
        }
    }
    return _interleave4_table;
}

/*
 * This expands 7 bit indices into 35 bit contents (high bit 30), by inserting 0s between bits.
 */
// return == int[]
+ (NSArray*)INTERLEAVE5_TABLE {
    static NSArray *_interleave5_table = nil;
    @synchronized(self) {
        if (_interleave5_table == nil) {
            @autoreleasepool {
                _interleave5_table = [[NSArray alloc] initWithObjects:
                                      @((int)(0x00000000)), @((int)(0x00000001)), @((int)(0x00000020)), @((int)(0x00000021)), @((int)(0x00000400)), @((int)(0x00000401)), @((int)(0x00000420)), @((int)(0x00000421)),
                                      @((int)(0x00008000)), @((int)(0x00008001)), @((int)(0x00008020)), @((int)(0x00008021)), @((int)(0x00008400)), @((int)(0x00008401)), @((int)(0x00008420)), @((int)(0x00008421)),
                                      @((int)(0x00100000)), @((int)(0x00100001)), @((int)(0x00100020)), @((int)(0x00100021)), @((int)(0x00100400)), @((int)(0x00100401)), @((int)(0x00100420)), @((int)(0x00100421)),
                                      @((int)(0x00108000)), @((int)(0x00108001)), @((int)(0x00108020)), @((int)(0x00108021)), @((int)(0x00108400)), @((int)(0x00108401)), @((int)(0x00108420)), @((int)(0x00108421)),
                                      @((int)(0x02000000)), @((int)(0x02000001)), @((int)(0x02000020)), @((int)(0x02000021)), @((int)(0x02000400)), @((int)(0x02000401)), @((int)(0x02000420)), @((int)(0x02000421)),
                                      @((int)(0x02008000)), @((int)(0x02008001)), @((int)(0x02008020)), @((int)(0x02008021)), @((int)(0x02008400)), @((int)(0x02008401)), @((int)(0x02008420)), @((int)(0x02008421)),
                                      @((int)(0x02100000)), @((int)(0x02100001)), @((int)(0x02100020)), @((int)(0x02100021)), @((int)(0x02100400)), @((int)(0x02100401)), @((int)(0x02100420)), @((int)(0x02100421)),
                                      @((int)(0x02108000)), @((int)(0x02108001)), @((int)(0x02108020)), @((int)(0x02108021)), @((int)(0x02108400)), @((int)(0x02108401)), @((int)(0x02108420)), @((int)(0x02108421)),
                                      @((int)(0x40000000)), @((int)(0x40000001)), @((int)(0x40000020)), @((int)(0x40000021)), @((int)(0x40000400)), @((int)(0x40000401)), @((int)(0x40000420)), @((int)(0x40000421)),
                                      @((int)(0x40008000)), @((int)(0x40008001)), @((int)(0x40008020)), @((int)(0x40008021)), @((int)(0x40008400)), @((int)(0x40008401)), @((int)(0x40008420)), @((int)(0x40008421)),
                                      @((int)(0x40100000)), @((int)(0x40100001)), @((int)(0x40100020)), @((int)(0x40100021)), @((int)(0x40100400)), @((int)(0x40100401)), @((int)(0x40100420)), @((int)(0x40100421)),
                                      @((int)(0x40108000)), @((int)(0x40108001)), @((int)(0x40108020)), @((int)(0x40108021)), @((int)(0x40108400)), @((int)(0x40108401)), @((int)(0x40108420)), @((int)(0x40108421)),
                                      @((int)(0x42000000)), @((int)(0x42000001)), @((int)(0x42000020)), @((int)(0x42000021)), @((int)(0x42000400)), @((int)(0x42000401)), @((int)(0x42000420)), @((int)(0x42000421)),
                                      @((int)(0x42008000)), @((int)(0x42008001)), @((int)(0x42008020)), @((int)(0x42008021)), @((int)(0x42008400)), @((int)(0x42008401)), @((int)(0x42008420)), @((int)(0x42008421)),
                                      @((int)(0x42100000)), @((int)(0x42100001)), @((int)(0x42100020)), @((int)(0x42100021)), @((int)(0x42100400)), @((int)(0x42100401)), @((int)(0x42100420)), @((int)(0x42100421)),
                                      @((int)(0x42108000)), @((int)(0x42108001)), @((int)(0x42108020)), @((int)(0x42108021)), @((int)(0x42108400)), @((int)(0x42108401)), @((int)(0x42108420)), @((int)(0x42108421)), nil];
            }
        }
    }
    return _interleave5_table;
}

/*
 * This expands 9 bit indices into 63 bit (long) contents (high bit 56), by inserting 0s between bits.
 */
// return == long[]
+ (NSArray*)INTERLEAVE7_TABLE {
    static NSArray *_interleave7_table = nil;
    @synchronized(self) {
        if (_interleave7_table == nil) {
            @autoreleasepool {
                _interleave7_table = [[NSArray alloc] initWithObjects:
                                      @((int64_t)(0x0000000000000000LL)), @((int64_t)(0x0000000000000001LL)), @((int64_t)(0x0000000000000080LL)), @((int64_t)(0x0000000000000081LL)),
                                      @((int64_t)(0x0000000000004000LL)), @((int64_t)(0x0000000000004001LL)), @((int64_t)(0x0000000000004080LL)), @((int64_t)(0x0000000000004081LL)),
                                      @((int64_t)(0x0000000000200000LL)), @((int64_t)(0x0000000000200001LL)), @((int64_t)(0x0000000000200080LL)), @((int64_t)(0x0000000000200081LL)),
                                      @((int64_t)(0x0000000000204000LL)), @((int64_t)(0x0000000000204001LL)), @((int64_t)(0x0000000000204080LL)), @((int64_t)(0x0000000000204081LL)),
                                      @((int64_t)(0x0000000010000000LL)), @((int64_t)(0x0000000010000001LL)), @((int64_t)(0x0000000010000080LL)), @((int64_t)(0x0000000010000081LL)),
                                      @((int64_t)(0x0000000010004000LL)), @((int64_t)(0x0000000010004001LL)), @((int64_t)(0x0000000010004080LL)), @((int64_t)(0x0000000010004081LL)),
                                      @((int64_t)(0x0000000010200000LL)), @((int64_t)(0x0000000010200001LL)), @((int64_t)(0x0000000010200080LL)), @((int64_t)(0x0000000010200081LL)),
                                      @((int64_t)(0x0000000010204000LL)), @((int64_t)(0x0000000010204001LL)), @((int64_t)(0x0000000010204080LL)), @((int64_t)(0x0000000010204081LL)),
                                      @((int64_t)(0x0000000800000000LL)), @((int64_t)(0x0000000800000001LL)), @((int64_t)(0x0000000800000080LL)), @((int64_t)(0x0000000800000081LL)),
                                      @((int64_t)(0x0000000800004000LL)), @((int64_t)(0x0000000800004001LL)), @((int64_t)(0x0000000800004080LL)), @((int64_t)(0x0000000800004081LL)),
                                      @((int64_t)(0x0000000800200000LL)), @((int64_t)(0x0000000800200001LL)), @((int64_t)(0x0000000800200080LL)), @((int64_t)(0x0000000800200081LL)),
                                      @((int64_t)(0x0000000800204000LL)), @((int64_t)(0x0000000800204001LL)), @((int64_t)(0x0000000800204080LL)), @((int64_t)(0x0000000800204081LL)),
                                      @((int64_t)(0x0000000810000000LL)), @((int64_t)(0x0000000810000001LL)), @((int64_t)(0x0000000810000080LL)), @((int64_t)(0x0000000810000081LL)),
                                      @((int64_t)(0x0000000810004000LL)), @((int64_t)(0x0000000810004001LL)), @((int64_t)(0x0000000810004080LL)), @((int64_t)(0x0000000810004081LL)),
                                      @((int64_t)(0x0000000810200000LL)), @((int64_t)(0x0000000810200001LL)), @((int64_t)(0x0000000810200080LL)), @((int64_t)(0x0000000810200081LL)),
                                      @((int64_t)(0x0000000810204000LL)), @((int64_t)(0x0000000810204001LL)), @((int64_t)(0x0000000810204080LL)), @((int64_t)(0x0000000810204081LL)),
                                      @((int64_t)(0x0000040000000000LL)), @((int64_t)(0x0000040000000001LL)), @((int64_t)(0x0000040000000080LL)), @((int64_t)(0x0000040000000081LL)),
                                      @((int64_t)(0x0000040000004000LL)), @((int64_t)(0x0000040000004001LL)), @((int64_t)(0x0000040000004080LL)), @((int64_t)(0x0000040000004081LL)),
                                      @((int64_t)(0x0000040000200000LL)), @((int64_t)(0x0000040000200001LL)), @((int64_t)(0x0000040000200080LL)), @((int64_t)(0x0000040000200081LL)),
                                      @((int64_t)(0x0000040000204000LL)), @((int64_t)(0x0000040000204001LL)), @((int64_t)(0x0000040000204080LL)), @((int64_t)(0x0000040000204081LL)),
                                      @((int64_t)(0x0000040010000000LL)), @((int64_t)(0x0000040010000001LL)), @((int64_t)(0x0000040010000080LL)), @((int64_t)(0x0000040010000081LL)),
                                      @((int64_t)(0x0000040010004000LL)), @((int64_t)(0x0000040010004001LL)), @((int64_t)(0x0000040010004080LL)), @((int64_t)(0x0000040010004081LL)),
                                      @((int64_t)(0x0000040010200000LL)), @((int64_t)(0x0000040010200001LL)), @((int64_t)(0x0000040010200080LL)), @((int64_t)(0x0000040010200081LL)),
                                      @((int64_t)(0x0000040010204000LL)), @((int64_t)(0x0000040010204001LL)), @((int64_t)(0x0000040010204080LL)), @((int64_t)(0x0000040010204081LL)),
                                      @((int64_t)(0x0000040800000000LL)), @((int64_t)(0x0000040800000001LL)), @((int64_t)(0x0000040800000080LL)), @((int64_t)(0x0000040800000081LL)),
                                      @((int64_t)(0x0000040800004000LL)), @((int64_t)(0x0000040800004001LL)), @((int64_t)(0x0000040800004080LL)), @((int64_t)(0x0000040800004081LL)),
                                      @((int64_t)(0x0000040800200000LL)), @((int64_t)(0x0000040800200001LL)), @((int64_t)(0x0000040800200080LL)), @((int64_t)(0x0000040800200081LL)),
                                      @((int64_t)(0x0000040800204000LL)), @((int64_t)(0x0000040800204001LL)), @((int64_t)(0x0000040800204080LL)), @((int64_t)(0x0000040800204081LL)),
                                      @((int64_t)(0x0000040810000000LL)), @((int64_t)(0x0000040810000001LL)), @((int64_t)(0x0000040810000080LL)), @((int64_t)(0x0000040810000081LL)),
                                      @((int64_t)(0x0000040810004000LL)), @((int64_t)(0x0000040810004001LL)), @((int64_t)(0x0000040810004080LL)), @((int64_t)(0x0000040810004081LL)),
                                      @((int64_t)(0x0000040810200000LL)), @((int64_t)(0x0000040810200001LL)), @((int64_t)(0x0000040810200080LL)), @((int64_t)(0x0000040810200081LL)),
                                      @((int64_t)(0x0000040810204000LL)), @((int64_t)(0x0000040810204001LL)), @((int64_t)(0x0000040810204080LL)), @((int64_t)(0x0000040810204081LL)),
                                      @((int64_t)(0x0002000000000000LL)), @((int64_t)(0x0002000000000001LL)), @((int64_t)(0x0002000000000080LL)), @((int64_t)(0x0002000000000081LL)),
                                      @((int64_t)(0x0002000000004000LL)), @((int64_t)(0x0002000000004001LL)), @((int64_t)(0x0002000000004080LL)), @((int64_t)(0x0002000000004081LL)),
                                      @((int64_t)(0x0002000000200000LL)), @((int64_t)(0x0002000000200001LL)), @((int64_t)(0x0002000000200080LL)), @((int64_t)(0x0002000000200081LL)),
                                      @((int64_t)(0x0002000000204000LL)), @((int64_t)(0x0002000000204001LL)), @((int64_t)(0x0002000000204080LL)), @((int64_t)(0x0002000000204081LL)),
                                      @((int64_t)(0x0002000010000000LL)), @((int64_t)(0x0002000010000001LL)), @((int64_t)(0x0002000010000080LL)), @((int64_t)(0x0002000010000081LL)),
                                      @((int64_t)(0x0002000010004000LL)), @((int64_t)(0x0002000010004001LL)), @((int64_t)(0x0002000010004080LL)), @((int64_t)(0x0002000010004081LL)),
                                      @((int64_t)(0x0002000010200000LL)), @((int64_t)(0x0002000010200001LL)), @((int64_t)(0x0002000010200080LL)), @((int64_t)(0x0002000010200081LL)),
                                      @((int64_t)(0x0002000010204000LL)), @((int64_t)(0x0002000010204001LL)), @((int64_t)(0x0002000010204080LL)), @((int64_t)(0x0002000010204081LL)),
                                      @((int64_t)(0x0002000800000000LL)), @((int64_t)(0x0002000800000001LL)), @((int64_t)(0x0002000800000080LL)), @((int64_t)(0x0002000800000081LL)),
                                      @((int64_t)(0x0002000800004000LL)), @((int64_t)(0x0002000800004001LL)), @((int64_t)(0x0002000800004080LL)), @((int64_t)(0x0002000800004081LL)),
                                      @((int64_t)(0x0002000800200000LL)), @((int64_t)(0x0002000800200001LL)), @((int64_t)(0x0002000800200080LL)), @((int64_t)(0x0002000800200081LL)),
                                      @((int64_t)(0x0002000800204000LL)), @((int64_t)(0x0002000800204001LL)), @((int64_t)(0x0002000800204080LL)), @((int64_t)(0x0002000800204081LL)),
                                      @((int64_t)(0x0002000810000000LL)), @((int64_t)(0x0002000810000001LL)), @((int64_t)(0x0002000810000080LL)), @((int64_t)(0x0002000810000081LL)),
                                      @((int64_t)(0x0002000810004000LL)), @((int64_t)(0x0002000810004001LL)), @((int64_t)(0x0002000810004080LL)), @((int64_t)(0x0002000810004081LL)),
                                      @((int64_t)(0x0002000810200000LL)), @((int64_t)(0x0002000810200001LL)), @((int64_t)(0x0002000810200080LL)), @((int64_t)(0x0002000810200081LL)),
                                      @((int64_t)(0x0002000810204000LL)), @((int64_t)(0x0002000810204001LL)), @((int64_t)(0x0002000810204080LL)), @((int64_t)(0x0002000810204081LL)),
                                      @((int64_t)(0x0002040000000000LL)), @((int64_t)(0x0002040000000001LL)), @((int64_t)(0x0002040000000080LL)), @((int64_t)(0x0002040000000081LL)),
                                      @((int64_t)(0x0002040000004000LL)), @((int64_t)(0x0002040000004001LL)), @((int64_t)(0x0002040000004080LL)), @((int64_t)(0x0002040000004081LL)),
                                      @((int64_t)(0x0002040000200000LL)), @((int64_t)(0x0002040000200001LL)), @((int64_t)(0x0002040000200080LL)), @((int64_t)(0x0002040000200081LL)),
                                      @((int64_t)(0x0002040000204000LL)), @((int64_t)(0x0002040000204001LL)), @((int64_t)(0x0002040000204080LL)), @((int64_t)(0x0002040000204081LL)),
                                      @((int64_t)(0x0002040010000000LL)), @((int64_t)(0x0002040010000001LL)), @((int64_t)(0x0002040010000080LL)), @((int64_t)(0x0002040010000081LL)),
                                      @((int64_t)(0x0002040010004000LL)), @((int64_t)(0x0002040010004001LL)), @((int64_t)(0x0002040010004080LL)), @((int64_t)(0x0002040010004081LL)),
                                      @((int64_t)(0x0002040010200000LL)), @((int64_t)(0x0002040010200001LL)), @((int64_t)(0x0002040010200080LL)), @((int64_t)(0x0002040010200081LL)),
                                      @((int64_t)(0x0002040010204000LL)), @((int64_t)(0x0002040010204001LL)), @((int64_t)(0x0002040010204080LL)), @((int64_t)(0x0002040010204081LL)),
                                      @((int64_t)(0x0002040800000000LL)), @((int64_t)(0x0002040800000001LL)), @((int64_t)(0x0002040800000080LL)), @((int64_t)(0x0002040800000081LL)),
                                      @((int64_t)(0x0002040800004000LL)), @((int64_t)(0x0002040800004001LL)), @((int64_t)(0x0002040800004080LL)), @((int64_t)(0x0002040800004081LL)),
                                      @((int64_t)(0x0002040800200000LL)), @((int64_t)(0x0002040800200001LL)), @((int64_t)(0x0002040800200080LL)), @((int64_t)(0x0002040800200081LL)),
                                      @((int64_t)(0x0002040800204000LL)), @((int64_t)(0x0002040800204001LL)), @((int64_t)(0x0002040800204080LL)), @((int64_t)(0x0002040800204081LL)),
                                      @((int64_t)(0x0002040810000000LL)), @((int64_t)(0x0002040810000001LL)), @((int64_t)(0x0002040810000080LL)), @((int64_t)(0x0002040810000081LL)),
                                      @((int64_t)(0x0002040810004000LL)), @((int64_t)(0x0002040810004001LL)), @((int64_t)(0x0002040810004080LL)), @((int64_t)(0x0002040810004081LL)),
                                      @((int64_t)(0x0002040810200000LL)), @((int64_t)(0x0002040810200001LL)), @((int64_t)(0x0002040810200080LL)), @((int64_t)(0x0002040810200081LL)),
                                      @((int64_t)(0x0002040810204000LL)), @((int64_t)(0x0002040810204001LL)), @((int64_t)(0x0002040810204080LL)), @((int64_t)(0x0002040810204081LL)),
                                      @((int64_t)(0x0100000000000000LL)), @((int64_t)(0x0100000000000001LL)), @((int64_t)(0x0100000000000080LL)), @((int64_t)(0x0100000000000081LL)),
                                      @((int64_t)(0x0100000000004000LL)), @((int64_t)(0x0100000000004001LL)), @((int64_t)(0x0100000000004080LL)), @((int64_t)(0x0100000000004081LL)),
                                      @((int64_t)(0x0100000000200000LL)), @((int64_t)(0x0100000000200001LL)), @((int64_t)(0x0100000000200080LL)), @((int64_t)(0x0100000000200081LL)),
                                      @((int64_t)(0x0100000000204000LL)), @((int64_t)(0x0100000000204001LL)), @((int64_t)(0x0100000000204080LL)), @((int64_t)(0x0100000000204081LL)),
                                      @((int64_t)(0x0100000010000000LL)), @((int64_t)(0x0100000010000001LL)), @((int64_t)(0x0100000010000080LL)), @((int64_t)(0x0100000010000081LL)),
                                      @((int64_t)(0x0100000010004000LL)), @((int64_t)(0x0100000010004001LL)), @((int64_t)(0x0100000010004080LL)), @((int64_t)(0x0100000010004081LL)),
                                      @((int64_t)(0x0100000010200000LL)), @((int64_t)(0x0100000010200001LL)), @((int64_t)(0x0100000010200080LL)), @((int64_t)(0x0100000010200081LL)),
                                      @((int64_t)(0x0100000010204000LL)), @((int64_t)(0x0100000010204001LL)), @((int64_t)(0x0100000010204080LL)), @((int64_t)(0x0100000010204081LL)),
                                      @((int64_t)(0x0100000800000000LL)), @((int64_t)(0x0100000800000001LL)), @((int64_t)(0x0100000800000080LL)), @((int64_t)(0x0100000800000081LL)),
                                      @((int64_t)(0x0100000800004000LL)), @((int64_t)(0x0100000800004001LL)), @((int64_t)(0x0100000800004080LL)), @((int64_t)(0x0100000800004081LL)),
                                      @((int64_t)(0x0100000800200000LL)), @((int64_t)(0x0100000800200001LL)), @((int64_t)(0x0100000800200080LL)), @((int64_t)(0x0100000800200081LL)),
                                      @((int64_t)(0x0100000800204000LL)), @((int64_t)(0x0100000800204001LL)), @((int64_t)(0x0100000800204080LL)), @((int64_t)(0x0100000800204081LL)),
                                      @((int64_t)(0x0100000810000000LL)), @((int64_t)(0x0100000810000001LL)), @((int64_t)(0x0100000810000080LL)), @((int64_t)(0x0100000810000081LL)),
                                      @((int64_t)(0x0100000810004000LL)), @((int64_t)(0x0100000810004001LL)), @((int64_t)(0x0100000810004080LL)), @((int64_t)(0x0100000810004081LL)),
                                      @((int64_t)(0x0100000810200000LL)), @((int64_t)(0x0100000810200001LL)), @((int64_t)(0x0100000810200080LL)), @((int64_t)(0x0100000810200081LL)),
                                      @((int64_t)(0x0100000810204000LL)), @((int64_t)(0x0100000810204001LL)), @((int64_t)(0x0100000810204080LL)), @((int64_t)(0x0100000810204081LL)),
                                      @((int64_t)(0x0100040000000000LL)), @((int64_t)(0x0100040000000001LL)), @((int64_t)(0x0100040000000080LL)), @((int64_t)(0x0100040000000081LL)),
                                      @((int64_t)(0x0100040000004000LL)), @((int64_t)(0x0100040000004001LL)), @((int64_t)(0x0100040000004080LL)), @((int64_t)(0x0100040000004081LL)),
                                      @((int64_t)(0x0100040000200000LL)), @((int64_t)(0x0100040000200001LL)), @((int64_t)(0x0100040000200080LL)), @((int64_t)(0x0100040000200081LL)),
                                      @((int64_t)(0x0100040000204000LL)), @((int64_t)(0x0100040000204001LL)), @((int64_t)(0x0100040000204080LL)), @((int64_t)(0x0100040000204081LL)),
                                      @((int64_t)(0x0100040010000000LL)), @((int64_t)(0x0100040010000001LL)), @((int64_t)(0x0100040010000080LL)), @((int64_t)(0x0100040010000081LL)),
                                      @((int64_t)(0x0100040010004000LL)), @((int64_t)(0x0100040010004001LL)), @((int64_t)(0x0100040010004080LL)), @((int64_t)(0x0100040010004081LL)),
                                      @((int64_t)(0x0100040010200000LL)), @((int64_t)(0x0100040010200001LL)), @((int64_t)(0x0100040010200080LL)), @((int64_t)(0x0100040010200081LL)),
                                      @((int64_t)(0x0100040010204000LL)), @((int64_t)(0x0100040010204001LL)), @((int64_t)(0x0100040010204080LL)), @((int64_t)(0x0100040010204081LL)),
                                      @((int64_t)(0x0100040800000000LL)), @((int64_t)(0x0100040800000001LL)), @((int64_t)(0x0100040800000080LL)), @((int64_t)(0x0100040800000081LL)),
                                      @((int64_t)(0x0100040800004000LL)), @((int64_t)(0x0100040800004001LL)), @((int64_t)(0x0100040800004080LL)), @((int64_t)(0x0100040800004081LL)),
                                      @((int64_t)(0x0100040800200000LL)), @((int64_t)(0x0100040800200001LL)), @((int64_t)(0x0100040800200080LL)), @((int64_t)(0x0100040800200081LL)),
                                      @((int64_t)(0x0100040800204000LL)), @((int64_t)(0x0100040800204001LL)), @((int64_t)(0x0100040800204080LL)), @((int64_t)(0x0100040800204081LL)),
                                      @((int64_t)(0x0100040810000000LL)), @((int64_t)(0x0100040810000001LL)), @((int64_t)(0x0100040810000080LL)), @((int64_t)(0x0100040810000081LL)),
                                      @((int64_t)(0x0100040810004000LL)), @((int64_t)(0x0100040810004001LL)), @((int64_t)(0x0100040810004080LL)), @((int64_t)(0x0100040810004081LL)),
                                      @((int64_t)(0x0100040810200000LL)), @((int64_t)(0x0100040810200001LL)), @((int64_t)(0x0100040810200080LL)), @((int64_t)(0x0100040810200081LL)),
                                      @((int64_t)(0x0100040810204000LL)), @((int64_t)(0x0100040810204001LL)), @((int64_t)(0x0100040810204080LL)), @((int64_t)(0x0100040810204081LL)),
                                      @((int64_t)(0x0102000000000000LL)), @((int64_t)(0x0102000000000001LL)), @((int64_t)(0x0102000000000080LL)), @((int64_t)(0x0102000000000081LL)),
                                      @((int64_t)(0x0102000000004000LL)), @((int64_t)(0x0102000000004001LL)), @((int64_t)(0x0102000000004080LL)), @((int64_t)(0x0102000000004081LL)),
                                      @((int64_t)(0x0102000000200000LL)), @((int64_t)(0x0102000000200001LL)), @((int64_t)(0x0102000000200080LL)), @((int64_t)(0x0102000000200081LL)),
                                      @((int64_t)(0x0102000000204000LL)), @((int64_t)(0x0102000000204001LL)), @((int64_t)(0x0102000000204080LL)), @((int64_t)(0x0102000000204081LL)),
                                      @((int64_t)(0x0102000010000000LL)), @((int64_t)(0x0102000010000001LL)), @((int64_t)(0x0102000010000080LL)), @((int64_t)(0x0102000010000081LL)),
                                      @((int64_t)(0x0102000010004000LL)), @((int64_t)(0x0102000010004001LL)), @((int64_t)(0x0102000010004080LL)), @((int64_t)(0x0102000010004081LL)),
                                      @((int64_t)(0x0102000010200000LL)), @((int64_t)(0x0102000010200001LL)), @((int64_t)(0x0102000010200080LL)), @((int64_t)(0x0102000010200081LL)),
                                      @((int64_t)(0x0102000010204000LL)), @((int64_t)(0x0102000010204001LL)), @((int64_t)(0x0102000010204080LL)), @((int64_t)(0x0102000010204081LL)),
                                      @((int64_t)(0x0102000800000000LL)), @((int64_t)(0x0102000800000001LL)), @((int64_t)(0x0102000800000080LL)), @((int64_t)(0x0102000800000081LL)),
                                      @((int64_t)(0x0102000800004000LL)), @((int64_t)(0x0102000800004001LL)), @((int64_t)(0x0102000800004080LL)), @((int64_t)(0x0102000800004081LL)),
                                      @((int64_t)(0x0102000800200000LL)), @((int64_t)(0x0102000800200001LL)), @((int64_t)(0x0102000800200080LL)), @((int64_t)(0x0102000800200081LL)),
                                      @((int64_t)(0x0102000800204000LL)), @((int64_t)(0x0102000800204001LL)), @((int64_t)(0x0102000800204080LL)), @((int64_t)(0x0102000800204081LL)),
                                      @((int64_t)(0x0102000810000000LL)), @((int64_t)(0x0102000810000001LL)), @((int64_t)(0x0102000810000080LL)), @((int64_t)(0x0102000810000081LL)),
                                      @((int64_t)(0x0102000810004000LL)), @((int64_t)(0x0102000810004001LL)), @((int64_t)(0x0102000810004080LL)), @((int64_t)(0x0102000810004081LL)),
                                      @((int64_t)(0x0102000810200000LL)), @((int64_t)(0x0102000810200001LL)), @((int64_t)(0x0102000810200080LL)), @((int64_t)(0x0102000810200081LL)),
                                      @((int64_t)(0x0102000810204000LL)), @((int64_t)(0x0102000810204001LL)), @((int64_t)(0x0102000810204080LL)), @((int64_t)(0x0102000810204081LL)),
                                      @((int64_t)(0x0102040000000000LL)), @((int64_t)(0x0102040000000001LL)), @((int64_t)(0x0102040000000080LL)), @((int64_t)(0x0102040000000081LL)),
                                      @((int64_t)(0x0102040000004000LL)), @((int64_t)(0x0102040000004001LL)), @((int64_t)(0x0102040000004080LL)), @((int64_t)(0x0102040000004081LL)),
                                      @((int64_t)(0x0102040000200000LL)), @((int64_t)(0x0102040000200001LL)), @((int64_t)(0x0102040000200080LL)), @((int64_t)(0x0102040000200081LL)),
                                      @((int64_t)(0x0102040000204000LL)), @((int64_t)(0x0102040000204001LL)), @((int64_t)(0x0102040000204080LL)), @((int64_t)(0x0102040000204081LL)),
                                      @((int64_t)(0x0102040010000000LL)), @((int64_t)(0x0102040010000001LL)), @((int64_t)(0x0102040010000080LL)), @((int64_t)(0x0102040010000081LL)),
                                      @((int64_t)(0x0102040010004000LL)), @((int64_t)(0x0102040010004001LL)), @((int64_t)(0x0102040010004080LL)), @((int64_t)(0x0102040010004081LL)),
                                      @((int64_t)(0x0102040010200000LL)), @((int64_t)(0x0102040010200001LL)), @((int64_t)(0x0102040010200080LL)), @((int64_t)(0x0102040010200081LL)),
                                      @((int64_t)(0x0102040010204000LL)), @((int64_t)(0x0102040010204001LL)), @((int64_t)(0x0102040010204080LL)), @((int64_t)(0x0102040010204081LL)),
                                      @((int64_t)(0x0102040800000000LL)), @((int64_t)(0x0102040800000001LL)), @((int64_t)(0x0102040800000080LL)), @((int64_t)(0x0102040800000081LL)),
                                      @((int64_t)(0x0102040800004000LL)), @((int64_t)(0x0102040800004001LL)), @((int64_t)(0x0102040800004080LL)), @((int64_t)(0x0102040800004081LL)),
                                      @((int64_t)(0x0102040800200000LL)), @((int64_t)(0x0102040800200001LL)), @((int64_t)(0x0102040800200080LL)), @((int64_t)(0x0102040800200081LL)),
                                      @((int64_t)(0x0102040800204000LL)), @((int64_t)(0x0102040800204001LL)), @((int64_t)(0x0102040800204080LL)), @((int64_t)(0x0102040800204081LL)),
                                      @((int64_t)(0x0102040810000000LL)), @((int64_t)(0x0102040810000001LL)), @((int64_t)(0x0102040810000080LL)), @((int64_t)(0x0102040810000081LL)),
                                      @((int64_t)(0x0102040810004000LL)), @((int64_t)(0x0102040810004001LL)), @((int64_t)(0x0102040810004080LL)), @((int64_t)(0x0102040810004081LL)),
                                      @((int64_t)(0x0102040810200000LL)), @((int64_t)(0x0102040810200001LL)), @((int64_t)(0x0102040810200080LL)), @((int64_t)(0x0102040810200081LL)),
                                      @((int64_t)(0x0102040810204000LL)), @((int64_t)(0x0102040810204001LL)), @((int64_t)(0x0102040810204080LL)), @((int64_t)(0x0102040810204081LL)), nil];
                
            }
        }
    }
    return _interleave7_table;
}

+ (NSData*)BitLengths {
    static NSMutableData *_bitlengths = nil;
    @synchronized(self) {
        if (_bitlengths == nil) {
            _bitlengths = [[NSMutableData alloc] initWithSize:256];
            ((Byte*)(_bitlengths.bytes))[0] = 0;
            ((Byte*)(_bitlengths.bytes))[1] = 1;
            for (int i = 2; i < 4; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 2;
            }
            for (int i = 4; i < 8; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 3;
            }
            for (int i = 8; i < 16; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 4;
            }
            for (int i = 16; i < 32; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 5;
            }
            for (int i = 32; i < 64; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 6;
            }
            for (int i = 64; i < 128; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 7;
            }
            for (int i = 128; i < 256; i++) {
                ((Byte*)(_bitlengths.bytes))[i] = 8;
            }
        }
    }
    return _bitlengths;
}

- (id)initWithIntLen:(int)intLen {
    if (self = [super init]) {
        @autoreleasepool {
            NSMutableArray *tmpArray = [[NSMutableArray alloc] initWithSize:intLen];
            [self setM_ints:tmpArray];
#if !__has_feature(objc_arc)
            if (tmpArray != nil) [tmpArray release]; tmpArray = nil;
#endif
        }
        return self;
    } else {
        return nil;
    }
}

// ints == long[]
- (id)initWithInts:(NSMutableArray*)ints {
    if (self = [super init]) {
        [self setM_ints:ints];
        return self;
    } else {
        return nil;
    }
}

// ints == long[]
- (id)initWithInts:(NSMutableArray*)ints withOff:(int)off withLen:(int)len {
    if (self = [super init]) {
        if (off == 0 && len == ints.count) {
            [self setM_ints:ints];
        } else {
            @autoreleasepool {
                NSMutableArray *tmpArray = [[NSMutableArray alloc] initWithSize:len];
                [self setM_ints:tmpArray];
#if !__has_feature(objc_arc)
                if (tmpArray != nil) [tmpArray release]; tmpArray = nil;
#endif
                [self.m_ints copyFromIndex:0 withSource:ints withSourceIndex:off withLength:len];
            }
        }
        return self;
    } else {
        return nil;
    }
}

- (id)initWithBigInt:(BigInteger*)bigInt {
    if (self = [super init]) {
        @autoreleasepool {
            if (bigInt == nil || [bigInt signValue] < 0) {
                @throw [NSException exceptionWithName:@"Argument" reason:@"bigInt is invalid F2m field value" userInfo:nil];
            }
            if ([bigInt signValue] == 0) {
                NSMutableArray *tmpArray = [[NSMutableArray alloc] initWithObjects:@((int64_t)0LL), nil];
                [self setM_ints:tmpArray];
#if !__has_feature(objc_arc)
                if (tmpArray != nil) [tmpArray release]; tmpArray = nil;
#endif
                return self;
            }
            
            NSMutableData *barr = [bigInt toByteArray];
            int barrLen = (int)(barr.length);
            int barrStart = 0;
            if (((Byte*)(barr.bytes))[0] == 0) {
                // First byte is 0 to enforce highest (=sign) bit is zero. In this case ignore barr[0].
                barrLen--;
                barrStart = 1;
            }
            int intLen = (barrLen + 7) / 8;
            NSMutableArray *tmpArray = [[NSMutableArray alloc] initWithSize:intLen];
            [self setM_ints:tmpArray];
#if !__has_feature(objc_arc)
            if (tmpArray != nil) [tmpArray release]; tmpArray = nil;
#endif
            
            int iarrJ = intLen - 1;
            int rem = barrLen % 8 + barrStart;
            int64_t temp = 0;
            int barrI = barrStart;
            if (barrStart < rem) {
                for (; barrI < rem; barrI++) {
                    temp <<= 8;
                    uint barrBarrI = (uint)(((Byte*)(barr.bytes))[barrI]);
                    temp |= barrBarrI;
                }
                self.m_ints[iarrJ--] = @(temp);
            }
            
            for (; iarrJ >= 0; iarrJ--) {
                temp = 0;
                for (int i = 0; i < 8; i++) {
                    temp <<= 8;
                    uint barrBarrI = (uint)(((Byte*)(barr.bytes))[barrI++]);
                    temp |= barrBarrI;
                }
                self.m_ints[iarrJ] = @(temp);
            }
        }
        return self;
    } else {
        return nil;
    }
}

- (BOOL)isOne {
    BOOL retVal = YES;
    @autoreleasepool {
        NSMutableArray *a = self.m_ints;
        if ([a[0] longLongValue] != 1LL) {
            retVal = NO;
        } else {
            for (int i = 1; i < a.count; ++i) {
                if ([a[i] longLongValue] != 0LL) {
                    retVal = NO;
                    break;
                }
            }
        }
    }
    return retVal;
}

- (BOOL)isZero {
    BOOL retVal = YES;
    @autoreleasepool {
        NSMutableArray *a = self.m_ints;
        for (int i = 0; i < a.count; ++i) {
            if ([a[i] longLongValue] != 0LL) {
                retVal = NO;
                break;
            }
        }
    }
    return retVal;
}

- (int)getUsedLength {
    return [self getUsedLengthFrom:(int)(self.m_ints.count)];
}

- (int)getUsedLengthFrom:(int)from {
    int retVal = 0;
    @autoreleasepool {
        NSMutableArray *a = self.m_ints;
        from = MIN(from, (int)(a.count));
        
        if (from < 1) {
            retVal = 0;
        } else {
            // Check if first element will act as sentinel
            if ([a[0] longLongValue] != 0) {
                while ([a[--from] longLongValue] == 0) {
                }
                retVal = from + 1;
            } else {
                do {
                    if ([a[--from] longLongValue] != 0) {
                        retVal = from + 1;
                    }
                } while (from > 0);
            }
        }
    }
    return retVal;
}

- (int)degree {
    int retVal = 0;
    @autoreleasepool {
        int i = (int)(self.m_ints.count);
        int64_t w;
        do {
            if (i == 0) {
                return 0;
            }
            w = [self.m_ints[--i] longLongValue];
        }
        while (w == 0);
        
        retVal = (i << 6) + [LongArray bitLength:w];
    }
    return retVal;
}

- (int)degreeFrom:(int)limit {
    int retVal = 0;
    @autoreleasepool {
        int i = (int)(((uint)limit + 62) >> 6);
        int64_t w;
        do {
            if (i == 0) {
                return 0;
            }
            w = [self.m_ints[--i] longLongValue];
        } while (w == 0);
        
        retVal = (i << 6) + [LongArray bitLength:w];
    }
    return retVal;
}

+ (int)bitLength:(int64_t)w {
    int retVal = 0;
    @autoreleasepool {
        int u = (int)((uint64_t)w >> 32), b;
        if (u == 0){
            u = (int)w;
            b = 0;
        } else {
            b = 32;
        }
        
        int t = (int)((uint)u >> 16), k;
        if (t == 0) {
            t = (int)((uint)u >> 8);
            k = (t == 0) ? ((Byte*)([LongArray BitLengths].bytes))[u] : 8 + ((Byte*)([LongArray BitLengths].bytes))[t];
        } else {
            int v = (int)((uint)t >> 8);
            k = (v == 0) ? 16 + ((Byte*)([LongArray BitLengths].bytes))[t] : 24 + ((Byte*)([LongArray BitLengths].bytes))[v];
        }
        
        retVal = b + k;
    }
    return retVal;
}

// return == long[]
- (NSMutableArray*)resizedInts:(int)newLen {
    NSMutableArray *newInts = [[[NSMutableArray alloc] initWithSize:newLen] autorelease];
    [newInts copyFromIndex:0 withSource:self.m_ints withSourceIndex:0 withLength:MIN((int)(self.m_ints.count), newLen)];
    return newInts;
}

- (BigInteger*)toBigInteger {
    BigInteger *retVal = nil;
    @autoreleasepool {
        int usedLen = [self getUsedLength];
        if (usedLen == 0) {
            return [BigInteger Zero];
        }
        
        int64_t highestInt = [self.m_ints[usedLen - 1] longLongValue];
        NSMutableData *temp = [[NSMutableData alloc] initWithSize:8];
        int barrI = 0;
        BOOL trailingZeroBytesDone = NO;
        for (int j = 7; j >= 0; j--) {
            Byte thisByte = (Byte)((uint64_t)highestInt >> (8 * j));
            if (trailingZeroBytesDone || (thisByte != 0)) {
                trailingZeroBytesDone = YES;
                ((Byte*)(temp.bytes))[barrI++] = thisByte;
            }
        }
        
        int barrLen = 8 * (usedLen - 1) + barrI;
        NSMutableData *barr = [[NSMutableData alloc] initWithSize:barrLen];
        for (int j = 0; j < barrI; j++) {
            ((Byte*)(barr.bytes))[j] = ((Byte*)(temp))[j];
        }
        // Highest value int is done now
        
        for (int iarrJ = usedLen - 2; iarrJ >= 0; iarrJ--) {
            int64_t mi = [self.m_ints[iarrJ] longLongValue];
            for (int j = 7; j >= 0; j--) {
                ((Byte*)(barr.bytes))[barrI++] = (Byte)((uint64_t)mi >> (8 * j));
            }
        }
        retVal = [[BigInteger alloc] initWithSign:1 withBytes:barr];
#if !__has_feature(objc_arc)
        if (temp != nil) [temp release]; temp = nil;
        if (barr != nil) [barr release]; barr = nil;
#endif
    }
    return (retVal ? [retVal autorelease] : nil);
}

// x == long[]
+ (int64_t)shiftUp:(NSMutableArray*)x withXoff:(int)xOff withCount:(int)count withShift:(int)shift {
    int64_t prev = 0;
    @autoreleasepool {
        int shiftInv = 64 - shift;
        for (int i = 0; i < count; ++i) {
            int64_t next = [x[xOff + i] longLongValue];
            x[xOff + i] = @((int64_t)((next << shift) | prev));
            prev = (int64_t)((uint64_t)next >> shiftInv);
        }
    }
    return prev;
}

// x, z == long[]
+ (int64_t)ShiftUp:(NSMutableArray*)x withXoff:(int)xOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count withShift:(int)shift {
    int64_t prev = 0;
    @autoreleasepool {
        int shiftInv = 64 - shift;
        for (int i = 0; i < count; ++i) {
            int64_t next = [x[xOff + i] longLongValue];
            z[zOff + i] = @((int64_t)((next << shift) | prev));
            prev = (int64_t)((uint64_t)next >> shiftInv);
        }
    }
    return prev;
}

- (LongArray*)addOne {
    LongArray *retVal = nil;
    @autoreleasepool {
        if (self.m_ints.count == 0) {
            NSMutableArray *tempArray = [[NSMutableArray alloc] initWithObjects:@((int64_t)1LL), nil];
            retVal = [[LongArray alloc] initWithInts:tempArray];
#if !__has_feature(objc_arc)
            if (tempArray != nil) [tempArray release]; tempArray = nil;
#endif
        } else {
            int resultLen = MAX(1, [self getUsedLength]);
            NSMutableArray *ints = [self resizedInts:resultLen];
            ints[0] = @((int64_t)([ints[0] longLongValue] ^ 1LL));
            retVal = [[LongArray alloc] initWithInts:ints];
        }
    }
    return (retVal ? [retVal autorelease] : nil);
}

- (void)addShiftedByBitsSafe:(LongArray*)other withOtherDegree:(int)otherDegree withBits:(int)bits {
    @autoreleasepool {
        int otherLen = (int)((uint)(otherDegree + 63) >> 6);
        
        int words = (int)((uint)bits >> 6);
        int shift = bits & 0x3F;
        
        if (shift == 0) {
            [LongArray add:self.m_ints withXoff:words withY:other.m_ints withYoff:0 withCount:otherLen];
            return;
        }
        
        int64_t carry = [LongArray addShiftedUp:self.m_ints withXoff:words withY:other.m_ints withYoff:0 withCount:otherLen withShift:shift];
        if (carry != 0L) {
            self.m_ints[otherLen + words] = @((int64_t)([self.m_ints[otherLen + words] longLongValue] ^ carry));
        }
    }
}

// x, y == long[]
+ (int64_t)addShiftedUp:(NSMutableArray*)x withXoff:(int)xOff withY:(NSMutableArray*)y withYoff:(int)yOff withCount:(int)count withShift:(int)shift {
    int64_t prev = 0;
    @autoreleasepool {
        int shiftInv = 64 - shift;
        for (int i = 0; i < count; ++i) {
            int64_t next = [y[yOff + i] longLongValue];
            x[xOff + i] = @((int64_t)([x[xOff + i] longLongValue] ^ ((next << shift) | prev)));
            prev = (int64_t)((uint64_t)next >> shiftInv);
        }
    }
    return prev;
}

// x, y == long[]
+ (int64_t)addShiftedDown:(NSMutableArray*)x withXoff:(int)xOff withY:(NSMutableArray*)y withYoff:(int)yOff withCount:(int)count withShift:(int)shift {
    int64_t prev = 0;
    @autoreleasepool {
        int shiftInv = 64 - shift;
        int i = count;
        while (--i >= 0) {
            int64_t next = [y[yOff + i] longLongValue];
            x[xOff + i] = @((int64_t)([x[xOff + i] longLongValue] ^ ((int64_t)((uint64_t)next >> shift) | prev)));
            prev = next << shiftInv;
        }
    }
    return prev;
}

- (void)addShiftedByWords:(LongArray*)other withWords:(int)words {
    @autoreleasepool {
        int otherUsedLen = [other getUsedLength];
        if (otherUsedLen == 0) {
            return;
        }
        
        int minLen = otherUsedLen + words;
        if (minLen > self.m_ints.count) {
            [self setM_ints:[self resizedInts:minLen]];
        }
        [LongArray add:self.m_ints withXoff:words withY:other.m_ints withYoff:0 withCount:otherUsedLen];
    }
}

// x, y == long[]
+ (void)add:(NSMutableArray*)x withXoff:(int)xOff withY:(NSMutableArray*)y withYoff:(int)yOff withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            x[xOff + i] = @((int64_t)([x[xOff + i] longLongValue] ^ [y[yOff + i] longLongValue]));
        }
    }
}

// x, y, z == long[]
+ (void)add:(NSMutableArray*)x withXoff:(int)xOff withY:(NSMutableArray*)y withYoff:(int)yOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            z[zOff + i] = @((int64_t)([x[xOff + i] longLongValue] ^ [y[yOff + i] longLongValue]));
        }
    }
}

// x, y1, y2 == long[]
+ (void)addBoth:(NSMutableArray*)x withXoff:(int)xOff withY1:(NSMutableArray*)y1 withY1off:(int)y1Off withY2:(NSMutableArray*)y2 withY2off:(int)y2Off withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            x[xOff + i] = @((int64_t)([x[xOff + i] longLongValue] ^ ([y1[y1Off + i] longLongValue] ^ [y2[y2Off + i] longLongValue])));
        }
    }
}

// x == long[]
+ (void)distribute:(NSMutableArray*)x withSrc:(int)src withDst1:(int)dst1 withDst2:(int)dst2 withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            uint64_t v = [x[src + i] longLongValue];
            x[dst1 + i] = @((int64_t)([x[dst1 + i] longLongValue] ^ v));
            x[dst2 + i] = @((int64_t)([x[dst2 + i] longLongValue] ^ v));
        }
    }
}

- (int)length {
    return (int)(self.m_ints.count);
}

// buf == long[]
+ (void)flipWord:(NSMutableArray*)buf withOff:(int)off withBit:(int)bit withWord:(int64_t)word {
    @autoreleasepool {
        int n = off + (int)((uint)bit >> 6);
        int shift = bit & 0x3F;
        if (shift == 0) {
            buf[n] = @((int64_t)([buf[n] longLongValue] ^ word));
        } else {
            buf[n] = @((int64_t)([buf[n] longLongValue] ^ (word << shift)));
            word = (int64_t)((uint64_t)word >> (64 - shift));
            if (word != 0) {
                buf[++n] = @((int64_t)([buf[++n] longLongValue] ^ word));
            }
        }
    }
}

- (BOOL)testBitZero {
    return self.m_ints.count > 0 && ([self.m_ints[0] longLongValue] & 1LL) != 0;
}

// buf == long[]
+ (BOOL)testBit:(NSMutableArray*)buf withOff:(int)off withN:(int)n {
    // theInt = n / 64
    int theInt = (int)((uint)n >> 6);
    // theBit = n % 64
    int theBit = n & 0x3F;
    int64_t tester = 1LL << theBit;
    return ([buf[off + theInt] longLongValue] & tester) != 0;
}

// buf == long[]
+ (void)flipBit:(NSMutableArray*)buf withOff:(int)off withN:(int)n {
    @autoreleasepool {
        // theInt = n / 64
        int theInt = (int)((uint)n >> 6);
        // theBit = n % 64
        int theBit = n & 0x3F;
        int64_t flipper = 1LL << theBit;
        buf[off + theInt] = @((int64_t)([buf[off + theInt] longLongValue] ^ flipper));
    }
}

// b, c == long[]
+ (void)multiplyWord:(int64_t)a withB:(NSMutableArray*)b withBlen:(int)bLen withC:(NSMutableArray*)c withCoff:(int)cOff {
    @autoreleasepool {
        if ((a & 1L) != 0L) {
            [LongArray add:c withXoff:cOff withY:b withYoff:0 withCount:bLen];
        }
        int k = 1;
        while ((a = (int64_t)((uint64_t)a >> 1)) != 0LL) {
            if ((a & 1L) != 0L) {
                int64_t carry = [LongArray addShiftedUp:c withXoff:cOff withY:b withYoff:0 withCount:bLen withShift:k];
                if (carry != 0L) {
                    c[cOff + bLen] = @((int64_t)([c[cOff + bLen] longLongValue] ^ carry));
                }
            }
            ++k;
        }
    }
}

// ks == int[]
- (LongArray*)modMultiplyLD:(LongArray*)other withM:(int)m withKs:(NSMutableArray*)ks {
    /*
     * Find out the degree of each argument and handle the zero cases
     */
    int aDeg = [self degree];
    if (aDeg == 0) {
        return self;
    }
    int bDeg = [other degree];
    if (bDeg == 0) {
        return other;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        /*
         * Swap if necessary so that A is the smaller argument
         */
        LongArray *A = self, *B = other;
        if (aDeg > bDeg) {
            A = other; B = self;
            int tmp = aDeg; aDeg = bDeg; bDeg = tmp;
        }
        
        /*
         * Establish the word lengths of the arguments and result
         */
        int aLen = (int)((uint)(aDeg + 63) >> 6);
        int bLen = (int)((uint)(bDeg + 63) >> 6);
        int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
        
        if (aLen == 1) {
            int64_t a0 = [A.m_ints[0] longLongValue];
            if (a0 == 1L) {
                retVal = B;
            } else {
                /*
                 * Fast path for small A, with performance dependent only on the number of set bits
                 */
                // NSMutableArray == long[]
                NSMutableArray *c0 = [[NSMutableArray alloc] initWithSize:cLen];
                [LongArray multiplyWord:a0 withB:B.m_ints withBlen:bLen withC:c0 withCoff:0];
                
                /*
                 * Reduce the raw answer against the reduction coefficients
                 */
                retVal = [LongArray reduceResult:c0 withOff:0 withLen:cLen withM:m withKs:ks];
#if !__has_feature(objc_arc)
                if (c0 != nil) [c0 release]; c0 = nil;
#endif
            }
        } else {
            /*
             * Determine if B will get bigger during shifting
             */
            int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
            
            /*
             * Lookup table for the offset of each B in the tables
             */
            // NSMutableArray == int[]
            NSMutableArray *ti = [[NSMutableArray alloc] initWithSize:16];
            
            /*
             * Precompute table of all 4-bit products of B
             */
            // NSMutableArray == long[]
            NSMutableArray *T0 = [[NSMutableArray alloc] initWithSize:(bMax << 4)];
            int tOff = bMax;
            ti[1] = @(tOff);
            [T0 copyFromIndex:tOff withSource:B.m_ints withSourceIndex:0 withLength:bLen];
            for (int i = 2; i < 16; ++i) {
                ti[i] = @((tOff += bMax));
                if ((i & 1) == 0) {
                    [LongArray ShiftUp:T0 withXoff:(int)((uint)tOff >> 1) withZ:T0 withZoff:tOff withCount:bMax withShift:1];
                } else {
                    [LongArray add:T0 withXoff:bMax withY:T0 withYoff:(tOff - bMax) withZ:T0 withZoff:tOff withCount:bMax];
                }
            }
            
            /*
             * Second table with all 4-bit products of B shifted 4 bits
             */
            // NSMutableArray == long[]
            NSMutableArray *T1 = [[NSMutableArray alloc] initWithSize:(int)(T0.count)];
            [LongArray ShiftUp:T0 withXoff:0 withZ:T1 withZoff:0 withCount:(int)(T0.count) withShift:4];
            
            NSMutableArray *a = A.m_ints;
            NSMutableArray *c = [[NSMutableArray alloc] initWithSize:cLen];
            
            int MASK = 0xF;
            
            /*
             * Lopez-Dahab algorithm
             */
            
            for (int k = 56; k >= 0; k -= 8) {
                for (int j = 1; j < aLen; j += 2) {
                    int aVal = (int)([a[j] unsignedLongLongValue] >> k);
                    int u = aVal & MASK;
                    int v = (int)((uint)aVal >> 4) & MASK;
                    [LongArray addBoth:c withXoff:(j - 1) withY1:T0 withY1off:[ti[u] intValue] withY2:T1 withY2off:[ti[v] intValue] withCount:bMax];
                }
                [LongArray shiftUp:c withXoff:0 withCount:cLen withShift:8];
            }
            
            for (int k = 56; k >= 0; k -= 8) {
                for (int j = 0; j < aLen; j += 2) {
                    int aVal = (int)([a[j] unsignedLongLongValue] >> k);
                    int u = aVal & MASK;
                    int v = (int)((uint)aVal >> 4) & MASK;
                    [LongArray addBoth:c withXoff:j withY1:T0 withY1off:[ti[u] intValue] withY2:T1 withY2off:[ti[v] intValue] withCount:bMax];
                }
                if (k > 0) {
                    [LongArray shiftUp:c withXoff:0 withCount:cLen withShift:8];
                }
            }
            
            retVal = [LongArray reduceResult:c withOff:0 withLen:cLen withM:m withKs:ks];
            
#if !__has_feature(objc_arc)
            if (ti != nil) [ti release]; ti = nil;
            if (T0 != nil) [T0 release]; T0 = nil;
            if (T1 != nil) [T1 release]; T1 = nil;
            if (c != nil) [c release]; c = nil;
#endif
            
        }
        
        [retVal retain];
    }
    
    /*
     * Finally the raw answer is collected, reduce it against the reduction coefficients
     */
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (LongArray*)modMultiply:(LongArray*)other withM:(int)m withKs:(NSMutableArray*)ks {
    /*
     * Find out the degree of each argument and handle the zero cases
     */
    int aDeg = [self degree];
    if (aDeg == 0) {
        return self;
    }
    int bDeg = [other degree];
    if (bDeg == 0) {
        return other;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        /*
         * Swap if necessary so that A is the smaller argument
         */
        LongArray *A = self, *B = other;
        if (aDeg > bDeg) {
            A = other; B = self;
            int tmp = aDeg; aDeg = bDeg; bDeg = tmp;
        }
        
        /*
         * Establish the word lengths of the arguments and result
         */
        int aLen = (int)((uint)(aDeg + 63) >> 6);
        int bLen = (int)((uint)(bDeg + 63) >> 6);
        int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
        
        if (aLen == 1) {
            int64_t a0 = [A.m_ints[0] longLongValue];
            if (a0 == 1LL) {
                retVal = B;
            } else {
                /*
                 * Fast path for small A, with performance dependent only on the number of set bits
                 */
                // NSMutableArray == long[]
                NSMutableArray *c0 = [[NSMutableArray alloc] initWithSize:cLen];
                [LongArray multiplyWord:a0 withB:B.m_ints withBlen:bLen withC:c0 withCoff:0];
                
                /*
                 * Reduce the raw answer against the reduction coefficients
                 */
                retVal = [LongArray reduceResult:c0 withOff:0 withLen:cLen withM:m withKs:ks];
#if !__has_feature(objc_arc)
                if (c0 != nil) [c0 release]; c0 = nil;
#endif
            }
        } else {
            /*
             * Determine if B will get bigger during shifting
             */
            int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
            
            /*
             * Lookup table for the offset of each B in the tables
             */
            // NSMutableArray == int[]
            NSMutableArray *ti = [[NSMutableArray alloc] initWithSize:16];
            
            /*
             * Precompute table of all 4-bit products of B
             */
            // NSMutableArray == long[]
            NSMutableArray *T0 = [[NSMutableArray alloc] initWithSize:(bMax << 4)];
            int tOff = bMax;
            ti[1] = @(tOff);
            [T0 copyFromIndex:tOff withSource:B.m_ints withSourceIndex:0 withLength:bLen];
            for (int i = 2; i < 16; ++i) {
                ti[i] = @((tOff += bMax));
                if ((i & 1) == 0) {
                    [LongArray ShiftUp:T0 withXoff:(int)((uint)tOff >> 1) withZ:T0 withZoff:tOff withCount:bMax withShift:1];
                } else {
                    [LongArray add:T0 withXoff:bMax withY:T0 withYoff:(tOff - bMax) withZ:T0 withZoff:tOff withCount:bMax];
                }
            }
            
            /*
             * Second table with all 4-bit products of B shifted 4 bits
             */
            // NSMutableArray == long[]
            NSMutableArray *T1 = [[NSMutableArray alloc] initWithSize:(int)(T0.count)];
            [LongArray ShiftUp:T0 withXoff:0 withZ:T1 withZoff:0 withCount:(int)(T0.count) withShift:4];
            
            NSMutableArray *a = A.m_ints;
            NSMutableArray *c = [[NSMutableArray alloc] initWithSize:(cLen << 3)];
            
            int MASK = 0xF;
            
            /*
             * Lopez-Dahab (Modified) algorithm
             */
            
            for (int aPos = 0; aPos < aLen; ++aPos) {
                int64_t aVal = [a[aPos] longLongValue];
                int cOff = aPos;
                for (;;) {
                    int u = (int)aVal & MASK;
                    aVal = (int64_t)((uint64_t)aVal >> 4);
                    int v = (int)aVal & MASK;
                    [LongArray addBoth:c withXoff:cOff withY1:T0 withY1off:[ti[u] intValue] withY2:T1 withY2off:[ti[v] intValue] withCount:bMax];
                    aVal = (int64_t)((uint64_t)aVal >> 4);
                    if (aVal == 0LL) {
                        break;
                    }
                    cOff += cLen;
                }
            }
            
            {
                int cOff = (int)(c.count);
                while ((cOff -= cLen) != 0) {
                    [LongArray addShiftedUp:c withXoff:(cOff - cLen) withY:c withYoff:cOff withCount:cLen withShift:8];
                }
            }
            
            /*
             * Finally the raw answer is collected, reduce it against the reduction coefficients
             */
            retVal = [LongArray reduceResult:c withOff:0 withLen:cLen withM:m withKs:ks];
            
#if !__has_feature(objc_arc)
            if (ti != nil) [ti release]; ti = nil;
            if (T0 != nil) [T0 release]; T0 = nil;
            if (T1 != nil) [T1 release]; T1 = nil;
            if (c != nil) [c release]; c = nil;
#endif
        }
        [retVal retain];
    }
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (LongArray*)modMultiplyAlt:(LongArray*)other withM:(int)m withKs:(NSMutableArray*)ks {
    /*
     * Find out the degree of each argument and handle the zero cases
     */
    int aDeg = [self degree];
    if (aDeg == 0) {
        return self;
    }
    int bDeg = [other degree];
    if (bDeg == 0) {
        return other;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        /*
         * Swap if necessary so that A is the smaller argument
         */
        LongArray *A = self, *B = other;
        if (aDeg > bDeg) {
            A = other; B = self;
            int tmp = aDeg; aDeg = bDeg; bDeg = tmp;
        }
        
        /*
         * Establish the word lengths of the arguments and result
         */
        int aLen = (int)((uint)(aDeg + 63) >> 6);
        int bLen = (int)((uint)(bDeg + 63) >> 6);
        int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
        
        if (aLen == 1) {
            int64_t a0 = [A.m_ints[0] longLongValue];
            if (a0 == 1L) {
                retVal = B;
            } else {
                /*
                 * Fast path for small A, with performance dependent only on the number of set bits
                 */
                // NSMutableArray == long[]
                NSMutableArray *c0 = [[NSMutableArray alloc] initWithSize:cLen];
                [LongArray multiplyWord:a0 withB:B.m_ints withBlen:bLen withC:c0 withCoff:0];
                
                /*
                 * Reduce the raw answer against the reduction coefficients
                 */
                retVal = [LongArray reduceResult:c0 withOff:0 withLen:cLen withM:m withKs:ks];
#if !__has_feature(objc_arc)
                if (c0 != nil) [c0 release]; c0 = nil;
#endif
            }
        } else {
            // NOTE: This works, but is slower than width 4 processing
            //    if (aLen == 2) {
            //        /*
            //         * Use common-multiplicand optimization to save ~1/4 of the adds
            //         */
            //        long a1 = [A.m_ints[0] longValue], a2 = [A.m_ints[1] longValue];
            //        long aa = a1 & a2; a1 ^= aa; a2 ^= aa;
            //
            //        NSMutableArray *b = B.m_ints;
            //        NSMutableArray *c = [[NSMutableArray alloc] initWithSize:cLen];
            //        [LongArray multiplyWord:aa withB:b withBlen:bLen withC:c withCoff:1];
            //        [LongArray add:c withXoff:0 withY:c withYoff:1 withCount:(cLen - 1)];
            //        [LongArray multiplyWord:a1 withB:b withBlen:bLen withC:c withCoff:0];
            //        [LongArray multiplyWord:a2 withB:b withBlen:bLen withC:c withCoff:1];
            //
            //        /*
            //         * Reduce the raw answer against the reduction coefficients
            //         */
            //        LongArray *retVal = [LongArray reduceResult:c withOff:0 withLen:cLen withM:m withKs:ks];
            //#if !__has_feature(objc_arc)
            //        if (c != nil) [c release]; c = nil;
            //#endif
            //        return retVal;
            //    }
            
            /*
             * Determine the parameters of the Interleaved window algorithm: the 'width' in bits to
             * process together, the number of evaluation 'positions' implied by that width, and the
             * 'top' position at which the regular window algorithm stops.
             */
            int width, positions, top, banks;
            
            // NOTE: width 4 is the fastest over the entire range of sizes used in current crypto
            //        width = 1; positions = 64; top = 64; banks = 4;
            //        width = 2; positions = 32; top = 64; banks = 4;
            //        width = 3; positions = 21; top = 63; banks = 3;
            width = 4; positions = 16; top = 64; banks = 8;
            //        width = 5; positions = 13; top = 65; banks = 7;
            //        width = 7; positions = 9; top = 63; banks = 9;
            //        width = 8; positions = 8; top = 64; banks = 8;
            
            /*
             * Determine if B will get bigger during shifting
             */
            int shifts = top < 64 ? positions : positions - 1;
            int bMax = (int)((uint)(bDeg + shifts + 63) >> 6);
            
            int bTotal = bMax * banks, stride = width * banks;
            
            /*
             * Create a single temporary buffer, with an offset table to find the positions of things in it
             */
            // NSMutableArray == int[]
            NSMutableArray *ci = [[NSMutableArray alloc] initWithSize:(int)(1 << width)];
            int cTotal = aLen; {
                ci[0] = @(cTotal);
                cTotal += bTotal;
                ci[1] = @(cTotal);
                for (int i = 2; i < ci.count; ++i) {
                    cTotal += cLen;
                    ci[i] = @(cTotal);
                }
                cTotal += cLen;
            }
            // NOTE: Provide a safe dump for "high zeroes" since we are adding 'bMax' and not 'bLen'
            ++cTotal;
            
            // NSMutableArray == long[]
            NSMutableArray *c = [[NSMutableArray alloc] initWithSize:cTotal];
            
            // Prepare A in Interleaved form, according to the chosen width
            [LongArray interleave:A.m_ints withXoff:0 withZ:c withZoff:0 withCount:aLen withWidth:width];
            
            // Make a working copy of B, since we will be shifting it
            {
                int bOff = aLen;
                [c copyFromIndex:bOff withSource:B.m_ints withSourceIndex:0 withLength:bLen];
                
                for (int bank = 1; bank < banks; ++bank) {
                    [LongArray ShiftUp:c withXoff:aLen withZ:c withZoff:(bOff += bMax) withCount:bMax withShift:bank];
                }
            }
            
            /*
             * The main loop analyzes the Interleaved windows in A, and for each non-zero window
             * a single word-array XOR is performed to a carefully selected slice of 'c'. The loop is
             * breadth-first, checking the lowest window in each word, then looping again for the
             * next higher window position.
             */
            int MASK = (1 << width) - 1;
            
            int k = 0;
            for (;;) {
                int aPos = 0;
                do {
                    int64_t aVal = (int64_t)([c[aPos] unsignedLongLongValue] >> k);
                    int bank = 0, bOff = aLen;
                    for (;;) {
                        int index = (int)(aVal) & MASK;
                        if (index != 0) {
                            /*
                             * Add to a 'c' buffer based on the bit-pattern of 'index'. Since A is in
                             * Interleaved form, the bits represent the current B shifted by 0, 'positions',
                             * 'positions' * 2, ..., 'positions' * ('width' - 1)
                             */
                            [LongArray add:c withXoff:(aPos + [ci[index] intValue]) withY:c withYoff:bOff withCount:bMax];
                        }
                        if (++bank == banks) {
                            break;
                        }
                        bOff += bMax;
                        aVal = (int64_t)((uint64_t)aVal >> width);
                    }
                } while (++aPos < aLen);
                
                if ((k += stride) >= top) {
                    if (k >= 64) {
                        break;
                    }
                    
                    /*
                     * Adjustment for window setups with top == 63, the final bit (if any) is processed
                     * as the top-bit of a window
                     */
                    k = 64 - width;
                    MASK &= MASK << (top - k);
                }
                
                /*
                 * After each position has been checked for all words of A, B is shifted up 1 place
                 */
                [LongArray shiftUp:c withXoff:aLen withCount:bTotal withShift:banks];
            }
            
            int ciPos = (int)(ci.count);
            while (--ciPos > 1) {
                if ((ciPos & 1L) == 0L) {
                    /*
                     * For even numbers, shift contents and add to the half-position
                     */
                    [LongArray addShiftedUp:c withXoff:[ci[((uint)ciPos >> 1)] intValue] withY:c withYoff:[ci[ciPos] intValue] withCount:cLen withShift:positions];
                } else {
                    /*
                     * For odd numbers, 'distribute' contents to the result and the next-lowest position
                     */
                    [LongArray distribute:c withSrc:[ci[ciPos] intValue] withDst1:[ci[ciPos - 1] intValue] withDst2:[ci[1] intValue] withCount:cLen];
                }
            }
            
            /*
             * Finally the raw answer is collected, reduce it against the reduction coefficients
             */
            retVal = [LongArray reduceResult:c withOff:[ci[1] intValue] withLen:cLen withM:m withKs:ks];
#if !__has_feature(objc_arc)
            if (ci != nil) [ci release]; ci = nil;
            if (c != nil) [c release]; c = nil;
#endif
        }
        [retVal retain];
    }
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (LongArray*)modReduce:(int)m withKs:(NSMutableArray*)ks {
    LongArray *retVal = nil;
    @autoreleasepool {
        // NSMutableArray == long[]
        NSMutableArray *buf = [self.m_ints clone];
        int rLen = [LongArray reduceInPlace:buf withOff:0 withLen:(int)(buf.count) withM:m withKs:ks];
        retVal = [[LongArray alloc] initWithInts:buf withOff:0 withLen:rLen];
#if !__has_feature(objc_arc)
        if (buf) [buf release]; buf = nil;
#endif
    }
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (LongArray*)multiply:(LongArray*)other withM:(int)m withKs:(NSMutableArray*)ks {
    /*
     * Find out the degree of each argument and handle the zero cases
     */
    int aDeg = [self degree];
    if (aDeg == 0) {
        return self;
    }
    int bDeg = [other degree];
    if (bDeg == 0) {
        return other;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        /*
         * Swap if necessary so that A is the smaller argument
         */
        LongArray *A = self, *B = other;
        if (aDeg > bDeg) {
            A = other; B = self;
            int tmp = aDeg; aDeg = bDeg; bDeg = tmp;
        }
        
        /*
         * Establish the word lengths of the arguments and result
         */
        int aLen = (int)((uint)(aDeg + 63) >> 6);
        int bLen = (int)((uint)(bDeg + 63) >> 6);
        int cLen = (int)((uint)(aDeg + bDeg + 62) >> 6);
        
        if (aLen == 1) {
            int64_t a0 = [A.m_ints[0] longLongValue];
            if (a0 == 1L) {
                retVal = B;
            } else {
                /*
                 * Fast path for small A, with performance dependent only on the number of set bits
                 */
                // NSMutableArray == long[]
                NSMutableArray *c0 = [[NSMutableArray alloc] initWithSize:cLen];
                [LongArray multiplyWord:a0 withB:B.m_ints withBlen:bLen withC:c0 withCoff:0];
                
                /*
                 * Reduce the raw answer against the reduction coefficients
                 */
                // LongArray *retVal = [LongArray reduceResult:c0 withOff:0 withLen:cLen withM:m withKs:ks];
                retVal = [[[LongArray alloc] initWithInts:c0 withOff:0 withLen:cLen] autorelease];
#if !__has_feature(objc_arc)
                if (c0 != nil) [c0 release]; c0 = nil;
#endif
            }
        } else {
            /*
             * Determine if B will get bigger during shifting
             */
            int bMax = (int)((uint)(bDeg + 7 + 63) >> 6);
            
            /*
             * Lookup table for the offset of each B in the tables
             */
            // NSMutableArray == int[]
            NSMutableArray *ti = [[NSMutableArray alloc] initWithSize:16];
            
            /*
             * Precompute table of all 4-bit products of B
             */
            // NSMutableArray == long[]
            NSMutableArray *T0 = [[NSMutableArray alloc] initWithSize:(bMax << 4)];
            int tOff = bMax;
            ti[1] = @(tOff);
            [T0 copyFromIndex:tOff withSource:B.m_ints withSourceIndex:0 withLength:bLen];
            for (int i = 2; i < 16; ++i) {
                ti[i] = @((tOff += bMax));
                if ((i & 1) == 0) {
                    [LongArray ShiftUp:T0 withXoff:(int)((uint)tOff >> 1) withZ:T0 withZoff:tOff withCount:bMax withShift:1];
                } else {
                    [LongArray add:T0 withXoff:bMax withY:T0 withYoff:(tOff - bMax) withZ:T0 withZoff:tOff withCount:bMax];
                }
            }
            
            /*
             * Second table with all 4-bit products of B shifted 4 bits
             */
            // NSMutableArray == long[]
            NSMutableArray *T1 = [[NSMutableArray alloc] initWithSize:(int)(T0.count)];
            [LongArray ShiftUp:T0 withXoff:0 withZ:T1 withZoff:0 withCount:(int)(T0.count) withShift:4];
            
            NSMutableArray *a = A.m_ints;
            NSMutableArray *c = [[NSMutableArray alloc] initWithSize:(int)(cLen << 3)];
            
            int MASK = 0xF;
            
            /*
             * Lopez-Dahab (Modified) algorithm
             */
            
            for (int aPos = 0; aPos < aLen; ++aPos) {
                int64_t aVal = [a[aPos] longLongValue];
                int cOff = aPos;
                for (;;) {
                    int u = (int)aVal & MASK;
                    aVal = (int64_t)((uint64_t)aVal >> 4);
                    int v = (int)aVal & MASK;
                    [LongArray addBoth:c withXoff:cOff withY1:T0 withY1off:[ti[u] intValue] withY2:T1 withY2off:[ti[v] intValue] withCount:bMax];
                    aVal = (int64_t)((uint64_t)aVal >> 4);
                    if (aVal == 0L) {
                        break;
                    }
                    cOff += cLen;
                }
            }
            
            {
                int cOff = (int)(c.count);
                while ((cOff -= cLen) != 0) {
                    [LongArray addShiftedUp:c withXoff:(cOff - cLen) withY:c withYoff:cOff withCount:cLen withShift:8];
                }
            }
            
            /*
             * Finally the raw answer is collected, reduce it against the reduction coefficients
             */
            // LongArray *retVal = [LongArray reduceResult:c withOff:0 withLen:cLen withM:m withKs:ks];
            retVal = [[[LongArray alloc] initWithInts:c withOff:0 withLen:cLen] autorelease];
#if !__has_feature(objc_arc)
            if (ti != nil) [ti release]; ti = nil;
            if (T0 != nil) [T0 release]; T0 = nil;
            if (T1 != nil) [T1 release]; T1 = nil;
            if (c != nil) [c release]; c = nil;
#endif
        }
        [retVal retain];
    }
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (void)reduce:(int)m withKs:(NSMutableArray*)ks {
    @autoreleasepool {
        // NSMutableArray == long[]
        NSMutableArray *buf = self.m_ints;
        int rLen = [LongArray reduceInPlace:buf withOff:0 withLen:(int)(buf.count) withM:m withKs:ks];
        if (rLen < buf.count) {
            NSMutableArray *tmpArray = [[NSMutableArray alloc] initWithSize:rLen];
            [tmpArray copyFromIndex:0 withSource:buf withSourceIndex:0 withLength:rLen];
            [self setM_ints:tmpArray];
#if !__has_feature(objc_arc)
            if (tmpArray != nil) [tmpArray release]; tmpArray = nil;
#endif
        }
    }
}

// buf == long[], ks == int[]
+ (LongArray*)reduceResult:(NSMutableArray*)buf withOff:(int)off withLen:(int)len withM:(int)m withKs:(NSMutableArray*)ks {
    int rLen = [LongArray reduceInPlace:buf withOff:off withLen:len withM:m withKs:ks];
    return [[[LongArray alloc] initWithInts:buf withOff:off withLen:rLen] autorelease];
}

// buf == long[], ks == int[]
+ (int)reduceInPlace:(NSMutableArray*)buf withOff:(int)off withLen:(int)len withM:(int)m withKs:(NSMutableArray*)ks {
    int mLen = 0;
    @autoreleasepool {
        mLen = (m + 63) >> 6;
        if (len < mLen) {
            return len;
        }
        
        int numBits = MIN((len << 6), ((m << 1) - 1)); // TODO use actual degree?
        int excessBits = (len << 6) - numBits;
        while (excessBits >= 64) {
            --len;
            excessBits -= 64;
        }
        
        int kLen = (int)(ks.count), kMax = [ks[kLen - 1] intValue], kNext = kLen > 1 ? [ks[kLen - 2] intValue] : 0;
        int wordWiseLimit = MAX(m, (kMax + 64));
        int vectorableWords = (excessBits + MIN((numBits - wordWiseLimit), (m - kNext))) >> 6;
        if (vectorableWords > 1) {
            int vectorWiseWords = len - vectorableWords;
            [LongArray reduceVectorWise:buf withOff:off withLen:len withWords:vectorWiseWords withM:m withKs:ks];
            while (len > vectorWiseWords) {
                buf[off + --len] = @(0L);
            }
            numBits = vectorWiseWords << 6;
        }
        
        if (numBits > wordWiseLimit) {
            [LongArray reduceWordWise:buf withOff:off withLen:len withToBit:wordWiseLimit withM:m withKs:ks];
            numBits = wordWiseLimit;
        }
        
        if (numBits > m) {
            [LongArray reduceBitWise:buf withOff:off withBitLength:numBits withM:m withKs:ks];
        }
    }
    return mLen;
}

// buf == long[], ks == int[]
+ (void)reduceBitWise:(NSMutableArray*)buf withOff:(int)off withBitLength:(int)bitLength withM:(int)m withKs:(NSMutableArray*)ks {
    while (--bitLength >= m) {
        if ([LongArray testBit:buf withOff:off withN:bitLength]) {
            [LongArray reduceBit:buf withOff:off withBit:bitLength withM:m withKs:ks];
        }
    }
}

// buf == long[], ks == int[]
+ (void)reduceBit:(NSMutableArray*)buf withOff:(int)off withBit:(int)bit withM:(int)m withKs:(NSMutableArray*)ks {
    [LongArray flipBit:buf withOff:off withN:bit];
    int n = bit - m;
    int j = (int)(ks.count);
    while (--j >= 0) {
        [LongArray flipBit:buf withOff:off withN:([ks[j] intValue] + n)];
    }
    [LongArray flipBit:buf withOff:off withN:n];
}

// buf == long[], ks == int[]
+ (void)reduceWordWise:(NSMutableArray*)buf withOff:(int)off withLen:(int)len withToBit:(int)toBit withM:(int)m withKs:(NSMutableArray*)ks {
    @autoreleasepool {
        int toPos = (int)((uint)toBit >> 6);
        
        while (--len > toPos) {
            int64_t word = [buf[off + len] longLongValue];
            if (word != 0) {
                buf[off + len] = @((int64_t)0);
                [LongArray reduceWord:buf withOff:off withBit:(len << 6) withWord:word withM:m withKs:ks];
            }
        }
        
        {
            int partial = toBit & 0x3F;
            int64_t word = (int64_t)([buf[off + toPos] unsignedLongLongValue] >> partial);
            if (word != 0) {
                buf[off + toPos] = @((int64_t)([buf[off + toPos] longLongValue] ^ (word << partial)));
                [LongArray reduceWord:buf withOff:off withBit:toBit withWord:word withM:m withKs:ks];
            }
        }
    }
}

// buf == long[], ks == int[]
+ (void)reduceWord:(NSMutableArray*)buf withOff:(int)off withBit:(int)bit withWord:(int64_t)word withM:(int)m withKs:(NSMutableArray*)ks {
    int offset = bit - m;
    int j = (int)(ks.count);
    while (--j >= 0) {
        [LongArray flipWord:buf withOff:off withBit:(offset + [ks[j] intValue]) withWord:word];
    }
    [LongArray flipWord:buf withOff:off withBit:offset withWord:word];
}

// buf == long[], ks == int[]
+ (void)reduceVectorWise:(NSMutableArray*)buf withOff:(int)off withLen:(int)len withWords:(int)words withM:(int)m withKs:(NSMutableArray*)ks {
    /*
     * NOTE: It's important we go from highest coefficient to lowest, because for the highest
     * one (only) we allow the ranges to partially overlap, and therefore any changes must take
     * effect for the subsequent lower coefficients.
     */
    int baseBit = (words << 6) - m;
    int j = (int)(ks.count);
    while (--j >= 0) {
        [LongArray flipVector:buf withXoff:off withY:buf withYoff:(off + words) withYlen:(len - words) withBits:(baseBit + [ks[j] intValue])];
    }
    [LongArray flipVector:buf withXoff:off withY:buf withYoff:(off + words) withYlen:(len - words) withBits:baseBit];
}

// x, y == long[]
+ (void)flipVector:(NSMutableArray*)x withXoff:(int)xOff withY:(NSMutableArray*)y withYoff:(int)yOff withYlen:(int)yLen withBits:(int)bits {
    xOff += (int)((uint)bits >> 6);
    bits &= 0x3F;
    
    if (bits == 0) {
        [LongArray add:x withXoff:xOff withY:y withYoff:yOff withCount:yLen];
    } else {
        int64_t carry = [LongArray addShiftedDown:x withXoff:(xOff + 1) withY:y withYoff:yOff withCount:yLen withShift:(64 - bits)];
        x[xOff] = @((int64_t)([x[xOff] longLongValue] ^ carry));
    }
}

// ks == int[]
- (LongArray*)modSquare:(int)m withKs:(NSMutableArray*)ks {
    int len = [self getUsedLength];
    if (len == 0) {
        return self;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        int _2len = len << 1;
        // NSMutableArray == long[]
        NSMutableArray *r = [[NSMutableArray alloc] initWithSize:_2len];
        
        int pos = 0;
        while (pos < _2len) {
            int64_t mi = [self.m_ints[(uint)pos >> 1] longLongValue];
            r[pos++] = @([LongArray interleave2_32to64:(int)mi]);
            r[pos++] = @([LongArray interleave2_32to64:(int)((uint64_t)mi >> 32)]);
        }
        
        retVal = [[LongArray alloc] initWithInts:r withOff:0 withLen:[LongArray reduceInPlace:r withOff:0 withLen:(int)(r.count) withM:m withKs:ks]];
#if !__has_feature(objc_arc)
        if (r != nil) [r release]; r = nil;
#endif
    }
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (LongArray*)modSquareN:(int)n withM:(int)m withKs:(NSMutableArray*)ks {
    int len = [self getUsedLength];
    if (len == 0) {
        return self;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        int mLen = (m + 63) >> 6;
        // NSMutableArray == long[]
        NSMutableArray *r = [[NSMutableArray alloc] initWithSize:(mLen << 1)];
        [r copyFromIndex:0 withSource:self.m_ints withSourceIndex:0 withLength:len];
        
        while (--n >= 0) {
            [LongArray squareInPlace:r withXlen:len withM:m withKs:ks];
            len = [LongArray reduceInPlace:r withOff:0 withLen:(int)(r.count) withM:m withKs:ks];
        }
        
        retVal = [[LongArray alloc] initWithInts:r withOff:0 withLen:len];
#if !__has_feature(objc_arc)
        if (r != nil) [r release]; r = nil;
#endif
    }
    return (retVal ? [retVal autorelease] : nil);
}

// ks == int[]
- (LongArray*)square:(int)m withKs:(NSMutableArray*)ks {
    int len = [self getUsedLength];
    if (len == 0) {
        return self;
    }
    
    LongArray *retVal = nil;
    @autoreleasepool {
        int _2len = len << 1;
        // NSMutableArray == long[]
        NSMutableArray *r = [[NSMutableArray alloc] initWithSize:_2len];
        
        int pos = 0;
        while (pos < _2len) {
            int64_t mi = [self.m_ints[(uint)pos >> 1] longLongValue];
            r[pos++] = @([LongArray interleave2_32to64:(int)mi]);
            r[pos++] = @([LongArray interleave2_32to64:(int)((uint64_t)mi >> 32)]);
        }
        
        retVal = [[LongArray alloc] initWithInts:r withOff:0 withLen:(int)(r.count)];
#if !__has_feature(objc_arc)
        if (r != nil) [r release]; r = nil;
#endif
    }
    return (retVal ? [retVal autorelease] : nil);
}

// x == long[], ks == int[]
+ (void)squareInPlace:(NSMutableArray*)x withXlen:(int)xLen withM:(int)m withKs:(NSMutableArray*)ks {
    @autoreleasepool {
        int pos = xLen << 1;
        while (--xLen >= 0) {
            int64_t xVal = [x[xLen] longLongValue];
            x[--pos] = @([LongArray interleave2_32to64:(int)((uint64_t)xVal >> 32)]);
            x[--pos] = @([LongArray interleave2_32to64:(int)xVal]);
        }
    }
}

// x, z == long[]
+ (void)interleave:(NSMutableArray*)x withXoff:(int)xOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count withWidth:(int)width {
    switch (width) {
        case 3: {
            [LongArray interleave3:x withXoff:xOff withZ:z withZoff:zOff withCount:count];
            break;
        }
        case 5: {
            [LongArray interleave5:x withXoff:xOff withZ:z withZoff:zOff withCount:count];
            break;
        }
        case 7: {
            [LongArray interleave7:x withXoff:xOff withZ:z withZoff:zOff withCount:count];
            break;
        }
        default: {
            [LongArray interleave2_n:x withXoff:xOff withZ:z withZoff:zOff withCount:count withRounds:(((Byte*)([LongArray BitLengths].bytes))[width] - 1)];
            break;
        }
    }
}

// x, z == long[]
+ (void)interleave3:(NSMutableArray*)x withXoff:(int)xOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            z[zOff + i] = @([LongArray interleave3:[x[xOff + i] longLongValue]]);
        }
    }
}

+ (int64_t)interleave3:(int64_t)x {
    int64_t z = x & (1LL << 63);
    
    return z | [LongArray interleave3_21to63:((int)x & 0x1FFFFF)] | [LongArray interleave3_21to63:((int)((uint64_t)x >> 21) & 0x1FFFFF)] << 1 | [LongArray interleave3_21to63:((int)((uint64_t)x >> 42) & 0x1FFFFF)] << 2;
}

+ (int64_t)interleave3_21to63:(int)x {
    int r00 = [[LongArray INTERLEAVE3_TABLE][x & 0x7F] intValue];
    int r21 = [[LongArray INTERLEAVE3_TABLE][((uint)x >> 7) & 0x7F] intValue];
    int r42 = [[LongArray INTERLEAVE3_TABLE][(uint)x >> 14] intValue];
    return (r42 & 0xFFFFFFFFLL) << 42 | (r21 & 0xFFFFFFFFLL) << 21 | (r00 & 0xFFFFFFFFLL);
}

// x, z == long[]
+ (void)interleave5:(NSMutableArray*)x withXoff:(int)xOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            z[zOff + i] = @([LongArray interleave5:[x[xOff + i] longLongValue]]);
        }
    }
}

+ (int64_t)interleave5:(int64_t)x {
    return [LongArray interleave3_13to65:((int)x & 0x1FFF)] | [LongArray interleave3_13to65:((int)((uint64_t)x >> 13) & 0x1FFF)] << 1 | [LongArray interleave3_13to65:((int)((uint64_t)x >> 26) & 0x1FFF)] >> 2 | [LongArray interleave3_13to65:((int)((uint64_t)x >> 39) & 0x1FFF)] << 3 | [LongArray interleave3_13to65:((int)((uint64_t)x >> 52) & 0x1FFF)] << 4;
    
}

+ (int64_t)interleave3_13to65:(int)x {
    int r00 = [[LongArray INTERLEAVE5_TABLE][x & 0x7F] intValue];
    int r35 = [[LongArray INTERLEAVE5_TABLE][(uint)x >> 7] intValue];
    return (r35 & 0xFFFFFFFFLL) << 35 | (r00 & 0xFFFFFFFFLL);
}

// x, z == long[]
+ (void)interleave7:(NSMutableArray*)x withXoff:(int)xOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            z[zOff + i] = @([LongArray interleave7:[x[xOff + i] longLongValue]]);
        }
    }
}

+ (int64_t)interleave7:(int64_t)x {
    int64_t z = x & (1LL << 63);
    
    return z | [[LongArray INTERLEAVE7_TABLE][((int)x & 0x1FF)] longLongValue] | [[LongArray INTERLEAVE7_TABLE][((int)((uint64_t)x >> 9) & 0x1FF)] longLongValue] << 1 | [[LongArray INTERLEAVE7_TABLE][((int)((uint64_t)x >> 18) & 0x1FF)] longLongValue] << 2 | [[LongArray INTERLEAVE7_TABLE][((int)((uint64_t)x >> 27) & 0x1FF)] longLongValue] << 3 | [[LongArray INTERLEAVE7_TABLE][((int)((uint64_t)x >> 36) & 0x1FF)] longLongValue] << 4 | [[LongArray INTERLEAVE7_TABLE][((int)((uint64_t)x >> 45) & 0x1FF)] longLongValue] << 5 | [[LongArray INTERLEAVE7_TABLE][((int)((uint64_t)x >> 54) & 0x1FF)] longLongValue] << 6;
    
}

// x, z == long[]
+ (void)interleave2_n:(NSMutableArray*)x withXoff:(int)xOff withZ:(NSMutableArray*)z withZoff:(int)zOff withCount:(int)count withRounds:(int)rounds {
    @autoreleasepool {
        for (int i = 0; i < count; ++i) {
            z[zOff + i] = @([LongArray interleave2_n:[x[xOff + i] longLongValue] withRounds:rounds]);
        }
    }
}

+ (int64_t)interleave2_n:(int64_t)x withRounds:(int)rounds {
    while (rounds > 1) {
        rounds -= 2;
        x = [LongArray interleave4_16to64:((int)x & 0xFFFF)] | [LongArray interleave4_16to64:((int)((uint64_t)x >> 16) & 0xFFFF)] << 1 | [LongArray interleave4_16to64:((int)((uint64_t)x >> 32) & 0xFFFF)] << 2 | [LongArray interleave4_16to64:((int)((uint64_t)x >> 48) & 0xFFFF)] << 3;
        
    }
    if (rounds > 0) {
        x = [LongArray interleave2_32to64:(int)x] | [LongArray interleave2_32to64:(int)((uint64_t)x >> 32)] << 1;
    }
    return x;
}

+ (int64_t)interleave4_16to64:(int)x {
    int r00 = [[LongArray INTERLEAVE4_TABLE][x & 0xFF] intValue];
    int r32 = [[LongArray INTERLEAVE4_TABLE][(uint)x >> 8] intValue];
    return (r32 & 0xFFFFFFFFLL) << 32 | (r00 & 0xFFFFFFFFLL);
}

+ (int64_t)interleave2_32to64:(int)x {
    int r00 = [[LongArray INTERLEAVE2_TABLE][x & 0xFF] unsignedShortValue] | [[LongArray INTERLEAVE2_TABLE][((uint)x >> 8) & 0xFF] unsignedShortValue] << 16;
    int r32 = [[LongArray INTERLEAVE2_TABLE][((uint)x >> 16) & 0xFF] unsignedShortValue] | [[LongArray INTERLEAVE2_TABLE][(uint)x >> 24] unsignedShortValue] << 16;
    return (r32 & 0xFFFFFFFFLL) << 32 | (r00 & 0xFFFFFFFFLL);
}

// ks == int[]
- (LongArray*)modInverse:(int)m withKs:(NSMutableArray*)ks {
    /*
     * Inversion in F2m using the extended Euclidean algorithm
     *
     * Input: A nonzero polynomial a(z) of degree at most m-1
     * Output: a(z)^(-1) mod f(z)
     */
    int uzDegree = [self degree];
    if (uzDegree == 0) {
        @throw [NSException exceptionWithName:@"InvalidOperation" reason:nil userInfo:nil];
    }
    if (uzDegree == 1) {
        return self;
    }
    
    LongArray *retVal = nil;
    
    @autoreleasepool {
        LongArray *uz = nil;
        
        // u(z) := a(z)
        //    uz = (LongArray*)[self copy];
        
        int t = (m + 63) >> 6;
        
        // v(z) := f(z)
        LongArray *vz = [[LongArray alloc] initWithIntLen:t];
        [LongArray reduceBit:vz.m_ints withOff:0 withBit:m withM:m withKs:ks];
        
        // g1(z) := 1, g2(z) := 0
        LongArray *g1z = [[LongArray alloc] initWithIntLen:t];
        g1z.m_ints[0] = @((int64_t)1LL);
        LongArray *g2z = [[LongArray alloc] initWithIntLen:t];
        
        // NSMutableArray == int[]
        NSMutableArray *uvDeg = [[NSMutableArray alloc] initWithObjects:@((int)uzDegree), @((int)(m + 1)), nil];
        [uvDeg setFixedSize:(int)(uvDeg.count)];
        NSMutableArray *uv = nil;
        // NSMutableArray == LongArray[]
        uz = (LongArray*)[self copy];
        uv = [[NSMutableArray alloc] initWithObjects:uz, vz, nil];
        [uv setFixedSize:(int)(uv.count)];
        
        // NSMutableArray == int[]
        NSMutableArray *ggDeg = [[NSMutableArray alloc] initWithObjects:@((int)1), @((int)0), nil];
        [ggDeg setFixedSize:(int)(ggDeg.count)];
        // NSMutableArray == LongArray[]
        NSMutableArray *gg = [[NSMutableArray alloc] initWithObjects:g1z, g2z, nil];
        [gg setFixedSize:(int)(gg.count)];
        
        int b = 1;
        int duv1 = [uvDeg[b] intValue];
        int dgg1 = [ggDeg[b] intValue];
        int j = duv1 - [uvDeg[1 - b] intValue];
        
        for (;;) {
            if (j < 0) {
                j = -j;
                uvDeg[b] = @(duv1);
                ggDeg[b] = @(dgg1);
                b = 1 - b;
                duv1 = [uvDeg[b] intValue];
                dgg1 = [ggDeg[b] intValue];
            }
            
            [uv[b] addShiftedByBitsSafe:uv[1 - b] withOtherDegree:[uvDeg[1 - b] intValue] withBits:j];
            
            int duv2 = [uv[b] degreeFrom:duv1];
            if (duv2 == 0) {
                retVal = [gg[1 - b] retain];
#if !__has_feature(objc_arc)
                if (vz != nil) [vz release]; vz = nil;
                if (g1z != nil) [g1z release]; g1z = nil;
                if (g2z != nil) [g2z release]; g2z = nil;
                if (uvDeg != nil) [uvDeg release]; uvDeg = nil;
                if (uv != nil) [uv release]; uv = nil;
                if (ggDeg != nil) [ggDeg release]; ggDeg = nil;
                if (gg != nil) [gg release]; gg = nil;
#endif
                break;
            }
            
            {
                int dgg2 = [ggDeg[1 - b] intValue];
                [gg[b] addShiftedByBitsSafe:gg[1 - b] withOtherDegree:dgg2 withBits:j];
                dgg2 += j;
                
                if (dgg2 > dgg1) {
                    dgg1 = dgg2;
                } else if (dgg2 == dgg1) {
                    dgg1 = [gg[b] degreeFrom:dgg1];
                }
            }
            
            j += (duv2 - duv1);
            duv1 = duv2;
        }
    }
    
    return retVal ? [retVal autorelease] : nil;
}

- (BOOL)isEqual:(id)object {
    BOOL retVal = NO;
    if (object != nil && [object isKindOfClass:[LongArray class]]) {
        retVal = [self equalsWithOther:(LongArray*)object];
    }
    return retVal;
}

- (BOOL)equalsWithOther:(LongArray*)other {
    if (self == other) {
        return YES;
    }
    if (nil == other) {
        return NO;
    }
    int usedLen = [self getUsedLength];
    if ([other getUsedLength] != usedLen) {
        return NO;
    }
    for (int i = 0; i < usedLen; i++) {
        if ([self.m_ints[i] longLongValue] != [other.m_ints[i] longLongValue]) {
            return NO;
        }
    }
    return YES;
}

- (NSUInteger)hash {
    int usedLen = [self getUsedLength];
    int hash = 1;
    for (int i = 0; i < usedLen; i++) {
        int64_t mi = [self.m_ints[i] longLongValue];
        hash *= 31;
        hash ^= (int)mi;
        hash *= 31;
        hash ^= (int)((uint64_t)mi >> 32);
    }
    return hash;
}

- (LongArray*)copy {
    NSMutableArray *tmpArray = [self.m_ints clone];
    LongArray *retVal = [[LongArray alloc] initWithInts:tmpArray];
#if !__has_feature(objc_arc)
    if (tmpArray) [tmpArray release]; tmpArray = nil;
#endif
    return (retVal ? [retVal autorelease] : nil);
}

- (NSString*)toString {
    int i = [self getUsedLength];
    if (i == 0) {
        return @"0";
    }
    
    NSMutableString *mStr = [[[NSMutableString alloc] init] autorelease];
    @autoreleasepool {
        [mStr appendString:[self.m_ints[--i] binaryString]];
        while (--i >= 0) {
            NSString *s = [self.m_ints[i] binaryString];
            
            // Add leading zeroes, except for highest significant word
            int len = (int)(s.length);
            if (len < 64) {
                [mStr appendString:[ZEROES substringFromIndex:len]];
            }
            [mStr appendString:s];
        }
    }
    return mStr;
}

@end
