// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "ChunkServer.pb.h"

@implementation ChunkServerRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [ChunkServerRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface ChunkInfo ()
@property (retain) NSData* chunkChecksum;
@property (retain) NSData* chunkEncryptionKey;
@property int32_t chunkLength;
@property int32_t chunkOffset;
@end

@implementation ChunkInfo

- (BOOL) hasChunkChecksum {
  return !!hasChunkChecksum_;
}
- (void) setHasChunkChecksum:(BOOL) value {
  hasChunkChecksum_ = !!value;
}
@synthesize chunkChecksum;
- (BOOL) hasChunkEncryptionKey {
  return !!hasChunkEncryptionKey_;
}
- (void) setHasChunkEncryptionKey:(BOOL) value {
  hasChunkEncryptionKey_ = !!value;
}
@synthesize chunkEncryptionKey;
- (BOOL) hasChunkLength {
  return !!hasChunkLength_;
}
- (void) setHasChunkLength:(BOOL) value {
  hasChunkLength_ = !!value;
}
@synthesize chunkLength;
- (BOOL) hasChunkOffset {
  return !!hasChunkOffset_;
}
- (void) setHasChunkOffset:(BOOL) value {
  hasChunkOffset_ = !!value;
}
@synthesize chunkOffset;
- (void) dealloc {
  self.chunkChecksum = nil;
  self.chunkEncryptionKey = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.chunkChecksum = [NSData data];
    self.chunkEncryptionKey = [NSData data];
    self.chunkLength = 0;
    self.chunkOffset = 0;
  }
  return self;
}
static ChunkInfo* defaultChunkInfoInstance = nil;
+ (void) initialize {
  if (self == [ChunkInfo class]) {
    defaultChunkInfoInstance = [[ChunkInfo alloc] init];
  }
}
+ (ChunkInfo*) defaultInstance {
  return defaultChunkInfoInstance;
}
- (ChunkInfo*) defaultInstance {
  return defaultChunkInfoInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChunkChecksum) {
    return NO;
  }
  if (!self.hasChunkLength) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChunkChecksum) {
    [output writeData:1 value:self.chunkChecksum];
  }
  if (self.hasChunkEncryptionKey) {
    [output writeData:2 value:self.chunkEncryptionKey];
  }
  if (self.hasChunkLength) {
    [output writeUInt32:3 value:self.chunkLength];
  }
  if (self.hasChunkOffset) {
    [output writeUInt32:4 value:self.chunkOffset];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChunkChecksum) {
    size += computeDataSize(1, self.chunkChecksum);
  }
  if (self.hasChunkEncryptionKey) {
    size += computeDataSize(2, self.chunkEncryptionKey);
  }
  if (self.hasChunkLength) {
    size += computeUInt32Size(3, self.chunkLength);
  }
  if (self.hasChunkOffset) {
    size += computeUInt32Size(4, self.chunkOffset);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkInfo*) parseFromData:(NSData*) data {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeFromData:data] build];
}
+ (ChunkInfo*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkInfo*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeFromInputStream:input] build];
}
+ (ChunkInfo*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeDelimitedFromInputStream:input] build];
}
+ (ChunkInfo*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkInfo*)[[[ChunkInfo builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkInfo_Builder*) builder {
  return [[[ChunkInfo_Builder alloc] init] autorelease];
}
+ (ChunkInfo_Builder*) builderWithPrototype:(ChunkInfo*) prototype {
  return [[ChunkInfo builder] mergeFrom:prototype];
}
- (ChunkInfo_Builder*) builder {
  return [ChunkInfo builder];
}
@end

@interface ChunkInfo_Builder()
@property (retain) ChunkInfo* result;
@end

@implementation ChunkInfo_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkInfo alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkInfo_Builder*) clear {
  self.result = [[[ChunkInfo alloc] init] autorelease];
  return self;
}
- (ChunkInfo_Builder*) clone {
  return [ChunkInfo builderWithPrototype:result];
}
- (ChunkInfo*) defaultInstance {
  return [ChunkInfo defaultInstance];
}
- (ChunkInfo*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkInfo*) buildPartial {
  ChunkInfo* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkInfo_Builder*) mergeFrom:(ChunkInfo*) other {
  if (other == [ChunkInfo defaultInstance]) {
    return self;
  }
  if (other.hasChunkChecksum) {
    [self setChunkChecksum:other.chunkChecksum];
  }
  if (other.hasChunkEncryptionKey) {
    [self setChunkEncryptionKey:other.chunkEncryptionKey];
  }
  if (other.hasChunkLength) {
    [self setChunkLength:other.chunkLength];
  }
  if (other.hasChunkOffset) {
    [self setChunkOffset:other.chunkOffset];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkInfo_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkInfo_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChunkChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setChunkEncryptionKey:[input readData]];
        break;
      }
      case 24: {
        [self setChunkLength:[input readUInt32]];
        break;
      }
      case 32: {
        [self setChunkOffset:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasChunkChecksum {
  return result.hasChunkChecksum;
}
- (NSData*) chunkChecksum {
  return result.chunkChecksum;
}
- (ChunkInfo_Builder*) setChunkChecksum:(NSData*) value {
  result.hasChunkChecksum = YES;
  result.chunkChecksum = value;
  return self;
}
- (ChunkInfo_Builder*) clearChunkChecksum {
  result.hasChunkChecksum = NO;
  result.chunkChecksum = [NSData data];
  return self;
}
- (BOOL) hasChunkEncryptionKey {
  return result.hasChunkEncryptionKey;
}
- (NSData*) chunkEncryptionKey {
  return result.chunkEncryptionKey;
}
- (ChunkInfo_Builder*) setChunkEncryptionKey:(NSData*) value {
  result.hasChunkEncryptionKey = YES;
  result.chunkEncryptionKey = value;
  return self;
}
- (ChunkInfo_Builder*) clearChunkEncryptionKey {
  result.hasChunkEncryptionKey = NO;
  result.chunkEncryptionKey = [NSData data];
  return self;
}
- (BOOL) hasChunkLength {
  return result.hasChunkLength;
}
- (int32_t) chunkLength {
  return result.chunkLength;
}
- (ChunkInfo_Builder*) setChunkLength:(int32_t) value {
  result.hasChunkLength = YES;
  result.chunkLength = value;
  return self;
}
- (ChunkInfo_Builder*) clearChunkLength {
  result.hasChunkLength = NO;
  result.chunkLength = 0;
  return self;
}
- (BOOL) hasChunkOffset {
  return result.hasChunkOffset;
}
- (int32_t) chunkOffset {
  return result.chunkOffset;
}
- (ChunkInfo_Builder*) setChunkOffset:(int32_t) value {
  result.hasChunkOffset = YES;
  result.chunkOffset = value;
  return self;
}
- (ChunkInfo_Builder*) clearChunkOffset {
  result.hasChunkOffset = NO;
  result.chunkOffset = 0;
  return self;
}
@end

@interface NameValuePair ()
@property (retain) NSString* name;
@property (retain) NSString* value;
@end

@implementation NameValuePair

- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value {
  hasName_ = !!value;
}
@synthesize name;
- (BOOL) hasValue {
  return !!hasValue_;
}
- (void) setHasValue:(BOOL) value {
  hasValue_ = !!value;
}
@synthesize value;
- (void) dealloc {
  self.name = nil;
  self.value = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.name = @"";
    self.value = @"";
  }
  return self;
}
static NameValuePair* defaultNameValuePairInstance = nil;
+ (void) initialize {
  if (self == [NameValuePair class]) {
    defaultNameValuePairInstance = [[NameValuePair alloc] init];
  }
}
+ (NameValuePair*) defaultInstance {
  return defaultNameValuePairInstance;
}
- (NameValuePair*) defaultInstance {
  return defaultNameValuePairInstance;
}
- (BOOL) isInitialized {
  if (!self.hasName) {
    return NO;
  }
  if (!self.hasValue) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasName) {
    [output writeString:1 value:self.name];
  }
  if (self.hasValue) {
    [output writeString:2 value:self.value];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasName) {
    size += computeStringSize(1, self.name);
  }
  if (self.hasValue) {
    size += computeStringSize(2, self.value);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (NameValuePair*) parseFromData:(NSData*) data {
  return (NameValuePair*)[[[NameValuePair builder] mergeFromData:data] build];
}
+ (NameValuePair*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (NameValuePair*)[[[NameValuePair builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (NameValuePair*) parseFromInputStream:(NSInputStream*) input {
  return (NameValuePair*)[[[NameValuePair builder] mergeFromInputStream:input] build];
}
+ (NameValuePair*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (NameValuePair*)[[[NameValuePair builder] mergeDelimitedFromInputStream:input] build];
}
+ (NameValuePair*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (NameValuePair*)[[[NameValuePair builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (NameValuePair*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (NameValuePair*)[[[NameValuePair builder] mergeFromCodedInputStream:input] build];
}
+ (NameValuePair*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (NameValuePair*)[[[NameValuePair builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (NameValuePair_Builder*) builder {
  return [[[NameValuePair_Builder alloc] init] autorelease];
}
+ (NameValuePair_Builder*) builderWithPrototype:(NameValuePair*) prototype {
  return [[NameValuePair builder] mergeFrom:prototype];
}
- (NameValuePair_Builder*) builder {
  return [NameValuePair builder];
}
@end

@interface NameValuePair_Builder()
@property (retain) NameValuePair* result;
@end

@implementation NameValuePair_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[NameValuePair alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (NameValuePair_Builder*) clear {
  self.result = [[[NameValuePair alloc] init] autorelease];
  return self;
}
- (NameValuePair_Builder*) clone {
  return [NameValuePair builderWithPrototype:result];
}
- (NameValuePair*) defaultInstance {
  return [NameValuePair defaultInstance];
}
- (NameValuePair*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (NameValuePair*) buildPartial {
  NameValuePair* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (NameValuePair_Builder*) mergeFrom:(NameValuePair*) other {
  if (other == [NameValuePair defaultInstance]) {
    return self;
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasValue) {
    [self setValue:other.value];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (NameValuePair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (NameValuePair_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setName:[input readString]];
        break;
      }
      case 18: {
        [self setValue:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasName {
  return result.hasName;
}
- (NSString*) name {
  return result.name;
}
- (NameValuePair_Builder*) setName:(NSString*) value {
  result.hasName = YES;
  result.name = value;
  return self;
}
- (NameValuePair_Builder*) clearName {
  result.hasName = NO;
  result.name = @"";
  return self;
}
- (BOOL) hasValue {
  return result.hasValue;
}
- (NSString*) value {
  return result.value;
}
- (NameValuePair_Builder*) setValue:(NSString*) value {
  result.hasValue = YES;
  result.value = value;
  return self;
}
- (NameValuePair_Builder*) clearValue {
  result.hasValue = NO;
  result.value = @"";
  return self;
}
@end

@interface HostInfo ()
@property (retain) NSString* hostname;
@property int32_t port;
@property (retain) NSString* method;
@property (retain) NSString* uri;
@property (retain) NSString* transportProtocol;
@property (retain) NSString* transportProtocolVersion;
@property (retain) NSString* scheme;
@property (retain) NSMutableArray* mutableHeadersList;
@property (retain) NSString* datacenter;
@property int64_t expiry;
@end

@implementation HostInfo

- (BOOL) hasHostname {
  return !!hasHostname_;
}
- (void) setHasHostname:(BOOL) value {
  hasHostname_ = !!value;
}
@synthesize hostname;
- (BOOL) hasPort {
  return !!hasPort_;
}
- (void) setHasPort:(BOOL) value {
  hasPort_ = !!value;
}
@synthesize port;
- (BOOL) hasMethod {
  return !!hasMethod_;
}
- (void) setHasMethod:(BOOL) value {
  hasMethod_ = !!value;
}
@synthesize method;
- (BOOL) hasUri {
  return !!hasUri_;
}
- (void) setHasUri:(BOOL) value {
  hasUri_ = !!value;
}
@synthesize uri;
- (BOOL) hasTransportProtocol {
  return !!hasTransportProtocol_;
}
- (void) setHasTransportProtocol:(BOOL) value {
  hasTransportProtocol_ = !!value;
}
@synthesize transportProtocol;
- (BOOL) hasTransportProtocolVersion {
  return !!hasTransportProtocolVersion_;
}
- (void) setHasTransportProtocolVersion:(BOOL) value {
  hasTransportProtocolVersion_ = !!value;
}
@synthesize transportProtocolVersion;
- (BOOL) hasScheme {
  return !!hasScheme_;
}
- (void) setHasScheme:(BOOL) value {
  hasScheme_ = !!value;
}
@synthesize scheme;
@synthesize mutableHeadersList;
- (BOOL) hasDatacenter {
  return !!hasDatacenter_;
}
- (void) setHasDatacenter:(BOOL) value {
  hasDatacenter_ = !!value;
}
@synthesize datacenter;
- (BOOL) hasExpiry {
  return !!hasExpiry_;
}
- (void) setHasExpiry:(BOOL) value {
  hasExpiry_ = !!value;
}
@synthesize expiry;
- (void) dealloc {
  self.hostname = nil;
  self.method = nil;
  self.uri = nil;
  self.transportProtocol = nil;
  self.transportProtocolVersion = nil;
  self.scheme = nil;
  self.mutableHeadersList = nil;
  self.datacenter = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.hostname = @"";
    self.port = 0;
    self.method = @"";
    self.uri = @"";
    self.transportProtocol = @"";
    self.transportProtocolVersion = @"";
    self.scheme = @"";
    self.datacenter = @"";
    self.expiry = 0L;
  }
  return self;
}
static HostInfo* defaultHostInfoInstance = nil;
+ (void) initialize {
  if (self == [HostInfo class]) {
    defaultHostInfoInstance = [[HostInfo alloc] init];
  }
}
+ (HostInfo*) defaultInstance {
  return defaultHostInfoInstance;
}
- (HostInfo*) defaultInstance {
  return defaultHostInfoInstance;
}
- (NSArray*) headersList {
  return mutableHeadersList;
}
- (NameValuePair*) headersAtIndex:(int32_t) index {
  id value = [mutableHeadersList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasHostname) {
    return NO;
  }
  if (!self.hasPort) {
    return NO;
  }
  if (!self.hasMethod) {
    return NO;
  }
  if (!self.hasUri) {
    return NO;
  }
  if (!self.hasTransportProtocol) {
    return NO;
  }
  if (!self.hasTransportProtocolVersion) {
    return NO;
  }
  if (!self.hasScheme) {
    return NO;
  }
  for (NameValuePair* element in self.headersList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasHostname) {
    [output writeString:1 value:self.hostname];
  }
  if (self.hasPort) {
    [output writeUInt32:2 value:self.port];
  }
  if (self.hasMethod) {
    [output writeString:3 value:self.method];
  }
  if (self.hasUri) {
    [output writeString:4 value:self.uri];
  }
  if (self.hasTransportProtocol) {
    [output writeString:5 value:self.transportProtocol];
  }
  if (self.hasTransportProtocolVersion) {
    [output writeString:6 value:self.transportProtocolVersion];
  }
  if (self.hasScheme) {
    [output writeString:7 value:self.scheme];
  }
  for (NameValuePair* element in self.headersList) {
    [output writeMessage:8 value:element];
  }
  if (self.hasDatacenter) {
    [output writeString:9 value:self.datacenter];
  }
  if (self.hasExpiry) {
    [output writeUInt64:11 value:self.expiry];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasHostname) {
    size += computeStringSize(1, self.hostname);
  }
  if (self.hasPort) {
    size += computeUInt32Size(2, self.port);
  }
  if (self.hasMethod) {
    size += computeStringSize(3, self.method);
  }
  if (self.hasUri) {
    size += computeStringSize(4, self.uri);
  }
  if (self.hasTransportProtocol) {
    size += computeStringSize(5, self.transportProtocol);
  }
  if (self.hasTransportProtocolVersion) {
    size += computeStringSize(6, self.transportProtocolVersion);
  }
  if (self.hasScheme) {
    size += computeStringSize(7, self.scheme);
  }
  for (NameValuePair* element in self.headersList) {
    size += computeMessageSize(8, element);
  }
  if (self.hasDatacenter) {
    size += computeStringSize(9, self.datacenter);
  }
  if (self.hasExpiry) {
    size += computeUInt64Size(11, self.expiry);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (HostInfo*) parseFromData:(NSData*) data {
  return (HostInfo*)[[[HostInfo builder] mergeFromData:data] build];
}
+ (HostInfo*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HostInfo*)[[[HostInfo builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (HostInfo*) parseFromInputStream:(NSInputStream*) input {
  return (HostInfo*)[[[HostInfo builder] mergeFromInputStream:input] build];
}
+ (HostInfo*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (HostInfo*)[[[HostInfo builder] mergeDelimitedFromInputStream:input] build];
}
+ (HostInfo*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HostInfo*)[[[HostInfo builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HostInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (HostInfo*)[[[HostInfo builder] mergeFromCodedInputStream:input] build];
}
+ (HostInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HostInfo*)[[[HostInfo builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HostInfo_Builder*) builder {
  return [[[HostInfo_Builder alloc] init] autorelease];
}
+ (HostInfo_Builder*) builderWithPrototype:(HostInfo*) prototype {
  return [[HostInfo builder] mergeFrom:prototype];
}
- (HostInfo_Builder*) builder {
  return [HostInfo builder];
}
@end

@interface HostInfo_Builder()
@property (retain) HostInfo* result;
@end

@implementation HostInfo_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[HostInfo alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (HostInfo_Builder*) clear {
  self.result = [[[HostInfo alloc] init] autorelease];
  return self;
}
- (HostInfo_Builder*) clone {
  return [HostInfo builderWithPrototype:result];
}
- (HostInfo*) defaultInstance {
  return [HostInfo defaultInstance];
}
- (HostInfo*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (HostInfo*) buildPartial {
  HostInfo* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (HostInfo_Builder*) mergeFrom:(HostInfo*) other {
  if (other == [HostInfo defaultInstance]) {
    return self;
  }
  if (other.hasHostname) {
    [self setHostname:other.hostname];
  }
  if (other.hasPort) {
    [self setPort:other.port];
  }
  if (other.hasMethod) {
    [self setMethod:other.method];
  }
  if (other.hasUri) {
    [self setUri:other.uri];
  }
  if (other.hasTransportProtocol) {
    [self setTransportProtocol:other.transportProtocol];
  }
  if (other.hasTransportProtocolVersion) {
    [self setTransportProtocolVersion:other.transportProtocolVersion];
  }
  if (other.hasScheme) {
    [self setScheme:other.scheme];
  }
  if (other.mutableHeadersList.count > 0) {
    if (result.mutableHeadersList == nil) {
      result.mutableHeadersList = [NSMutableArray array];
    }
    [result.mutableHeadersList addObjectsFromArray:other.mutableHeadersList];
  }
  if (other.hasDatacenter) {
    [self setDatacenter:other.datacenter];
  }
  if (other.hasExpiry) {
    [self setExpiry:other.expiry];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (HostInfo_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (HostInfo_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setHostname:[input readString]];
        break;
      }
      case 16: {
        [self setPort:[input readUInt32]];
        break;
      }
      case 26: {
        [self setMethod:[input readString]];
        break;
      }
      case 34: {
        [self setUri:[input readString]];
        break;
      }
      case 42: {
        [self setTransportProtocol:[input readString]];
        break;
      }
      case 50: {
        [self setTransportProtocolVersion:[input readString]];
        break;
      }
      case 58: {
        [self setScheme:[input readString]];
        break;
      }
      case 66: {
        NameValuePair_Builder* subBuilder = [NameValuePair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addHeaders:[subBuilder buildPartial]];
        break;
      }
      case 74: {
        [self setDatacenter:[input readString]];
        break;
      }
      case 88: {
        [self setExpiry:[input readUInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasHostname {
  return result.hasHostname;
}
- (NSString*) hostname {
  return result.hostname;
}
- (HostInfo_Builder*) setHostname:(NSString*) value {
  result.hasHostname = YES;
  result.hostname = value;
  return self;
}
- (HostInfo_Builder*) clearHostname {
  result.hasHostname = NO;
  result.hostname = @"";
  return self;
}
- (BOOL) hasPort {
  return result.hasPort;
}
- (int32_t) port {
  return result.port;
}
- (HostInfo_Builder*) setPort:(int32_t) value {
  result.hasPort = YES;
  result.port = value;
  return self;
}
- (HostInfo_Builder*) clearPort {
  result.hasPort = NO;
  result.port = 0;
  return self;
}
- (BOOL) hasMethod {
  return result.hasMethod;
}
- (NSString*) method {
  return result.method;
}
- (HostInfo_Builder*) setMethod:(NSString*) value {
  result.hasMethod = YES;
  result.method = value;
  return self;
}
- (HostInfo_Builder*) clearMethod {
  result.hasMethod = NO;
  result.method = @"";
  return self;
}
- (BOOL) hasUri {
  return result.hasUri;
}
- (NSString*) uri {
  return result.uri;
}
- (HostInfo_Builder*) setUri:(NSString*) value {
  result.hasUri = YES;
  result.uri = value;
  return self;
}
- (HostInfo_Builder*) clearUri {
  result.hasUri = NO;
  result.uri = @"";
  return self;
}
- (BOOL) hasTransportProtocol {
  return result.hasTransportProtocol;
}
- (NSString*) transportProtocol {
  return result.transportProtocol;
}
- (HostInfo_Builder*) setTransportProtocol:(NSString*) value {
  result.hasTransportProtocol = YES;
  result.transportProtocol = value;
  return self;
}
- (HostInfo_Builder*) clearTransportProtocol {
  result.hasTransportProtocol = NO;
  result.transportProtocol = @"";
  return self;
}
- (BOOL) hasTransportProtocolVersion {
  return result.hasTransportProtocolVersion;
}
- (NSString*) transportProtocolVersion {
  return result.transportProtocolVersion;
}
- (HostInfo_Builder*) setTransportProtocolVersion:(NSString*) value {
  result.hasTransportProtocolVersion = YES;
  result.transportProtocolVersion = value;
  return self;
}
- (HostInfo_Builder*) clearTransportProtocolVersion {
  result.hasTransportProtocolVersion = NO;
  result.transportProtocolVersion = @"";
  return self;
}
- (BOOL) hasScheme {
  return result.hasScheme;
}
- (NSString*) scheme {
  return result.scheme;
}
- (HostInfo_Builder*) setScheme:(NSString*) value {
  result.hasScheme = YES;
  result.scheme = value;
  return self;
}
- (HostInfo_Builder*) clearScheme {
  result.hasScheme = NO;
  result.scheme = @"";
  return self;
}
- (NSArray*) headersList {
  if (result.mutableHeadersList == nil) { return [NSArray array]; }
  return result.mutableHeadersList;
}
- (NameValuePair*) headersAtIndex:(int32_t) index {
  return [result headersAtIndex:index];
}
- (HostInfo_Builder*) replaceHeadersAtIndex:(int32_t) index with:(NameValuePair*) value {
  [result.mutableHeadersList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (HostInfo_Builder*) addAllHeaders:(NSArray*) values {
  if (result.mutableHeadersList == nil) {
    result.mutableHeadersList = [NSMutableArray array];
  }
  [result.mutableHeadersList addObjectsFromArray:values];
  return self;
}
- (HostInfo_Builder*) clearHeadersList {
  result.mutableHeadersList = nil;
  return self;
}
- (HostInfo_Builder*) addHeaders:(NameValuePair*) value {
  if (result.mutableHeadersList == nil) {
    result.mutableHeadersList = [NSMutableArray array];
  }
  [result.mutableHeadersList addObject:value];
  return self;
}
- (BOOL) hasDatacenter {
  return result.hasDatacenter;
}
- (NSString*) datacenter {
  return result.datacenter;
}
- (HostInfo_Builder*) setDatacenter:(NSString*) value {
  result.hasDatacenter = YES;
  result.datacenter = value;
  return self;
}
- (HostInfo_Builder*) clearDatacenter {
  result.hasDatacenter = NO;
  result.datacenter = @"";
  return self;
}
- (BOOL) hasExpiry {
  return result.hasExpiry;
}
- (int64_t) expiry {
  return result.expiry;
}
- (HostInfo_Builder*) setExpiry:(int64_t) value {
  result.hasExpiry = YES;
  result.expiry = value;
  return self;
}
- (HostInfo_Builder*) clearExpiry {
  result.hasExpiry = NO;
  result.expiry = 0L;
  return self;
}
@end

@interface ErrorResponse ()
@property (retain) NSString* domain;
@property int32_t errorCode;
@property (retain) NSString* errorDescription;
@property (retain) NSMutableArray* mutableUnderlyingErrorsList;
@property (retain) NSMutableArray* mutableNameValuePairList;
@end

@implementation ErrorResponse

- (BOOL) hasDomain {
  return !!hasDomain_;
}
- (void) setHasDomain:(BOOL) value {
  hasDomain_ = !!value;
}
@synthesize domain;
- (BOOL) hasErrorCode {
  return !!hasErrorCode_;
}
- (void) setHasErrorCode:(BOOL) value {
  hasErrorCode_ = !!value;
}
@synthesize errorCode;
- (BOOL) hasErrorDescription {
  return !!hasErrorDescription_;
}
- (void) setHasErrorDescription:(BOOL) value {
  hasErrorDescription_ = !!value;
}
@synthesize errorDescription;
@synthesize mutableUnderlyingErrorsList;
@synthesize mutableNameValuePairList;
- (void) dealloc {
  self.domain = nil;
  self.errorDescription = nil;
  self.mutableUnderlyingErrorsList = nil;
  self.mutableNameValuePairList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.domain = @"";
    self.errorCode = 0;
    self.errorDescription = @"";
  }
  return self;
}
static ErrorResponse* defaultErrorResponseInstance = nil;
+ (void) initialize {
  if (self == [ErrorResponse class]) {
    defaultErrorResponseInstance = [[ErrorResponse alloc] init];
  }
}
+ (ErrorResponse*) defaultInstance {
  return defaultErrorResponseInstance;
}
- (ErrorResponse*) defaultInstance {
  return defaultErrorResponseInstance;
}
- (NSArray*) underlyingErrorsList {
  return mutableUnderlyingErrorsList;
}
- (ErrorResponse*) underlyingErrorsAtIndex:(int32_t) index {
  id value = [mutableUnderlyingErrorsList objectAtIndex:index];
  return value;
}
- (NSArray*) nameValuePairList {
  return mutableNameValuePairList;
}
- (NameValuePair*) nameValuePairAtIndex:(int32_t) index {
  id value = [mutableNameValuePairList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasDomain) {
    return NO;
  }
  if (!self.hasErrorCode) {
    return NO;
  }
  for (ErrorResponse* element in self.underlyingErrorsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (NameValuePair* element in self.nameValuePairList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasDomain) {
    [output writeString:1 value:self.domain];
  }
  if (self.hasErrorCode) {
    [output writeInt32:2 value:self.errorCode];
  }
  if (self.hasErrorDescription) {
    [output writeString:3 value:self.errorDescription];
  }
  for (ErrorResponse* element in self.underlyingErrorsList) {
    [output writeMessage:4 value:element];
  }
  for (NameValuePair* element in self.nameValuePairList) {
    [output writeMessage:5 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasDomain) {
    size += computeStringSize(1, self.domain);
  }
  if (self.hasErrorCode) {
    size += computeInt32Size(2, self.errorCode);
  }
  if (self.hasErrorDescription) {
    size += computeStringSize(3, self.errorDescription);
  }
  for (ErrorResponse* element in self.underlyingErrorsList) {
    size += computeMessageSize(4, element);
  }
  for (NameValuePair* element in self.nameValuePairList) {
    size += computeMessageSize(5, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ErrorResponse*) parseFromData:(NSData*) data {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeFromData:data] build];
}
+ (ErrorResponse*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ErrorResponse*) parseFromInputStream:(NSInputStream*) input {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeFromInputStream:input] build];
}
+ (ErrorResponse*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeDelimitedFromInputStream:input] build];
}
+ (ErrorResponse*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ErrorResponse*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeFromCodedInputStream:input] build];
}
+ (ErrorResponse*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ErrorResponse*)[[[ErrorResponse builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ErrorResponse_Builder*) builder {
  return [[[ErrorResponse_Builder alloc] init] autorelease];
}
+ (ErrorResponse_Builder*) builderWithPrototype:(ErrorResponse*) prototype {
  return [[ErrorResponse builder] mergeFrom:prototype];
}
- (ErrorResponse_Builder*) builder {
  return [ErrorResponse builder];
}
@end

@interface ErrorResponse_Builder()
@property (retain) ErrorResponse* result;
@end

@implementation ErrorResponse_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ErrorResponse alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ErrorResponse_Builder*) clear {
  self.result = [[[ErrorResponse alloc] init] autorelease];
  return self;
}
- (ErrorResponse_Builder*) clone {
  return [ErrorResponse builderWithPrototype:result];
}
- (ErrorResponse*) defaultInstance {
  return [ErrorResponse defaultInstance];
}
- (ErrorResponse*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ErrorResponse*) buildPartial {
  ErrorResponse* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ErrorResponse_Builder*) mergeFrom:(ErrorResponse*) other {
  if (other == [ErrorResponse defaultInstance]) {
    return self;
  }
  if (other.hasDomain) {
    [self setDomain:other.domain];
  }
  if (other.hasErrorCode) {
    [self setErrorCode:other.errorCode];
  }
  if (other.hasErrorDescription) {
    [self setErrorDescription:other.errorDescription];
  }
  if (other.mutableUnderlyingErrorsList.count > 0) {
    if (result.mutableUnderlyingErrorsList == nil) {
      result.mutableUnderlyingErrorsList = [NSMutableArray array];
    }
    [result.mutableUnderlyingErrorsList addObjectsFromArray:other.mutableUnderlyingErrorsList];
  }
  if (other.mutableNameValuePairList.count > 0) {
    if (result.mutableNameValuePairList == nil) {
      result.mutableNameValuePairList = [NSMutableArray array];
    }
    [result.mutableNameValuePairList addObjectsFromArray:other.mutableNameValuePairList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ErrorResponse_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ErrorResponse_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setDomain:[input readString]];
        break;
      }
      case 16: {
        [self setErrorCode:[input readInt32]];
        break;
      }
      case 26: {
        [self setErrorDescription:[input readString]];
        break;
      }
      case 34: {
        ErrorResponse_Builder* subBuilder = [ErrorResponse builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addUnderlyingErrors:[subBuilder buildPartial]];
        break;
      }
      case 42: {
        NameValuePair_Builder* subBuilder = [NameValuePair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addNameValuePair:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasDomain {
  return result.hasDomain;
}
- (NSString*) domain {
  return result.domain;
}
- (ErrorResponse_Builder*) setDomain:(NSString*) value {
  result.hasDomain = YES;
  result.domain = value;
  return self;
}
- (ErrorResponse_Builder*) clearDomain {
  result.hasDomain = NO;
  result.domain = @"";
  return self;
}
- (BOOL) hasErrorCode {
  return result.hasErrorCode;
}
- (int32_t) errorCode {
  return result.errorCode;
}
- (ErrorResponse_Builder*) setErrorCode:(int32_t) value {
  result.hasErrorCode = YES;
  result.errorCode = value;
  return self;
}
- (ErrorResponse_Builder*) clearErrorCode {
  result.hasErrorCode = NO;
  result.errorCode = 0;
  return self;
}
- (BOOL) hasErrorDescription {
  return result.hasErrorDescription;
}
- (NSString*) errorDescription {
  return result.errorDescription;
}
- (ErrorResponse_Builder*) setErrorDescription:(NSString*) value {
  result.hasErrorDescription = YES;
  result.errorDescription = value;
  return self;
}
- (ErrorResponse_Builder*) clearErrorDescription {
  result.hasErrorDescription = NO;
  result.errorDescription = @"";
  return self;
}
- (NSArray*) underlyingErrorsList {
  if (result.mutableUnderlyingErrorsList == nil) { return [NSArray array]; }
  return result.mutableUnderlyingErrorsList;
}
- (ErrorResponse*) underlyingErrorsAtIndex:(int32_t) index {
  return [result underlyingErrorsAtIndex:index];
}
- (ErrorResponse_Builder*) replaceUnderlyingErrorsAtIndex:(int32_t) index with:(ErrorResponse*) value {
  [result.mutableUnderlyingErrorsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (ErrorResponse_Builder*) addAllUnderlyingErrors:(NSArray*) values {
  if (result.mutableUnderlyingErrorsList == nil) {
    result.mutableUnderlyingErrorsList = [NSMutableArray array];
  }
  [result.mutableUnderlyingErrorsList addObjectsFromArray:values];
  return self;
}
- (ErrorResponse_Builder*) clearUnderlyingErrorsList {
  result.mutableUnderlyingErrorsList = nil;
  return self;
}
- (ErrorResponse_Builder*) addUnderlyingErrors:(ErrorResponse*) value {
  if (result.mutableUnderlyingErrorsList == nil) {
    result.mutableUnderlyingErrorsList = [NSMutableArray array];
  }
  [result.mutableUnderlyingErrorsList addObject:value];
  return self;
}
- (NSArray*) nameValuePairList {
  if (result.mutableNameValuePairList == nil) { return [NSArray array]; }
  return result.mutableNameValuePairList;
}
- (NameValuePair*) nameValuePairAtIndex:(int32_t) index {
  return [result nameValuePairAtIndex:index];
}
- (ErrorResponse_Builder*) replaceNameValuePairAtIndex:(int32_t) index with:(NameValuePair*) value {
  [result.mutableNameValuePairList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (ErrorResponse_Builder*) addAllNameValuePair:(NSArray*) values {
  if (result.mutableNameValuePairList == nil) {
    result.mutableNameValuePairList = [NSMutableArray array];
  }
  [result.mutableNameValuePairList addObjectsFromArray:values];
  return self;
}
- (ErrorResponse_Builder*) clearNameValuePairList {
  result.mutableNameValuePairList = nil;
  return self;
}
- (ErrorResponse_Builder*) addNameValuePair:(NameValuePair*) value {
  if (result.mutableNameValuePairList == nil) {
    result.mutableNameValuePairList = [NSMutableArray array];
  }
  [result.mutableNameValuePairList addObject:value];
  return self;
}
@end

@interface FileError ()
@property (retain) NSData* fileChecksum;
@property (retain) ErrorResponse* errorResponse;
@end

@implementation FileError

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (void) dealloc {
  self.fileChecksum = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.errorResponse = [ErrorResponse defaultInstance];
  }
  return self;
}
static FileError* defaultFileErrorInstance = nil;
+ (void) initialize {
  if (self == [FileError class]) {
    defaultFileErrorInstance = [[FileError alloc] init];
  }
}
+ (FileError*) defaultInstance {
  return defaultFileErrorInstance;
}
- (FileError*) defaultInstance {
  return defaultFileErrorInstance;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileError*) parseFromData:(NSData*) data {
  return (FileError*)[[[FileError builder] mergeFromData:data] build];
}
+ (FileError*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileError*)[[[FileError builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileError*) parseFromInputStream:(NSInputStream*) input {
  return (FileError*)[[[FileError builder] mergeFromInputStream:input] build];
}
+ (FileError*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileError*)[[[FileError builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileError*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileError*)[[[FileError builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileError*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileError*)[[[FileError builder] mergeFromCodedInputStream:input] build];
}
+ (FileError*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileError*)[[[FileError builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileError_Builder*) builder {
  return [[[FileError_Builder alloc] init] autorelease];
}
+ (FileError_Builder*) builderWithPrototype:(FileError*) prototype {
  return [[FileError builder] mergeFrom:prototype];
}
- (FileError_Builder*) builder {
  return [FileError builder];
}
@end

@interface FileError_Builder()
@property (retain) FileError* result;
@end

@implementation FileError_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileError alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileError_Builder*) clear {
  self.result = [[[FileError alloc] init] autorelease];
  return self;
}
- (FileError_Builder*) clone {
  return [FileError builderWithPrototype:result];
}
- (FileError*) defaultInstance {
  return [FileError defaultInstance];
}
- (FileError*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileError*) buildPartial {
  FileError* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileError_Builder*) mergeFrom:(FileError*) other {
  if (other == [FileError defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        ErrorResponse_Builder* subBuilder = [ErrorResponse builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileError_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileError_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponse*) errorResponse {
  return result.errorResponse;
}
- (FileError_Builder*) setErrorResponse:(ErrorResponse*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (FileError_Builder*) setErrorResponseBuilder:(ErrorResponse_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (FileError_Builder*) mergeErrorResponse:(ErrorResponse*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponse defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponse builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (FileError_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponse defaultInstance];
  return self;
}
@end

@interface ChunkError ()
@property (retain) NSData* chunkChecksum;
@property (retain) ErrorResponse* errorResponse;
@end

@implementation ChunkError

- (BOOL) hasChunkChecksum {
  return !!hasChunkChecksum_;
}
- (void) setHasChunkChecksum:(BOOL) value {
  hasChunkChecksum_ = !!value;
}
@synthesize chunkChecksum;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (void) dealloc {
  self.chunkChecksum = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.chunkChecksum = [NSData data];
    self.errorResponse = [ErrorResponse defaultInstance];
  }
  return self;
}
static ChunkError* defaultChunkErrorInstance = nil;
+ (void) initialize {
  if (self == [ChunkError class]) {
    defaultChunkErrorInstance = [[ChunkError alloc] init];
  }
}
+ (ChunkError*) defaultInstance {
  return defaultChunkErrorInstance;
}
- (ChunkError*) defaultInstance {
  return defaultChunkErrorInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChunkChecksum) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChunkChecksum) {
    [output writeData:1 value:self.chunkChecksum];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChunkChecksum) {
    size += computeDataSize(1, self.chunkChecksum);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkError*) parseFromData:(NSData*) data {
  return (ChunkError*)[[[ChunkError builder] mergeFromData:data] build];
}
+ (ChunkError*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkError*)[[[ChunkError builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkError*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkError*)[[[ChunkError builder] mergeFromInputStream:input] build];
}
+ (ChunkError*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (ChunkError*)[[[ChunkError builder] mergeDelimitedFromInputStream:input] build];
}
+ (ChunkError*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkError*)[[[ChunkError builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkError*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkError*)[[[ChunkError builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkError*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkError*)[[[ChunkError builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkError_Builder*) builder {
  return [[[ChunkError_Builder alloc] init] autorelease];
}
+ (ChunkError_Builder*) builderWithPrototype:(ChunkError*) prototype {
  return [[ChunkError builder] mergeFrom:prototype];
}
- (ChunkError_Builder*) builder {
  return [ChunkError builder];
}
@end

@interface ChunkError_Builder()
@property (retain) ChunkError* result;
@end

@implementation ChunkError_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkError alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkError_Builder*) clear {
  self.result = [[[ChunkError alloc] init] autorelease];
  return self;
}
- (ChunkError_Builder*) clone {
  return [ChunkError builderWithPrototype:result];
}
- (ChunkError*) defaultInstance {
  return [ChunkError defaultInstance];
}
- (ChunkError*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkError*) buildPartial {
  ChunkError* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkError_Builder*) mergeFrom:(ChunkError*) other {
  if (other == [ChunkError defaultInstance]) {
    return self;
  }
  if (other.hasChunkChecksum) {
    [self setChunkChecksum:other.chunkChecksum];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChunkChecksum:[input readData]];
        break;
      }
      case 18: {
        ErrorResponse_Builder* subBuilder = [ErrorResponse builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasChunkChecksum {
  return result.hasChunkChecksum;
}
- (NSData*) chunkChecksum {
  return result.chunkChecksum;
}
- (ChunkError_Builder*) setChunkChecksum:(NSData*) value {
  result.hasChunkChecksum = YES;
  result.chunkChecksum = value;
  return self;
}
- (ChunkError_Builder*) clearChunkChecksum {
  result.hasChunkChecksum = NO;
  result.chunkChecksum = [NSData data];
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponse*) errorResponse {
  return result.errorResponse;
}
- (ChunkError_Builder*) setErrorResponse:(ErrorResponse*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (ChunkError_Builder*) setErrorResponseBuilder:(ErrorResponse_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (ChunkError_Builder*) mergeErrorResponse:(ErrorResponse*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponse defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponse builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (ChunkError_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponse defaultInstance];
  return self;
}
@end

@interface ChunkErrorIndex ()
@property (retain) NSData* chunkChecksum;
@property (retain) ErrorResponse* errorResponse;
@property int32_t chunkIndex;
@end

@implementation ChunkErrorIndex

- (BOOL) hasChunkChecksum {
  return !!hasChunkChecksum_;
}
- (void) setHasChunkChecksum:(BOOL) value {
  hasChunkChecksum_ = !!value;
}
@synthesize chunkChecksum;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (BOOL) hasChunkIndex {
  return !!hasChunkIndex_;
}
- (void) setHasChunkIndex:(BOOL) value {
  hasChunkIndex_ = !!value;
}
@synthesize chunkIndex;
- (void) dealloc {
  self.chunkChecksum = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.chunkChecksum = [NSData data];
    self.errorResponse = [ErrorResponse defaultInstance];
    self.chunkIndex = 0;
  }
  return self;
}
static ChunkErrorIndex* defaultChunkErrorIndexInstance = nil;
+ (void) initialize {
  if (self == [ChunkErrorIndex class]) {
    defaultChunkErrorIndexInstance = [[ChunkErrorIndex alloc] init];
  }
}
+ (ChunkErrorIndex*) defaultInstance {
  return defaultChunkErrorIndexInstance;
}
- (ChunkErrorIndex*) defaultInstance {
  return defaultChunkErrorIndexInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChunkChecksum) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.hasChunkIndex) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChunkChecksum) {
    [output writeData:1 value:self.chunkChecksum];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  if (self.hasChunkIndex) {
    [output writeUInt32:3 value:self.chunkIndex];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChunkChecksum) {
    size += computeDataSize(1, self.chunkChecksum);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  if (self.hasChunkIndex) {
    size += computeUInt32Size(3, self.chunkIndex);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkErrorIndex*) parseFromData:(NSData*) data {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeFromData:data] build];
}
+ (ChunkErrorIndex*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorIndex*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeFromInputStream:input] build];
}
+ (ChunkErrorIndex*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeDelimitedFromInputStream:input] build];
}
+ (ChunkErrorIndex*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorIndex*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkErrorIndex*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorIndex*)[[[ChunkErrorIndex builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorIndex_Builder*) builder {
  return [[[ChunkErrorIndex_Builder alloc] init] autorelease];
}
+ (ChunkErrorIndex_Builder*) builderWithPrototype:(ChunkErrorIndex*) prototype {
  return [[ChunkErrorIndex builder] mergeFrom:prototype];
}
- (ChunkErrorIndex_Builder*) builder {
  return [ChunkErrorIndex builder];
}
@end

@interface ChunkErrorIndex_Builder()
@property (retain) ChunkErrorIndex* result;
@end

@implementation ChunkErrorIndex_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkErrorIndex alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkErrorIndex_Builder*) clear {
  self.result = [[[ChunkErrorIndex alloc] init] autorelease];
  return self;
}
- (ChunkErrorIndex_Builder*) clone {
  return [ChunkErrorIndex builderWithPrototype:result];
}
- (ChunkErrorIndex*) defaultInstance {
  return [ChunkErrorIndex defaultInstance];
}
- (ChunkErrorIndex*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkErrorIndex*) buildPartial {
  ChunkErrorIndex* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkErrorIndex_Builder*) mergeFrom:(ChunkErrorIndex*) other {
  if (other == [ChunkErrorIndex defaultInstance]) {
    return self;
  }
  if (other.hasChunkChecksum) {
    [self setChunkChecksum:other.chunkChecksum];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  if (other.hasChunkIndex) {
    [self setChunkIndex:other.chunkIndex];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkErrorIndex_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkErrorIndex_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChunkChecksum:[input readData]];
        break;
      }
      case 18: {
        ErrorResponse_Builder* subBuilder = [ErrorResponse builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setChunkIndex:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasChunkChecksum {
  return result.hasChunkChecksum;
}
- (NSData*) chunkChecksum {
  return result.chunkChecksum;
}
- (ChunkErrorIndex_Builder*) setChunkChecksum:(NSData*) value {
  result.hasChunkChecksum = YES;
  result.chunkChecksum = value;
  return self;
}
- (ChunkErrorIndex_Builder*) clearChunkChecksum {
  result.hasChunkChecksum = NO;
  result.chunkChecksum = [NSData data];
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponse*) errorResponse {
  return result.errorResponse;
}
- (ChunkErrorIndex_Builder*) setErrorResponse:(ErrorResponse*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (ChunkErrorIndex_Builder*) setErrorResponseBuilder:(ErrorResponse_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (ChunkErrorIndex_Builder*) mergeErrorResponse:(ErrorResponse*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponse defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponse builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (ChunkErrorIndex_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponse defaultInstance];
  return self;
}
- (BOOL) hasChunkIndex {
  return result.hasChunkIndex;
}
- (int32_t) chunkIndex {
  return result.chunkIndex;
}
- (ChunkErrorIndex_Builder*) setChunkIndex:(int32_t) value {
  result.hasChunkIndex = YES;
  result.chunkIndex = value;
  return self;
}
- (ChunkErrorIndex_Builder*) clearChunkIndex {
  result.hasChunkIndex = NO;
  result.chunkIndex = 0;
  return self;
}
@end

@interface FileChunkError ()
@property (retain) NSData* fileChecksum;
@property (retain) NSMutableArray* mutableChunkErrorList;
@end

@implementation FileChunkError

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
@synthesize mutableChunkErrorList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.mutableChunkErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
  }
  return self;
}
static FileChunkError* defaultFileChunkErrorInstance = nil;
+ (void) initialize {
  if (self == [FileChunkError class]) {
    defaultFileChunkErrorInstance = [[FileChunkError alloc] init];
  }
}
+ (FileChunkError*) defaultInstance {
  return defaultFileChunkErrorInstance;
}
- (FileChunkError*) defaultInstance {
  return defaultFileChunkErrorInstance;
}
- (NSArray*) chunkErrorList {
  return mutableChunkErrorList;
}
- (ChunkErrorIndex*) chunkErrorAtIndex:(int32_t) index {
  id value = [mutableChunkErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  for (ChunkErrorIndex* element in self.chunkErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  for (ChunkErrorIndex* element in self.chunkErrorList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  for (ChunkErrorIndex* element in self.chunkErrorList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChunkError*) parseFromData:(NSData*) data {
  return (FileChunkError*)[[[FileChunkError builder] mergeFromData:data] build];
}
+ (FileChunkError*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkError*)[[[FileChunkError builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChunkError*) parseFromInputStream:(NSInputStream*) input {
  return (FileChunkError*)[[[FileChunkError builder] mergeFromInputStream:input] build];
}
+ (FileChunkError*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChunkError*)[[[FileChunkError builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChunkError*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkError*)[[[FileChunkError builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkError*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChunkError*)[[[FileChunkError builder] mergeFromCodedInputStream:input] build];
}
+ (FileChunkError*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkError*)[[[FileChunkError builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkError_Builder*) builder {
  return [[[FileChunkError_Builder alloc] init] autorelease];
}
+ (FileChunkError_Builder*) builderWithPrototype:(FileChunkError*) prototype {
  return [[FileChunkError builder] mergeFrom:prototype];
}
- (FileChunkError_Builder*) builder {
  return [FileChunkError builder];
}
@end

@interface FileChunkError_Builder()
@property (retain) FileChunkError* result;
@end

@implementation FileChunkError_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChunkError alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChunkError_Builder*) clear {
  self.result = [[[FileChunkError alloc] init] autorelease];
  return self;
}
- (FileChunkError_Builder*) clone {
  return [FileChunkError builderWithPrototype:result];
}
- (FileChunkError*) defaultInstance {
  return [FileChunkError defaultInstance];
}
- (FileChunkError*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChunkError*) buildPartial {
  FileChunkError* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChunkError_Builder*) mergeFrom:(FileChunkError*) other {
  if (other == [FileChunkError defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.mutableChunkErrorList.count > 0) {
    if (result.mutableChunkErrorList == nil) {
      result.mutableChunkErrorList = [NSMutableArray array];
    }
    [result.mutableChunkErrorList addObjectsFromArray:other.mutableChunkErrorList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChunkError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChunkError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        ChunkErrorIndex_Builder* subBuilder = [ChunkErrorIndex builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkError:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChunkError_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChunkError_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (NSArray*) chunkErrorList {
  if (result.mutableChunkErrorList == nil) { return [NSArray array]; }
  return result.mutableChunkErrorList;
}
- (ChunkErrorIndex*) chunkErrorAtIndex:(int32_t) index {
  return [result chunkErrorAtIndex:index];
}
- (FileChunkError_Builder*) replaceChunkErrorAtIndex:(int32_t) index with:(ChunkErrorIndex*) value {
  [result.mutableChunkErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChunkError_Builder*) addAllChunkError:(NSArray*) values {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObjectsFromArray:values];
  return self;
}
- (FileChunkError_Builder*) clearChunkErrorList {
  result.mutableChunkErrorList = nil;
  return self;
}
- (FileChunkError_Builder*) addChunkError:(ChunkErrorIndex*) value {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObject:value];
  return self;
}
@end

@interface StorageContainerError ()
@property (retain) NSString* storageContainerKey;
@property (retain) ErrorResponse* errorResponse;
@end

@implementation StorageContainerError

- (BOOL) hasStorageContainerKey {
  return !!hasStorageContainerKey_;
}
- (void) setHasStorageContainerKey:(BOOL) value {
  hasStorageContainerKey_ = !!value;
}
@synthesize storageContainerKey;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (void) dealloc {
  self.storageContainerKey = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.storageContainerKey = @"";
    self.errorResponse = [ErrorResponse defaultInstance];
  }
  return self;
}
static StorageContainerError* defaultStorageContainerErrorInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerError class]) {
    defaultStorageContainerErrorInstance = [[StorageContainerError alloc] init];
  }
}
+ (StorageContainerError*) defaultInstance {
  return defaultStorageContainerErrorInstance;
}
- (StorageContainerError*) defaultInstance {
  return defaultStorageContainerErrorInstance;
}
- (BOOL) isInitialized {
  if (!self.hasStorageContainerKey) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStorageContainerKey) {
    [output writeString:1 value:self.storageContainerKey];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStorageContainerKey) {
    size += computeStringSize(1, self.storageContainerKey);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerError*) parseFromData:(NSData*) data {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeFromData:data] build];
}
+ (StorageContainerError*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerError*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeFromInputStream:input] build];
}
+ (StorageContainerError*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeDelimitedFromInputStream:input] build];
}
+ (StorageContainerError*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerError*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerError*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerError*)[[[StorageContainerError builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerError_Builder*) builder {
  return [[[StorageContainerError_Builder alloc] init] autorelease];
}
+ (StorageContainerError_Builder*) builderWithPrototype:(StorageContainerError*) prototype {
  return [[StorageContainerError builder] mergeFrom:prototype];
}
- (StorageContainerError_Builder*) builder {
  return [StorageContainerError builder];
}
@end

@interface StorageContainerError_Builder()
@property (retain) StorageContainerError* result;
@end

@implementation StorageContainerError_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerError alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerError_Builder*) clear {
  self.result = [[[StorageContainerError alloc] init] autorelease];
  return self;
}
- (StorageContainerError_Builder*) clone {
  return [StorageContainerError builderWithPrototype:result];
}
- (StorageContainerError*) defaultInstance {
  return [StorageContainerError defaultInstance];
}
- (StorageContainerError*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerError*) buildPartial {
  StorageContainerError* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerError_Builder*) mergeFrom:(StorageContainerError*) other {
  if (other == [StorageContainerError defaultInstance]) {
    return self;
  }
  if (other.hasStorageContainerKey) {
    [self setStorageContainerKey:other.storageContainerKey];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerError_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setStorageContainerKey:[input readString]];
        break;
      }
      case 18: {
        ErrorResponse_Builder* subBuilder = [ErrorResponse builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasStorageContainerKey {
  return result.hasStorageContainerKey;
}
- (NSString*) storageContainerKey {
  return result.storageContainerKey;
}
- (StorageContainerError_Builder*) setStorageContainerKey:(NSString*) value {
  result.hasStorageContainerKey = YES;
  result.storageContainerKey = value;
  return self;
}
- (StorageContainerError_Builder*) clearStorageContainerKey {
  result.hasStorageContainerKey = NO;
  result.storageContainerKey = @"";
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponse*) errorResponse {
  return result.errorResponse;
}
- (StorageContainerError_Builder*) setErrorResponse:(ErrorResponse*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (StorageContainerError_Builder*) setErrorResponseBuilder:(ErrorResponse_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (StorageContainerError_Builder*) mergeErrorResponse:(ErrorResponse*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponse defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponse builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (StorageContainerError_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponse defaultInstance];
  return self;
}
@end

@interface MethodCompletionInfo ()
@property (retain) NSString* url;
@property int32_t responseStatusCode;
@property (retain) NSString* responseStatusLine;
@property (retain) NSMutableArray* mutableVendorResponseHeadersList;
@property (retain) NSData* responseBody;
@property (retain) ErrorResponse* error;
@property (retain) NSData* clientComputedMd5;
@property (retain) NSMutableArray* mutableVendorNvPairsList;
@property (retain) NSMutableArray* mutableClientNvPairsList;
@property (retain) NSString* storageContainerAuthorizationToken;
@end

@implementation MethodCompletionInfo

- (BOOL) hasUrl {
  return !!hasUrl_;
}
- (void) setHasUrl:(BOOL) value {
  hasUrl_ = !!value;
}
@synthesize url;
- (BOOL) hasResponseStatusCode {
  return !!hasResponseStatusCode_;
}
- (void) setHasResponseStatusCode:(BOOL) value {
  hasResponseStatusCode_ = !!value;
}
@synthesize responseStatusCode;
- (BOOL) hasResponseStatusLine {
  return !!hasResponseStatusLine_;
}
- (void) setHasResponseStatusLine:(BOOL) value {
  hasResponseStatusLine_ = !!value;
}
@synthesize responseStatusLine;
@synthesize mutableVendorResponseHeadersList;
- (BOOL) hasResponseBody {
  return !!hasResponseBody_;
}
- (void) setHasResponseBody:(BOOL) value {
  hasResponseBody_ = !!value;
}
@synthesize responseBody;
- (BOOL) hasError {
  return !!hasError_;
}
- (void) setHasError:(BOOL) value {
  hasError_ = !!value;
}
@synthesize error;
- (BOOL) hasClientComputedMd5 {
  return !!hasClientComputedMd5_;
}
- (void) setHasClientComputedMd5:(BOOL) value {
  hasClientComputedMd5_ = !!value;
}
@synthesize clientComputedMd5;
@synthesize mutableVendorNvPairsList;
@synthesize mutableClientNvPairsList;
- (BOOL) hasStorageContainerAuthorizationToken {
  return !!hasStorageContainerAuthorizationToken_;
}
- (void) setHasStorageContainerAuthorizationToken:(BOOL) value {
  hasStorageContainerAuthorizationToken_ = !!value;
}
@synthesize storageContainerAuthorizationToken;
- (void) dealloc {
  self.url = nil;
  self.responseStatusLine = nil;
  self.mutableVendorResponseHeadersList = nil;
  self.responseBody = nil;
  self.error = nil;
  self.clientComputedMd5 = nil;
  self.mutableVendorNvPairsList = nil;
  self.mutableClientNvPairsList = nil;
  self.storageContainerAuthorizationToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.url = @"";
    self.responseStatusCode = 0;
    self.responseStatusLine = @"";
    self.responseBody = [NSData data];
    self.error = [ErrorResponse defaultInstance];
    self.clientComputedMd5 = [NSData data];
    self.storageContainerAuthorizationToken = @"";
  }
  return self;
}
static MethodCompletionInfo* defaultMethodCompletionInfoInstance = nil;
+ (void) initialize {
  if (self == [MethodCompletionInfo class]) {
    defaultMethodCompletionInfoInstance = [[MethodCompletionInfo alloc] init];
  }
}
+ (MethodCompletionInfo*) defaultInstance {
  return defaultMethodCompletionInfoInstance;
}
- (MethodCompletionInfo*) defaultInstance {
  return defaultMethodCompletionInfoInstance;
}
- (NSArray*) vendorResponseHeadersList {
  return mutableVendorResponseHeadersList;
}
- (NameValuePair*) vendorResponseHeadersAtIndex:(int32_t) index {
  id value = [mutableVendorResponseHeadersList objectAtIndex:index];
  return value;
}
- (NSArray*) vendorNvPairsList {
  return mutableVendorNvPairsList;
}
- (NameValuePair*) vendorNvPairsAtIndex:(int32_t) index {
  id value = [mutableVendorNvPairsList objectAtIndex:index];
  return value;
}
- (NSArray*) clientNvPairsList {
  return mutableClientNvPairsList;
}
- (NameValuePair*) clientNvPairsAtIndex:(int32_t) index {
  id value = [mutableClientNvPairsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasUrl) {
    return NO;
  }
  if (!self.hasResponseStatusCode) {
    return NO;
  }
  if (!self.hasStorageContainerAuthorizationToken) {
    return NO;
  }
  for (NameValuePair* element in self.vendorResponseHeadersList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  if (self.hasError) {
    if (!self.error.isInitialized) {
      return NO;
    }
  }
  for (NameValuePair* element in self.vendorNvPairsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (NameValuePair* element in self.clientNvPairsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasUrl) {
    [output writeString:1 value:self.url];
  }
  if (self.hasResponseStatusCode) {
    [output writeUInt32:2 value:self.responseStatusCode];
  }
  if (self.hasResponseStatusLine) {
    [output writeString:3 value:self.responseStatusLine];
  }
  for (NameValuePair* element in self.vendorResponseHeadersList) {
    [output writeMessage:4 value:element];
  }
  if (self.hasResponseBody) {
    [output writeData:5 value:self.responseBody];
  }
  if (self.hasError) {
    [output writeMessage:6 value:self.error];
  }
  if (self.hasClientComputedMd5) {
    [output writeData:7 value:self.clientComputedMd5];
  }
  for (NameValuePair* element in self.vendorNvPairsList) {
    [output writeMessage:8 value:element];
  }
  for (NameValuePair* element in self.clientNvPairsList) {
    [output writeMessage:9 value:element];
  }
  if (self.hasStorageContainerAuthorizationToken) {
    [output writeString:10 value:self.storageContainerAuthorizationToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasUrl) {
    size += computeStringSize(1, self.url);
  }
  if (self.hasResponseStatusCode) {
    size += computeUInt32Size(2, self.responseStatusCode);
  }
  if (self.hasResponseStatusLine) {
    size += computeStringSize(3, self.responseStatusLine);
  }
  for (NameValuePair* element in self.vendorResponseHeadersList) {
    size += computeMessageSize(4, element);
  }
  if (self.hasResponseBody) {
    size += computeDataSize(5, self.responseBody);
  }
  if (self.hasError) {
    size += computeMessageSize(6, self.error);
  }
  if (self.hasClientComputedMd5) {
    size += computeDataSize(7, self.clientComputedMd5);
  }
  for (NameValuePair* element in self.vendorNvPairsList) {
    size += computeMessageSize(8, element);
  }
  for (NameValuePair* element in self.clientNvPairsList) {
    size += computeMessageSize(9, element);
  }
  if (self.hasStorageContainerAuthorizationToken) {
    size += computeStringSize(10, self.storageContainerAuthorizationToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (MethodCompletionInfo*) parseFromData:(NSData*) data {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeFromData:data] build];
}
+ (MethodCompletionInfo*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfo*) parseFromInputStream:(NSInputStream*) input {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeFromInputStream:input] build];
}
+ (MethodCompletionInfo*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeDelimitedFromInputStream:input] build];
}
+ (MethodCompletionInfo*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeFromCodedInputStream:input] build];
}
+ (MethodCompletionInfo*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfo*)[[[MethodCompletionInfo builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfo_Builder*) builder {
  return [[[MethodCompletionInfo_Builder alloc] init] autorelease];
}
+ (MethodCompletionInfo_Builder*) builderWithPrototype:(MethodCompletionInfo*) prototype {
  return [[MethodCompletionInfo builder] mergeFrom:prototype];
}
- (MethodCompletionInfo_Builder*) builder {
  return [MethodCompletionInfo builder];
}
@end

@interface MethodCompletionInfo_Builder()
@property (retain) MethodCompletionInfo* result;
@end

@implementation MethodCompletionInfo_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[MethodCompletionInfo alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (MethodCompletionInfo_Builder*) clear {
  self.result = [[[MethodCompletionInfo alloc] init] autorelease];
  return self;
}
- (MethodCompletionInfo_Builder*) clone {
  return [MethodCompletionInfo builderWithPrototype:result];
}
- (MethodCompletionInfo*) defaultInstance {
  return [MethodCompletionInfo defaultInstance];
}
- (MethodCompletionInfo*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (MethodCompletionInfo*) buildPartial {
  MethodCompletionInfo* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (MethodCompletionInfo_Builder*) mergeFrom:(MethodCompletionInfo*) other {
  if (other == [MethodCompletionInfo defaultInstance]) {
    return self;
  }
  if (other.hasUrl) {
    [self setUrl:other.url];
  }
  if (other.hasResponseStatusCode) {
    [self setResponseStatusCode:other.responseStatusCode];
  }
  if (other.hasResponseStatusLine) {
    [self setResponseStatusLine:other.responseStatusLine];
  }
  if (other.mutableVendorResponseHeadersList.count > 0) {
    if (result.mutableVendorResponseHeadersList == nil) {
      result.mutableVendorResponseHeadersList = [NSMutableArray array];
    }
    [result.mutableVendorResponseHeadersList addObjectsFromArray:other.mutableVendorResponseHeadersList];
  }
  if (other.hasResponseBody) {
    [self setResponseBody:other.responseBody];
  }
  if (other.hasError) {
    [self mergeError:other.error];
  }
  if (other.hasClientComputedMd5) {
    [self setClientComputedMd5:other.clientComputedMd5];
  }
  if (other.mutableVendorNvPairsList.count > 0) {
    if (result.mutableVendorNvPairsList == nil) {
      result.mutableVendorNvPairsList = [NSMutableArray array];
    }
    [result.mutableVendorNvPairsList addObjectsFromArray:other.mutableVendorNvPairsList];
  }
  if (other.mutableClientNvPairsList.count > 0) {
    if (result.mutableClientNvPairsList == nil) {
      result.mutableClientNvPairsList = [NSMutableArray array];
    }
    [result.mutableClientNvPairsList addObjectsFromArray:other.mutableClientNvPairsList];
  }
  if (other.hasStorageContainerAuthorizationToken) {
    [self setStorageContainerAuthorizationToken:other.storageContainerAuthorizationToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (MethodCompletionInfo_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (MethodCompletionInfo_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setUrl:[input readString]];
        break;
      }
      case 16: {
        [self setResponseStatusCode:[input readUInt32]];
        break;
      }
      case 26: {
        [self setResponseStatusLine:[input readString]];
        break;
      }
      case 34: {
        NameValuePair_Builder* subBuilder = [NameValuePair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addVendorResponseHeaders:[subBuilder buildPartial]];
        break;
      }
      case 42: {
        [self setResponseBody:[input readData]];
        break;
      }
      case 50: {
        ErrorResponse_Builder* subBuilder = [ErrorResponse builder];
        if (self.hasError) {
          [subBuilder mergeFrom:self.error];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setError:[subBuilder buildPartial]];
        break;
      }
      case 58: {
        [self setClientComputedMd5:[input readData]];
        break;
      }
      case 66: {
        NameValuePair_Builder* subBuilder = [NameValuePair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addVendorNvPairs:[subBuilder buildPartial]];
        break;
      }
      case 74: {
        NameValuePair_Builder* subBuilder = [NameValuePair builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addClientNvPairs:[subBuilder buildPartial]];
        break;
      }
      case 82: {
        [self setStorageContainerAuthorizationToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasUrl {
  return result.hasUrl;
}
- (NSString*) url {
  return result.url;
}
- (MethodCompletionInfo_Builder*) setUrl:(NSString*) value {
  result.hasUrl = YES;
  result.url = value;
  return self;
}
- (MethodCompletionInfo_Builder*) clearUrl {
  result.hasUrl = NO;
  result.url = @"";
  return self;
}
- (BOOL) hasResponseStatusCode {
  return result.hasResponseStatusCode;
}
- (int32_t) responseStatusCode {
  return result.responseStatusCode;
}
- (MethodCompletionInfo_Builder*) setResponseStatusCode:(int32_t) value {
  result.hasResponseStatusCode = YES;
  result.responseStatusCode = value;
  return self;
}
- (MethodCompletionInfo_Builder*) clearResponseStatusCode {
  result.hasResponseStatusCode = NO;
  result.responseStatusCode = 0;
  return self;
}
- (BOOL) hasResponseStatusLine {
  return result.hasResponseStatusLine;
}
- (NSString*) responseStatusLine {
  return result.responseStatusLine;
}
- (MethodCompletionInfo_Builder*) setResponseStatusLine:(NSString*) value {
  result.hasResponseStatusLine = YES;
  result.responseStatusLine = value;
  return self;
}
- (MethodCompletionInfo_Builder*) clearResponseStatusLine {
  result.hasResponseStatusLine = NO;
  result.responseStatusLine = @"";
  return self;
}
- (NSArray*) vendorResponseHeadersList {
  if (result.mutableVendorResponseHeadersList == nil) { return [NSArray array]; }
  return result.mutableVendorResponseHeadersList;
}
- (NameValuePair*) vendorResponseHeadersAtIndex:(int32_t) index {
  return [result vendorResponseHeadersAtIndex:index];
}
- (MethodCompletionInfo_Builder*) replaceVendorResponseHeadersAtIndex:(int32_t) index with:(NameValuePair*) value {
  [result.mutableVendorResponseHeadersList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfo_Builder*) addAllVendorResponseHeaders:(NSArray*) values {
  if (result.mutableVendorResponseHeadersList == nil) {
    result.mutableVendorResponseHeadersList = [NSMutableArray array];
  }
  [result.mutableVendorResponseHeadersList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfo_Builder*) clearVendorResponseHeadersList {
  result.mutableVendorResponseHeadersList = nil;
  return self;
}
- (MethodCompletionInfo_Builder*) addVendorResponseHeaders:(NameValuePair*) value {
  if (result.mutableVendorResponseHeadersList == nil) {
    result.mutableVendorResponseHeadersList = [NSMutableArray array];
  }
  [result.mutableVendorResponseHeadersList addObject:value];
  return self;
}
- (BOOL) hasResponseBody {
  return result.hasResponseBody;
}
- (NSData*) responseBody {
  return result.responseBody;
}
- (MethodCompletionInfo_Builder*) setResponseBody:(NSData*) value {
  result.hasResponseBody = YES;
  result.responseBody = value;
  return self;
}
- (MethodCompletionInfo_Builder*) clearResponseBody {
  result.hasResponseBody = NO;
  result.responseBody = [NSData data];
  return self;
}
- (BOOL) hasError {
  return result.hasError;
}
- (ErrorResponse*) error {
  return result.error;
}
- (MethodCompletionInfo_Builder*) setError:(ErrorResponse*) value {
  result.hasError = YES;
  result.error = value;
  return self;
}
- (MethodCompletionInfo_Builder*) setErrorBuilder:(ErrorResponse_Builder*) builderForValue {
  return [self setError:[builderForValue build]];
}
- (MethodCompletionInfo_Builder*) mergeError:(ErrorResponse*) value {
  if (result.hasError &&
      result.error != [ErrorResponse defaultInstance]) {
    result.error =
      [[[ErrorResponse builderWithPrototype:result.error] mergeFrom:value] buildPartial];
  } else {
    result.error = value;
  }
  result.hasError = YES;
  return self;
}
- (MethodCompletionInfo_Builder*) clearError {
  result.hasError = NO;
  result.error = [ErrorResponse defaultInstance];
  return self;
}
- (BOOL) hasClientComputedMd5 {
  return result.hasClientComputedMd5;
}
- (NSData*) clientComputedMd5 {
  return result.clientComputedMd5;
}
- (MethodCompletionInfo_Builder*) setClientComputedMd5:(NSData*) value {
  result.hasClientComputedMd5 = YES;
  result.clientComputedMd5 = value;
  return self;
}
- (MethodCompletionInfo_Builder*) clearClientComputedMd5 {
  result.hasClientComputedMd5 = NO;
  result.clientComputedMd5 = [NSData data];
  return self;
}
- (NSArray*) vendorNvPairsList {
  if (result.mutableVendorNvPairsList == nil) { return [NSArray array]; }
  return result.mutableVendorNvPairsList;
}
- (NameValuePair*) vendorNvPairsAtIndex:(int32_t) index {
  return [result vendorNvPairsAtIndex:index];
}
- (MethodCompletionInfo_Builder*) replaceVendorNvPairsAtIndex:(int32_t) index with:(NameValuePair*) value {
  [result.mutableVendorNvPairsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfo_Builder*) addAllVendorNvPairs:(NSArray*) values {
  if (result.mutableVendorNvPairsList == nil) {
    result.mutableVendorNvPairsList = [NSMutableArray array];
  }
  [result.mutableVendorNvPairsList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfo_Builder*) clearVendorNvPairsList {
  result.mutableVendorNvPairsList = nil;
  return self;
}
- (MethodCompletionInfo_Builder*) addVendorNvPairs:(NameValuePair*) value {
  if (result.mutableVendorNvPairsList == nil) {
    result.mutableVendorNvPairsList = [NSMutableArray array];
  }
  [result.mutableVendorNvPairsList addObject:value];
  return self;
}
- (NSArray*) clientNvPairsList {
  if (result.mutableClientNvPairsList == nil) { return [NSArray array]; }
  return result.mutableClientNvPairsList;
}
- (NameValuePair*) clientNvPairsAtIndex:(int32_t) index {
  return [result clientNvPairsAtIndex:index];
}
- (MethodCompletionInfo_Builder*) replaceClientNvPairsAtIndex:(int32_t) index with:(NameValuePair*) value {
  [result.mutableClientNvPairsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfo_Builder*) addAllClientNvPairs:(NSArray*) values {
  if (result.mutableClientNvPairsList == nil) {
    result.mutableClientNvPairsList = [NSMutableArray array];
  }
  [result.mutableClientNvPairsList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfo_Builder*) clearClientNvPairsList {
  result.mutableClientNvPairsList = nil;
  return self;
}
- (MethodCompletionInfo_Builder*) addClientNvPairs:(NameValuePair*) value {
  if (result.mutableClientNvPairsList == nil) {
    result.mutableClientNvPairsList = [NSMutableArray array];
  }
  [result.mutableClientNvPairsList addObject:value];
  return self;
}
- (BOOL) hasStorageContainerAuthorizationToken {
  return result.hasStorageContainerAuthorizationToken;
}
- (NSString*) storageContainerAuthorizationToken {
  return result.storageContainerAuthorizationToken;
}
- (MethodCompletionInfo_Builder*) setStorageContainerAuthorizationToken:(NSString*) value {
  result.hasStorageContainerAuthorizationToken = YES;
  result.storageContainerAuthorizationToken = value;
  return self;
}
- (MethodCompletionInfo_Builder*) clearStorageContainerAuthorizationToken {
  result.hasStorageContainerAuthorizationToken = NO;
  result.storageContainerAuthorizationToken = @"";
  return self;
}
@end

@interface MethodCompletionInfoList ()
@property (retain) NSMutableArray* mutableMethodCompletionInfoList;
@end

@implementation MethodCompletionInfoList

@synthesize mutableMethodCompletionInfoList;
- (void) dealloc {
  self.mutableMethodCompletionInfoList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static MethodCompletionInfoList* defaultMethodCompletionInfoListInstance = nil;
+ (void) initialize {
  if (self == [MethodCompletionInfoList class]) {
    defaultMethodCompletionInfoListInstance = [[MethodCompletionInfoList alloc] init];
  }
}
+ (MethodCompletionInfoList*) defaultInstance {
  return defaultMethodCompletionInfoListInstance;
}
- (MethodCompletionInfoList*) defaultInstance {
  return defaultMethodCompletionInfoListInstance;
}
- (NSArray*) methodCompletionInfoList {
  return mutableMethodCompletionInfoList;
}
- (MethodCompletionInfo*) methodCompletionInfoAtIndex:(int32_t) index {
  id value = [mutableMethodCompletionInfoList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (MethodCompletionInfo* element in self.methodCompletionInfoList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (MethodCompletionInfo* element in self.methodCompletionInfoList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (MethodCompletionInfo* element in self.methodCompletionInfoList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (MethodCompletionInfoList*) parseFromData:(NSData*) data {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeFromData:data] build];
}
+ (MethodCompletionInfoList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoList*) parseFromInputStream:(NSInputStream*) input {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeFromInputStream:input] build];
}
+ (MethodCompletionInfoList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeDelimitedFromInputStream:input] build];
}
+ (MethodCompletionInfoList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeFromCodedInputStream:input] build];
}
+ (MethodCompletionInfoList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoList*)[[[MethodCompletionInfoList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoList_Builder*) builder {
  return [[[MethodCompletionInfoList_Builder alloc] init] autorelease];
}
+ (MethodCompletionInfoList_Builder*) builderWithPrototype:(MethodCompletionInfoList*) prototype {
  return [[MethodCompletionInfoList builder] mergeFrom:prototype];
}
- (MethodCompletionInfoList_Builder*) builder {
  return [MethodCompletionInfoList builder];
}
@end

@interface MethodCompletionInfoList_Builder()
@property (retain) MethodCompletionInfoList* result;
@end

@implementation MethodCompletionInfoList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[MethodCompletionInfoList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (MethodCompletionInfoList_Builder*) clear {
  self.result = [[[MethodCompletionInfoList alloc] init] autorelease];
  return self;
}
- (MethodCompletionInfoList_Builder*) clone {
  return [MethodCompletionInfoList builderWithPrototype:result];
}
- (MethodCompletionInfoList*) defaultInstance {
  return [MethodCompletionInfoList defaultInstance];
}
- (MethodCompletionInfoList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (MethodCompletionInfoList*) buildPartial {
  MethodCompletionInfoList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (MethodCompletionInfoList_Builder*) mergeFrom:(MethodCompletionInfoList*) other {
  if (other == [MethodCompletionInfoList defaultInstance]) {
    return self;
  }
  if (other.mutableMethodCompletionInfoList.count > 0) {
    if (result.mutableMethodCompletionInfoList == nil) {
      result.mutableMethodCompletionInfoList = [NSMutableArray array];
    }
    [result.mutableMethodCompletionInfoList addObjectsFromArray:other.mutableMethodCompletionInfoList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (MethodCompletionInfoList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (MethodCompletionInfoList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        MethodCompletionInfo_Builder* subBuilder = [MethodCompletionInfo builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addMethodCompletionInfo:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) methodCompletionInfoList {
  if (result.mutableMethodCompletionInfoList == nil) { return [NSArray array]; }
  return result.mutableMethodCompletionInfoList;
}
- (MethodCompletionInfo*) methodCompletionInfoAtIndex:(int32_t) index {
  return [result methodCompletionInfoAtIndex:index];
}
- (MethodCompletionInfoList_Builder*) replaceMethodCompletionInfoAtIndex:(int32_t) index with:(MethodCompletionInfo*) value {
  [result.mutableMethodCompletionInfoList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfoList_Builder*) addAllMethodCompletionInfo:(NSArray*) values {
  if (result.mutableMethodCompletionInfoList == nil) {
    result.mutableMethodCompletionInfoList = [NSMutableArray array];
  }
  [result.mutableMethodCompletionInfoList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfoList_Builder*) clearMethodCompletionInfoList {
  result.mutableMethodCompletionInfoList = nil;
  return self;
}
- (MethodCompletionInfoList_Builder*) addMethodCompletionInfo:(MethodCompletionInfo*) value {
  if (result.mutableMethodCompletionInfoList == nil) {
    result.mutableMethodCompletionInfoList = [NSMutableArray array];
  }
  [result.mutableMethodCompletionInfoList addObject:value];
  return self;
}
@end

@interface FileChunkList ()
@property (retain) NSData* fileChecksum;
@property (retain) NSString* authorization;
@property (retain) NSMutableArray* mutableChunkInfoList;
@end

@implementation FileChunkList

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
- (BOOL) hasAuthorization {
  return !!hasAuthorization_;
}
- (void) setHasAuthorization:(BOOL) value {
  hasAuthorization_ = !!value;
}
@synthesize authorization;
@synthesize mutableChunkInfoList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.authorization = nil;
  self.mutableChunkInfoList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.authorization = @"";
  }
  return self;
}
static FileChunkList* defaultFileChunkListInstance = nil;
+ (void) initialize {
  if (self == [FileChunkList class]) {
    defaultFileChunkListInstance = [[FileChunkList alloc] init];
  }
}
+ (FileChunkList*) defaultInstance {
  return defaultFileChunkListInstance;
}
- (FileChunkList*) defaultInstance {
  return defaultFileChunkListInstance;
}
- (NSArray*) chunkInfoList {
  return mutableChunkInfoList;
}
- (ChunkInfo*) chunkInfoAtIndex:(int32_t) index {
  id value = [mutableChunkInfoList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  if (!self.hasAuthorization) {
    return NO;
  }
  for (ChunkInfo* element in self.chunkInfoList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  if (self.hasAuthorization) {
    [output writeString:2 value:self.authorization];
  }
  for (ChunkInfo* element in self.chunkInfoList) {
    [output writeMessage:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  if (self.hasAuthorization) {
    size += computeStringSize(2, self.authorization);
  }
  for (ChunkInfo* element in self.chunkInfoList) {
    size += computeMessageSize(3, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChunkList*) parseFromData:(NSData*) data {
  return (FileChunkList*)[[[FileChunkList builder] mergeFromData:data] build];
}
+ (FileChunkList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkList*)[[[FileChunkList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChunkList*) parseFromInputStream:(NSInputStream*) input {
  return (FileChunkList*)[[[FileChunkList builder] mergeFromInputStream:input] build];
}
+ (FileChunkList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChunkList*)[[[FileChunkList builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChunkList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkList*)[[[FileChunkList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChunkList*)[[[FileChunkList builder] mergeFromCodedInputStream:input] build];
}
+ (FileChunkList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkList*)[[[FileChunkList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkList_Builder*) builder {
  return [[[FileChunkList_Builder alloc] init] autorelease];
}
+ (FileChunkList_Builder*) builderWithPrototype:(FileChunkList*) prototype {
  return [[FileChunkList builder] mergeFrom:prototype];
}
- (FileChunkList_Builder*) builder {
  return [FileChunkList builder];
}
@end

@interface FileChunkList_Builder()
@property (retain) FileChunkList* result;
@end

@implementation FileChunkList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChunkList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChunkList_Builder*) clear {
  self.result = [[[FileChunkList alloc] init] autorelease];
  return self;
}
- (FileChunkList_Builder*) clone {
  return [FileChunkList builderWithPrototype:result];
}
- (FileChunkList*) defaultInstance {
  return [FileChunkList defaultInstance];
}
- (FileChunkList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChunkList*) buildPartial {
  FileChunkList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChunkList_Builder*) mergeFrom:(FileChunkList*) other {
  if (other == [FileChunkList defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.hasAuthorization) {
    [self setAuthorization:other.authorization];
  }
  if (other.mutableChunkInfoList.count > 0) {
    if (result.mutableChunkInfoList == nil) {
      result.mutableChunkInfoList = [NSMutableArray array];
    }
    [result.mutableChunkInfoList addObjectsFromArray:other.mutableChunkInfoList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChunkList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChunkList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setAuthorization:[input readString]];
        break;
      }
      case 26: {
        ChunkInfo_Builder* subBuilder = [ChunkInfo builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkInfo:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChunkList_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChunkList_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (BOOL) hasAuthorization {
  return result.hasAuthorization;
}
- (NSString*) authorization {
  return result.authorization;
}
- (FileChunkList_Builder*) setAuthorization:(NSString*) value {
  result.hasAuthorization = YES;
  result.authorization = value;
  return self;
}
- (FileChunkList_Builder*) clearAuthorization {
  result.hasAuthorization = NO;
  result.authorization = @"";
  return self;
}
- (NSArray*) chunkInfoList {
  if (result.mutableChunkInfoList == nil) { return [NSArray array]; }
  return result.mutableChunkInfoList;
}
- (ChunkInfo*) chunkInfoAtIndex:(int32_t) index {
  return [result chunkInfoAtIndex:index];
}
- (FileChunkList_Builder*) replaceChunkInfoAtIndex:(int32_t) index with:(ChunkInfo*) value {
  [result.mutableChunkInfoList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChunkList_Builder*) addAllChunkInfo:(NSArray*) values {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObjectsFromArray:values];
  return self;
}
- (FileChunkList_Builder*) clearChunkInfoList {
  result.mutableChunkInfoList = nil;
  return self;
}
- (FileChunkList_Builder*) addChunkInfo:(ChunkInfo*) value {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObject:value];
  return self;
}
@end

@interface FileChunkLists ()
@property (retain) NSMutableArray* mutableFileChunkListList;
@end

@implementation FileChunkLists

@synthesize mutableFileChunkListList;
- (void) dealloc {
  self.mutableFileChunkListList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileChunkLists* defaultFileChunkListsInstance = nil;
+ (void) initialize {
  if (self == [FileChunkLists class]) {
    defaultFileChunkListsInstance = [[FileChunkLists alloc] init];
  }
}
+ (FileChunkLists*) defaultInstance {
  return defaultFileChunkListsInstance;
}
- (FileChunkLists*) defaultInstance {
  return defaultFileChunkListsInstance;
}
- (NSArray*) fileChunkListList {
  return mutableFileChunkListList;
}
- (FileChunkList*) fileChunkListAtIndex:(int32_t) index {
  id value = [mutableFileChunkListList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (FileChunkList* element in self.fileChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (FileChunkList* element in self.fileChunkListList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (FileChunkList* element in self.fileChunkListList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChunkLists*) parseFromData:(NSData*) data {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeFromData:data] build];
}
+ (FileChunkLists*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChunkLists*) parseFromInputStream:(NSInputStream*) input {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeFromInputStream:input] build];
}
+ (FileChunkLists*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChunkLists*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeFromCodedInputStream:input] build];
}
+ (FileChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkLists*)[[[FileChunkLists builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkLists_Builder*) builder {
  return [[[FileChunkLists_Builder alloc] init] autorelease];
}
+ (FileChunkLists_Builder*) builderWithPrototype:(FileChunkLists*) prototype {
  return [[FileChunkLists builder] mergeFrom:prototype];
}
- (FileChunkLists_Builder*) builder {
  return [FileChunkLists builder];
}
@end

@interface FileChunkLists_Builder()
@property (retain) FileChunkLists* result;
@end

@implementation FileChunkLists_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChunkLists alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChunkLists_Builder*) clear {
  self.result = [[[FileChunkLists alloc] init] autorelease];
  return self;
}
- (FileChunkLists_Builder*) clone {
  return [FileChunkLists builderWithPrototype:result];
}
- (FileChunkLists*) defaultInstance {
  return [FileChunkLists defaultInstance];
}
- (FileChunkLists*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChunkLists*) buildPartial {
  FileChunkLists* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChunkLists_Builder*) mergeFrom:(FileChunkLists*) other {
  if (other == [FileChunkLists defaultInstance]) {
    return self;
  }
  if (other.mutableFileChunkListList.count > 0) {
    if (result.mutableFileChunkListList == nil) {
      result.mutableFileChunkListList = [NSMutableArray array];
    }
    [result.mutableFileChunkListList addObjectsFromArray:other.mutableFileChunkListList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        FileChunkList_Builder* subBuilder = [FileChunkList builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChunkList:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) fileChunkListList {
  if (result.mutableFileChunkListList == nil) { return [NSArray array]; }
  return result.mutableFileChunkListList;
}
- (FileChunkList*) fileChunkListAtIndex:(int32_t) index {
  return [result fileChunkListAtIndex:index];
}
- (FileChunkLists_Builder*) replaceFileChunkListAtIndex:(int32_t) index with:(FileChunkList*) value {
  [result.mutableFileChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChunkLists_Builder*) addAllFileChunkList:(NSArray*) values {
  if (result.mutableFileChunkListList == nil) {
    result.mutableFileChunkListList = [NSMutableArray array];
  }
  [result.mutableFileChunkListList addObjectsFromArray:values];
  return self;
}
- (FileChunkLists_Builder*) clearFileChunkListList {
  result.mutableFileChunkListList = nil;
  return self;
}
- (FileChunkLists_Builder*) addFileChunkList:(FileChunkList*) value {
  if (result.mutableFileChunkListList == nil) {
    result.mutableFileChunkListList = [NSMutableArray array];
  }
  [result.mutableFileChunkListList addObject:value];
  return self;
}
@end

@interface StorageContainerChunkList ()
@property (retain) NSData* storageContainerKey;
@property (retain) HostInfo* hostInfo;
@property (retain) NSMutableArray* mutableChunkChecksumList;
@property (retain) NSString* storageContainerAuthorizationToken;
@end

@implementation StorageContainerChunkList

- (BOOL) hasStorageContainerKey {
  return !!hasStorageContainerKey_;
}
- (void) setHasStorageContainerKey:(BOOL) value {
  hasStorageContainerKey_ = !!value;
}
@synthesize storageContainerKey;
- (BOOL) hasHostInfo {
  return !!hasHostInfo_;
}
- (void) setHasHostInfo:(BOOL) value {
  hasHostInfo_ = !!value;
}
@synthesize hostInfo;
@synthesize mutableChunkChecksumList;
- (BOOL) hasStorageContainerAuthorizationToken {
  return !!hasStorageContainerAuthorizationToken_;
}
- (void) setHasStorageContainerAuthorizationToken:(BOOL) value {
  hasStorageContainerAuthorizationToken_ = !!value;
}
@synthesize storageContainerAuthorizationToken;
- (void) dealloc {
  self.storageContainerKey = nil;
  self.hostInfo = nil;
  self.mutableChunkChecksumList = nil;
  self.storageContainerAuthorizationToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.storageContainerKey = [NSData data];
    self.hostInfo = [HostInfo defaultInstance];
    self.storageContainerAuthorizationToken = @"";
  }
  return self;
}
static StorageContainerChunkList* defaultStorageContainerChunkListInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerChunkList class]) {
    defaultStorageContainerChunkListInstance = [[StorageContainerChunkList alloc] init];
  }
}
+ (StorageContainerChunkList*) defaultInstance {
  return defaultStorageContainerChunkListInstance;
}
- (StorageContainerChunkList*) defaultInstance {
  return defaultStorageContainerChunkListInstance;
}
- (NSArray*) chunkChecksumList {
  return mutableChunkChecksumList;
}
- (NSData*) chunkChecksumAtIndex:(int32_t) index {
  id value = [mutableChunkChecksumList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasStorageContainerKey) {
    return NO;
  }
  if (!self.hasHostInfo) {
    return NO;
  }
  if (!self.hasStorageContainerAuthorizationToken) {
    return NO;
  }
  if (!self.hostInfo.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStorageContainerKey) {
    [output writeData:1 value:self.storageContainerKey];
  }
  if (self.hasHostInfo) {
    [output writeMessage:2 value:self.hostInfo];
  }
  for (NSData* element in self.mutableChunkChecksumList) {
    [output writeData:3 value:element];
  }
  if (self.hasStorageContainerAuthorizationToken) {
    [output writeString:4 value:self.storageContainerAuthorizationToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStorageContainerKey) {
    size += computeDataSize(1, self.storageContainerKey);
  }
  if (self.hasHostInfo) {
    size += computeMessageSize(2, self.hostInfo);
  }
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableChunkChecksumList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableChunkChecksumList.count;
  }
  if (self.hasStorageContainerAuthorizationToken) {
    size += computeStringSize(4, self.storageContainerAuthorizationToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerChunkList*) parseFromData:(NSData*) data {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeFromData:data] build];
}
+ (StorageContainerChunkList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkList*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeFromInputStream:input] build];
}
+ (StorageContainerChunkList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeDelimitedFromInputStream:input] build];
}
+ (StorageContainerChunkList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerChunkList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkList*)[[[StorageContainerChunkList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkList_Builder*) builder {
  return [[[StorageContainerChunkList_Builder alloc] init] autorelease];
}
+ (StorageContainerChunkList_Builder*) builderWithPrototype:(StorageContainerChunkList*) prototype {
  return [[StorageContainerChunkList builder] mergeFrom:prototype];
}
- (StorageContainerChunkList_Builder*) builder {
  return [StorageContainerChunkList builder];
}
@end

@interface StorageContainerChunkList_Builder()
@property (retain) StorageContainerChunkList* result;
@end

@implementation StorageContainerChunkList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerChunkList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerChunkList_Builder*) clear {
  self.result = [[[StorageContainerChunkList alloc] init] autorelease];
  return self;
}
- (StorageContainerChunkList_Builder*) clone {
  return [StorageContainerChunkList builderWithPrototype:result];
}
- (StorageContainerChunkList*) defaultInstance {
  return [StorageContainerChunkList defaultInstance];
}
- (StorageContainerChunkList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerChunkList*) buildPartial {
  StorageContainerChunkList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerChunkList_Builder*) mergeFrom:(StorageContainerChunkList*) other {
  if (other == [StorageContainerChunkList defaultInstance]) {
    return self;
  }
  if (other.hasStorageContainerKey) {
    [self setStorageContainerKey:other.storageContainerKey];
  }
  if (other.hasHostInfo) {
    [self mergeHostInfo:other.hostInfo];
  }
  if (other.mutableChunkChecksumList.count > 0) {
    if (result.mutableChunkChecksumList == nil) {
      result.mutableChunkChecksumList = [NSMutableArray array];
    }
    [result.mutableChunkChecksumList addObjectsFromArray:other.mutableChunkChecksumList];
  }
  if (other.hasStorageContainerAuthorizationToken) {
    [self setStorageContainerAuthorizationToken:other.storageContainerAuthorizationToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerChunkList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerChunkList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setStorageContainerKey:[input readData]];
        break;
      }
      case 18: {
        HostInfo_Builder* subBuilder = [HostInfo builder];
        if (self.hasHostInfo) {
          [subBuilder mergeFrom:self.hostInfo];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setHostInfo:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        [self addChunkChecksum:[input readData]];
        break;
      }
      case 34: {
        [self setStorageContainerAuthorizationToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasStorageContainerKey {
  return result.hasStorageContainerKey;
}
- (NSData*) storageContainerKey {
  return result.storageContainerKey;
}
- (StorageContainerChunkList_Builder*) setStorageContainerKey:(NSData*) value {
  result.hasStorageContainerKey = YES;
  result.storageContainerKey = value;
  return self;
}
- (StorageContainerChunkList_Builder*) clearStorageContainerKey {
  result.hasStorageContainerKey = NO;
  result.storageContainerKey = [NSData data];
  return self;
}
- (BOOL) hasHostInfo {
  return result.hasHostInfo;
}
- (HostInfo*) hostInfo {
  return result.hostInfo;
}
- (StorageContainerChunkList_Builder*) setHostInfo:(HostInfo*) value {
  result.hasHostInfo = YES;
  result.hostInfo = value;
  return self;
}
- (StorageContainerChunkList_Builder*) setHostInfoBuilder:(HostInfo_Builder*) builderForValue {
  return [self setHostInfo:[builderForValue build]];
}
- (StorageContainerChunkList_Builder*) mergeHostInfo:(HostInfo*) value {
  if (result.hasHostInfo &&
      result.hostInfo != [HostInfo defaultInstance]) {
    result.hostInfo =
      [[[HostInfo builderWithPrototype:result.hostInfo] mergeFrom:value] buildPartial];
  } else {
    result.hostInfo = value;
  }
  result.hasHostInfo = YES;
  return self;
}
- (StorageContainerChunkList_Builder*) clearHostInfo {
  result.hasHostInfo = NO;
  result.hostInfo = [HostInfo defaultInstance];
  return self;
}
- (NSArray*) chunkChecksumList {
  if (result.mutableChunkChecksumList == nil) {
    return [NSArray array];
  }
  return result.mutableChunkChecksumList;
}
- (NSData*) chunkChecksumAtIndex:(int32_t) index {
  return [result chunkChecksumAtIndex:index];
}
- (StorageContainerChunkList_Builder*) replaceChunkChecksumAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableChunkChecksumList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerChunkList_Builder*) addChunkChecksum:(NSData*) value {
  if (result.mutableChunkChecksumList == nil) {
    result.mutableChunkChecksumList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumList addObject:value];
  return self;
}
- (StorageContainerChunkList_Builder*) addAllChunkChecksum:(NSArray*) values {
  if (result.mutableChunkChecksumList == nil) {
    result.mutableChunkChecksumList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumList addObjectsFromArray:values];
  return self;
}
- (StorageContainerChunkList_Builder*) clearChunkChecksumList {
  result.mutableChunkChecksumList = nil;
  return self;
}
- (BOOL) hasStorageContainerAuthorizationToken {
  return result.hasStorageContainerAuthorizationToken;
}
- (NSString*) storageContainerAuthorizationToken {
  return result.storageContainerAuthorizationToken;
}
- (StorageContainerChunkList_Builder*) setStorageContainerAuthorizationToken:(NSString*) value {
  result.hasStorageContainerAuthorizationToken = YES;
  result.storageContainerAuthorizationToken = value;
  return self;
}
- (StorageContainerChunkList_Builder*) clearStorageContainerAuthorizationToken {
  result.hasStorageContainerAuthorizationToken = NO;
  result.storageContainerAuthorizationToken = @"";
  return self;
}
@end

@interface StorageContainerChunkLists ()
@property (retain) NSMutableArray* mutableStorageContainerChunkListList;
@property (retain) NSMutableArray* mutableFileErrorList;
@property int32_t verbosityLevel;
@end

@implementation StorageContainerChunkLists

@synthesize mutableStorageContainerChunkListList;
@synthesize mutableFileErrorList;
- (BOOL) hasVerbosityLevel {
  return !!hasVerbosityLevel_;
}
- (void) setHasVerbosityLevel:(BOOL) value {
  hasVerbosityLevel_ = !!value;
}
@synthesize verbosityLevel;
- (void) dealloc {
  self.mutableStorageContainerChunkListList = nil;
  self.mutableFileErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.verbosityLevel = 0;
  }
  return self;
}
static StorageContainerChunkLists* defaultStorageContainerChunkListsInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerChunkLists class]) {
    defaultStorageContainerChunkListsInstance = [[StorageContainerChunkLists alloc] init];
  }
}
+ (StorageContainerChunkLists*) defaultInstance {
  return defaultStorageContainerChunkListsInstance;
}
- (StorageContainerChunkLists*) defaultInstance {
  return defaultStorageContainerChunkListsInstance;
}
- (NSArray*) storageContainerChunkListList {
  return mutableStorageContainerChunkListList;
}
- (StorageContainerChunkList*) storageContainerChunkListAtIndex:(int32_t) index {
  id value = [mutableStorageContainerChunkListList objectAtIndex:index];
  return value;
}
- (NSArray*) fileErrorList {
  return mutableFileErrorList;
}
- (FileError*) fileErrorAtIndex:(int32_t) index {
  id value = [mutableFileErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageContainerChunkList* element in self.storageContainerChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileError* element in self.fileErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageContainerChunkList* element in self.storageContainerChunkListList) {
    [output writeMessage:1 value:element];
  }
  for (FileError* element in self.fileErrorList) {
    [output writeMessage:2 value:element];
  }
  if (self.hasVerbosityLevel) {
    [output writeUInt32:3 value:self.verbosityLevel];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageContainerChunkList* element in self.storageContainerChunkListList) {
    size += computeMessageSize(1, element);
  }
  for (FileError* element in self.fileErrorList) {
    size += computeMessageSize(2, element);
  }
  if (self.hasVerbosityLevel) {
    size += computeUInt32Size(3, self.verbosityLevel);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerChunkLists*) parseFromData:(NSData*) data {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeFromData:data] build];
}
+ (StorageContainerChunkLists*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkLists*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeFromInputStream:input] build];
}
+ (StorageContainerChunkLists*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeDelimitedFromInputStream:input] build];
}
+ (StorageContainerChunkLists*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkLists*)[[[StorageContainerChunkLists builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkLists_Builder*) builder {
  return [[[StorageContainerChunkLists_Builder alloc] init] autorelease];
}
+ (StorageContainerChunkLists_Builder*) builderWithPrototype:(StorageContainerChunkLists*) prototype {
  return [[StorageContainerChunkLists builder] mergeFrom:prototype];
}
- (StorageContainerChunkLists_Builder*) builder {
  return [StorageContainerChunkLists builder];
}
@end

@interface StorageContainerChunkLists_Builder()
@property (retain) StorageContainerChunkLists* result;
@end

@implementation StorageContainerChunkLists_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerChunkLists alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerChunkLists_Builder*) clear {
  self.result = [[[StorageContainerChunkLists alloc] init] autorelease];
  return self;
}
- (StorageContainerChunkLists_Builder*) clone {
  return [StorageContainerChunkLists builderWithPrototype:result];
}
- (StorageContainerChunkLists*) defaultInstance {
  return [StorageContainerChunkLists defaultInstance];
}
- (StorageContainerChunkLists*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerChunkLists*) buildPartial {
  StorageContainerChunkLists* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerChunkLists_Builder*) mergeFrom:(StorageContainerChunkLists*) other {
  if (other == [StorageContainerChunkLists defaultInstance]) {
    return self;
  }
  if (other.mutableStorageContainerChunkListList.count > 0) {
    if (result.mutableStorageContainerChunkListList == nil) {
      result.mutableStorageContainerChunkListList = [NSMutableArray array];
    }
    [result.mutableStorageContainerChunkListList addObjectsFromArray:other.mutableStorageContainerChunkListList];
  }
  if (other.mutableFileErrorList.count > 0) {
    if (result.mutableFileErrorList == nil) {
      result.mutableFileErrorList = [NSMutableArray array];
    }
    [result.mutableFileErrorList addObjectsFromArray:other.mutableFileErrorList];
  }
  if (other.hasVerbosityLevel) {
    [self setVerbosityLevel:other.verbosityLevel];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageContainerChunkList_Builder* subBuilder = [StorageContainerChunkList builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageContainerChunkList:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        FileError_Builder* subBuilder = [FileError builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileError:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setVerbosityLevel:[input readUInt32]];
        break;
      }
    }
  }
}
- (NSArray*) storageContainerChunkListList {
  if (result.mutableStorageContainerChunkListList == nil) { return [NSArray array]; }
  return result.mutableStorageContainerChunkListList;
}
- (StorageContainerChunkList*) storageContainerChunkListAtIndex:(int32_t) index {
  return [result storageContainerChunkListAtIndex:index];
}
- (StorageContainerChunkLists_Builder*) replaceStorageContainerChunkListAtIndex:(int32_t) index with:(StorageContainerChunkList*) value {
  [result.mutableStorageContainerChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerChunkLists_Builder*) addAllStorageContainerChunkList:(NSArray*) values {
  if (result.mutableStorageContainerChunkListList == nil) {
    result.mutableStorageContainerChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageContainerChunkListList addObjectsFromArray:values];
  return self;
}
- (StorageContainerChunkLists_Builder*) clearStorageContainerChunkListList {
  result.mutableStorageContainerChunkListList = nil;
  return self;
}
- (StorageContainerChunkLists_Builder*) addStorageContainerChunkList:(StorageContainerChunkList*) value {
  if (result.mutableStorageContainerChunkListList == nil) {
    result.mutableStorageContainerChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageContainerChunkListList addObject:value];
  return self;
}
- (NSArray*) fileErrorList {
  if (result.mutableFileErrorList == nil) { return [NSArray array]; }
  return result.mutableFileErrorList;
}
- (FileError*) fileErrorAtIndex:(int32_t) index {
  return [result fileErrorAtIndex:index];
}
- (StorageContainerChunkLists_Builder*) replaceFileErrorAtIndex:(int32_t) index with:(FileError*) value {
  [result.mutableFileErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerChunkLists_Builder*) addAllFileError:(NSArray*) values {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObjectsFromArray:values];
  return self;
}
- (StorageContainerChunkLists_Builder*) clearFileErrorList {
  result.mutableFileErrorList = nil;
  return self;
}
- (StorageContainerChunkLists_Builder*) addFileError:(FileError*) value {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObject:value];
  return self;
}
- (BOOL) hasVerbosityLevel {
  return result.hasVerbosityLevel;
}
- (int32_t) verbosityLevel {
  return result.verbosityLevel;
}
- (StorageContainerChunkLists_Builder*) setVerbosityLevel:(int32_t) value {
  result.hasVerbosityLevel = YES;
  result.verbosityLevel = value;
  return self;
}
- (StorageContainerChunkLists_Builder*) clearVerbosityLevel {
  result.hasVerbosityLevel = NO;
  result.verbosityLevel = 0;
  return self;
}
@end

@interface StorageContainerErrorList ()
@property (retain) NSMutableArray* mutableStorageContainerErrorList;
@end

@implementation StorageContainerErrorList

@synthesize mutableStorageContainerErrorList;
- (void) dealloc {
  self.mutableStorageContainerErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static StorageContainerErrorList* defaultStorageContainerErrorListInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerErrorList class]) {
    defaultStorageContainerErrorListInstance = [[StorageContainerErrorList alloc] init];
  }
}
+ (StorageContainerErrorList*) defaultInstance {
  return defaultStorageContainerErrorListInstance;
}
- (StorageContainerErrorList*) defaultInstance {
  return defaultStorageContainerErrorListInstance;
}
- (NSArray*) storageContainerErrorList {
  return mutableStorageContainerErrorList;
}
- (StorageContainerError*) storageContainerErrorAtIndex:(int32_t) index {
  id value = [mutableStorageContainerErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageContainerError* element in self.storageContainerErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageContainerError* element in self.storageContainerErrorList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageContainerError* element in self.storageContainerErrorList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerErrorList*) parseFromData:(NSData*) data {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeFromData:data] build];
}
+ (StorageContainerErrorList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorList*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeFromInputStream:input] build];
}
+ (StorageContainerErrorList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeDelimitedFromInputStream:input] build];
}
+ (StorageContainerErrorList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerErrorList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorList*)[[[StorageContainerErrorList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorList_Builder*) builder {
  return [[[StorageContainerErrorList_Builder alloc] init] autorelease];
}
+ (StorageContainerErrorList_Builder*) builderWithPrototype:(StorageContainerErrorList*) prototype {
  return [[StorageContainerErrorList builder] mergeFrom:prototype];
}
- (StorageContainerErrorList_Builder*) builder {
  return [StorageContainerErrorList builder];
}
@end

@interface StorageContainerErrorList_Builder()
@property (retain) StorageContainerErrorList* result;
@end

@implementation StorageContainerErrorList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerErrorList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerErrorList_Builder*) clear {
  self.result = [[[StorageContainerErrorList alloc] init] autorelease];
  return self;
}
- (StorageContainerErrorList_Builder*) clone {
  return [StorageContainerErrorList builderWithPrototype:result];
}
- (StorageContainerErrorList*) defaultInstance {
  return [StorageContainerErrorList defaultInstance];
}
- (StorageContainerErrorList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerErrorList*) buildPartial {
  StorageContainerErrorList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerErrorList_Builder*) mergeFrom:(StorageContainerErrorList*) other {
  if (other == [StorageContainerErrorList defaultInstance]) {
    return self;
  }
  if (other.mutableStorageContainerErrorList.count > 0) {
    if (result.mutableStorageContainerErrorList == nil) {
      result.mutableStorageContainerErrorList = [NSMutableArray array];
    }
    [result.mutableStorageContainerErrorList addObjectsFromArray:other.mutableStorageContainerErrorList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerErrorList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerErrorList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageContainerError_Builder* subBuilder = [StorageContainerError builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageContainerError:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) storageContainerErrorList {
  if (result.mutableStorageContainerErrorList == nil) { return [NSArray array]; }
  return result.mutableStorageContainerErrorList;
}
- (StorageContainerError*) storageContainerErrorAtIndex:(int32_t) index {
  return [result storageContainerErrorAtIndex:index];
}
- (StorageContainerErrorList_Builder*) replaceStorageContainerErrorAtIndex:(int32_t) index with:(StorageContainerError*) value {
  [result.mutableStorageContainerErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerErrorList_Builder*) addAllStorageContainerError:(NSArray*) values {
  if (result.mutableStorageContainerErrorList == nil) {
    result.mutableStorageContainerErrorList = [NSMutableArray array];
  }
  [result.mutableStorageContainerErrorList addObjectsFromArray:values];
  return self;
}
- (StorageContainerErrorList_Builder*) clearStorageContainerErrorList {
  result.mutableStorageContainerErrorList = nil;
  return self;
}
- (StorageContainerErrorList_Builder*) addStorageContainerError:(StorageContainerError*) value {
  if (result.mutableStorageContainerErrorList == nil) {
    result.mutableStorageContainerErrorList = [NSMutableArray array];
  }
  [result.mutableStorageContainerErrorList addObject:value];
  return self;
}
@end

@interface FileChecksumAuthorization ()
@property (retain) NSData* fileChecksum;
@property (retain) NSString* authorization;
@property (retain) NSMutableArray* mutableChunkChecksumsList;
@end

@implementation FileChecksumAuthorization

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
- (BOOL) hasAuthorization {
  return !!hasAuthorization_;
}
- (void) setHasAuthorization:(BOOL) value {
  hasAuthorization_ = !!value;
}
@synthesize authorization;
@synthesize mutableChunkChecksumsList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.authorization = nil;
  self.mutableChunkChecksumsList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.authorization = @"";
  }
  return self;
}
static FileChecksumAuthorization* defaultFileChecksumAuthorizationInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumAuthorization class]) {
    defaultFileChecksumAuthorizationInstance = [[FileChecksumAuthorization alloc] init];
  }
}
+ (FileChecksumAuthorization*) defaultInstance {
  return defaultFileChecksumAuthorizationInstance;
}
- (FileChecksumAuthorization*) defaultInstance {
  return defaultFileChecksumAuthorizationInstance;
}
- (NSArray*) chunkChecksumsList {
  return mutableChunkChecksumsList;
}
- (NSData*) chunkChecksumsAtIndex:(int32_t) index {
  id value = [mutableChunkChecksumsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  if (!self.hasAuthorization) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  if (self.hasAuthorization) {
    [output writeString:2 value:self.authorization];
  }
  for (NSData* element in self.mutableChunkChecksumsList) {
    [output writeData:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  if (self.hasAuthorization) {
    size += computeStringSize(2, self.authorization);
  }
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableChunkChecksumsList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableChunkChecksumsList.count;
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumAuthorization*) parseFromData:(NSData*) data {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeFromData:data] build];
}
+ (FileChecksumAuthorization*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorization*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeFromInputStream:input] build];
}
+ (FileChecksumAuthorization*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChecksumAuthorization*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorization*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumAuthorization*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorization*)[[[FileChecksumAuthorization builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorization_Builder*) builder {
  return [[[FileChecksumAuthorization_Builder alloc] init] autorelease];
}
+ (FileChecksumAuthorization_Builder*) builderWithPrototype:(FileChecksumAuthorization*) prototype {
  return [[FileChecksumAuthorization builder] mergeFrom:prototype];
}
- (FileChecksumAuthorization_Builder*) builder {
  return [FileChecksumAuthorization builder];
}
@end

@interface FileChecksumAuthorization_Builder()
@property (retain) FileChecksumAuthorization* result;
@end

@implementation FileChecksumAuthorization_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumAuthorization alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumAuthorization_Builder*) clear {
  self.result = [[[FileChecksumAuthorization alloc] init] autorelease];
  return self;
}
- (FileChecksumAuthorization_Builder*) clone {
  return [FileChecksumAuthorization builderWithPrototype:result];
}
- (FileChecksumAuthorization*) defaultInstance {
  return [FileChecksumAuthorization defaultInstance];
}
- (FileChecksumAuthorization*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumAuthorization*) buildPartial {
  FileChecksumAuthorization* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumAuthorization_Builder*) mergeFrom:(FileChecksumAuthorization*) other {
  if (other == [FileChecksumAuthorization defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.hasAuthorization) {
    [self setAuthorization:other.authorization];
  }
  if (other.mutableChunkChecksumsList.count > 0) {
    if (result.mutableChunkChecksumsList == nil) {
      result.mutableChunkChecksumsList = [NSMutableArray array];
    }
    [result.mutableChunkChecksumsList addObjectsFromArray:other.mutableChunkChecksumsList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumAuthorization_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumAuthorization_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setAuthorization:[input readString]];
        break;
      }
      case 26: {
        [self addChunkChecksums:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChecksumAuthorization_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChecksumAuthorization_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (BOOL) hasAuthorization {
  return result.hasAuthorization;
}
- (NSString*) authorization {
  return result.authorization;
}
- (FileChecksumAuthorization_Builder*) setAuthorization:(NSString*) value {
  result.hasAuthorization = YES;
  result.authorization = value;
  return self;
}
- (FileChecksumAuthorization_Builder*) clearAuthorization {
  result.hasAuthorization = NO;
  result.authorization = @"";
  return self;
}
- (NSArray*) chunkChecksumsList {
  if (result.mutableChunkChecksumsList == nil) {
    return [NSArray array];
  }
  return result.mutableChunkChecksumsList;
}
- (NSData*) chunkChecksumsAtIndex:(int32_t) index {
  return [result chunkChecksumsAtIndex:index];
}
- (FileChecksumAuthorization_Builder*) replaceChunkChecksumsAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableChunkChecksumsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumAuthorization_Builder*) addChunkChecksums:(NSData*) value {
  if (result.mutableChunkChecksumsList == nil) {
    result.mutableChunkChecksumsList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumsList addObject:value];
  return self;
}
- (FileChecksumAuthorization_Builder*) addAllChunkChecksums:(NSArray*) values {
  if (result.mutableChunkChecksumsList == nil) {
    result.mutableChunkChecksumsList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumsList addObjectsFromArray:values];
  return self;
}
- (FileChecksumAuthorization_Builder*) clearChunkChecksumsList {
  result.mutableChunkChecksumsList = nil;
  return self;
}
@end

@interface FileChecksumAuthorizationList ()
@property (retain) NSMutableArray* mutableFileChecksumAuthorizationList;
@end

@implementation FileChecksumAuthorizationList

@synthesize mutableFileChecksumAuthorizationList;
- (void) dealloc {
  self.mutableFileChecksumAuthorizationList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileChecksumAuthorizationList* defaultFileChecksumAuthorizationListInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumAuthorizationList class]) {
    defaultFileChecksumAuthorizationListInstance = [[FileChecksumAuthorizationList alloc] init];
  }
}
+ (FileChecksumAuthorizationList*) defaultInstance {
  return defaultFileChecksumAuthorizationListInstance;
}
- (FileChecksumAuthorizationList*) defaultInstance {
  return defaultFileChecksumAuthorizationListInstance;
}
- (NSArray*) fileChecksumAuthorizationList {
  return mutableFileChecksumAuthorizationList;
}
- (FileChecksumAuthorization*) fileChecksumAuthorizationAtIndex:(int32_t) index {
  id value = [mutableFileChecksumAuthorizationList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (FileChecksumAuthorization* element in self.fileChecksumAuthorizationList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (FileChecksumAuthorization* element in self.fileChecksumAuthorizationList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (FileChecksumAuthorization* element in self.fileChecksumAuthorizationList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumAuthorizationList*) parseFromData:(NSData*) data {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeFromData:data] build];
}
+ (FileChecksumAuthorizationList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationList*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeFromInputStream:input] build];
}
+ (FileChecksumAuthorizationList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChecksumAuthorizationList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumAuthorizationList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationList*)[[[FileChecksumAuthorizationList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationList_Builder*) builder {
  return [[[FileChecksumAuthorizationList_Builder alloc] init] autorelease];
}
+ (FileChecksumAuthorizationList_Builder*) builderWithPrototype:(FileChecksumAuthorizationList*) prototype {
  return [[FileChecksumAuthorizationList builder] mergeFrom:prototype];
}
- (FileChecksumAuthorizationList_Builder*) builder {
  return [FileChecksumAuthorizationList builder];
}
@end

@interface FileChecksumAuthorizationList_Builder()
@property (retain) FileChecksumAuthorizationList* result;
@end

@implementation FileChecksumAuthorizationList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumAuthorizationList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumAuthorizationList_Builder*) clear {
  self.result = [[[FileChecksumAuthorizationList alloc] init] autorelease];
  return self;
}
- (FileChecksumAuthorizationList_Builder*) clone {
  return [FileChecksumAuthorizationList builderWithPrototype:result];
}
- (FileChecksumAuthorizationList*) defaultInstance {
  return [FileChecksumAuthorizationList defaultInstance];
}
- (FileChecksumAuthorizationList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumAuthorizationList*) buildPartial {
  FileChecksumAuthorizationList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumAuthorizationList_Builder*) mergeFrom:(FileChecksumAuthorizationList*) other {
  if (other == [FileChecksumAuthorizationList defaultInstance]) {
    return self;
  }
  if (other.mutableFileChecksumAuthorizationList.count > 0) {
    if (result.mutableFileChecksumAuthorizationList == nil) {
      result.mutableFileChecksumAuthorizationList = [NSMutableArray array];
    }
    [result.mutableFileChecksumAuthorizationList addObjectsFromArray:other.mutableFileChecksumAuthorizationList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumAuthorizationList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumAuthorizationList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        FileChecksumAuthorization_Builder* subBuilder = [FileChecksumAuthorization builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChecksumAuthorization:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) fileChecksumAuthorizationList {
  if (result.mutableFileChecksumAuthorizationList == nil) { return [NSArray array]; }
  return result.mutableFileChecksumAuthorizationList;
}
- (FileChecksumAuthorization*) fileChecksumAuthorizationAtIndex:(int32_t) index {
  return [result fileChecksumAuthorizationAtIndex:index];
}
- (FileChecksumAuthorizationList_Builder*) replaceFileChecksumAuthorizationAtIndex:(int32_t) index with:(FileChecksumAuthorization*) value {
  [result.mutableFileChecksumAuthorizationList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumAuthorizationList_Builder*) addAllFileChecksumAuthorization:(NSArray*) values {
  if (result.mutableFileChecksumAuthorizationList == nil) {
    result.mutableFileChecksumAuthorizationList = [NSMutableArray array];
  }
  [result.mutableFileChecksumAuthorizationList addObjectsFromArray:values];
  return self;
}
- (FileChecksumAuthorizationList_Builder*) clearFileChecksumAuthorizationList {
  result.mutableFileChecksumAuthorizationList = nil;
  return self;
}
- (FileChecksumAuthorizationList_Builder*) addFileChecksumAuthorization:(FileChecksumAuthorization*) value {
  if (result.mutableFileChecksumAuthorizationList == nil) {
    result.mutableFileChecksumAuthorizationList = [NSMutableArray array];
  }
  [result.mutableFileChecksumAuthorizationList addObject:value];
  return self;
}
@end

@interface ChunkReference ()
@property int64_t containerIndex;
@property int64_t chunkIndex;
@end

@implementation ChunkReference

- (BOOL) hasContainerIndex {
  return !!hasContainerIndex_;
}
- (void) setHasContainerIndex:(BOOL) value {
  hasContainerIndex_ = !!value;
}
@synthesize containerIndex;
- (BOOL) hasChunkIndex {
  return !!hasChunkIndex_;
}
- (void) setHasChunkIndex:(BOOL) value {
  hasChunkIndex_ = !!value;
}
@synthesize chunkIndex;
- (void) dealloc {
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.containerIndex = 0L;
    self.chunkIndex = 0L;
  }
  return self;
}
- (id)copyWithZone:(NSZone*)zone {
    return [self retain];
}
static ChunkReference* defaultChunkReferenceInstance = nil;
+ (void) initialize {
  if (self == [ChunkReference class]) {
    defaultChunkReferenceInstance = [[ChunkReference alloc] init];
  }
}
+ (ChunkReference*) defaultInstance {
  return defaultChunkReferenceInstance;
}
- (ChunkReference*) defaultInstance {
  return defaultChunkReferenceInstance;
}
- (BOOL) isInitialized {
  if (!self.hasContainerIndex) {
    return NO;
  }
  if (!self.hasChunkIndex) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasContainerIndex) {
    [output writeUInt64:1 value:self.containerIndex];
  }
  if (self.hasChunkIndex) {
    [output writeUInt64:2 value:self.chunkIndex];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasContainerIndex) {
    size += computeUInt64Size(1, self.containerIndex);
  }
  if (self.hasChunkIndex) {
    size += computeUInt64Size(2, self.chunkIndex);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    if (object == nil) {
        return NO;
    }
    if ([self class] != [object class]) {
        return NO;
    }
    ChunkReference *other = (ChunkReference*)object;
    if (self.containerIndex != other.containerIndex) {
        return NO;
    }
    if (self.chunkIndex != other.chunkIndex) {
        return NO;
    }
    return YES;
}
+ (ChunkReference*) parseFromData:(NSData*) data {
  return (ChunkReference*)[[[ChunkReference builder] mergeFromData:data] build];
}
+ (ChunkReference*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkReference*)[[[ChunkReference builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkReference*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkReference*)[[[ChunkReference builder] mergeFromInputStream:input] build];
}
+ (ChunkReference*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (ChunkReference*)[[[ChunkReference builder] mergeDelimitedFromInputStream:input] build];
}
+ (ChunkReference*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkReference*)[[[ChunkReference builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkReference*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkReference*)[[[ChunkReference builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkReference*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkReference*)[[[ChunkReference builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkReference_Builder*) builder {
  return [[[ChunkReference_Builder alloc] init] autorelease];
}
+ (ChunkReference_Builder*) builderWithPrototype:(ChunkReference*) prototype {
  return [[ChunkReference builder] mergeFrom:prototype];
}
- (ChunkReference_Builder*) builder {
  return [ChunkReference builder];
}
@end

@interface ChunkReference_Builder()
@property (retain) ChunkReference* result;
@end

@implementation ChunkReference_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkReference alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkReference_Builder*) clear {
  self.result = [[[ChunkReference alloc] init] autorelease];
  return self;
}
- (ChunkReference_Builder*) clone {
  return [ChunkReference builderWithPrototype:result];
}
- (ChunkReference*) defaultInstance {
  return [ChunkReference defaultInstance];
}
- (ChunkReference*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkReference*) buildPartial {
  ChunkReference* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkReference_Builder*) mergeFrom:(ChunkReference*) other {
  if (other == [ChunkReference defaultInstance]) {
    return self;
  }
  if (other.hasContainerIndex) {
    [self setContainerIndex:other.containerIndex];
  }
  if (other.hasChunkIndex) {
    [self setChunkIndex:other.chunkIndex];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkReference_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkReference_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setContainerIndex:[input readUInt64]];
        break;
      }
      case 16: {
        [self setChunkIndex:[input readUInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasContainerIndex {
  return result.hasContainerIndex;
}
- (int64_t) containerIndex {
  return result.containerIndex;
}
- (ChunkReference_Builder*) setContainerIndex:(int64_t) value {
  result.hasContainerIndex = YES;
  result.containerIndex = value;
  return self;
}
- (ChunkReference_Builder*) clearContainerIndex {
  result.hasContainerIndex = NO;
  result.containerIndex = 0L;
  return self;
}
- (BOOL) hasChunkIndex {
  return result.hasChunkIndex;
}
- (int64_t) chunkIndex {
  return result.chunkIndex;
}
- (ChunkReference_Builder*) setChunkIndex:(int64_t) value {
  result.hasChunkIndex = YES;
  result.chunkIndex = value;
  return self;
}
- (ChunkReference_Builder*) clearChunkIndex {
  result.hasChunkIndex = NO;
  result.chunkIndex = 0L;
  return self;
}
@end

@interface FileChecksumChunkReferences ()
@property (retain) NSData* fileChecksum;
@property (retain) NSMutableArray* mutableChunkReferencesList;
@property (retain) NSData* fileSignature;
@end

@implementation FileChecksumChunkReferences

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
@synthesize mutableChunkReferencesList;
- (BOOL) hasFileSignature {
  return !!hasFileSignature_;
}
- (void) setHasFileSignature:(BOOL) value {
  hasFileSignature_ = !!value;
}
@synthesize fileSignature;
- (void) dealloc {
  self.fileChecksum = nil;
  self.mutableChunkReferencesList = nil;
  self.fileSignature = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.fileSignature = [NSData data];
  }
  return self;
}
static FileChecksumChunkReferences* defaultFileChecksumChunkReferencesInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumChunkReferences class]) {
    defaultFileChecksumChunkReferencesInstance = [[FileChecksumChunkReferences alloc] init];
  }
}
+ (FileChecksumChunkReferences*) defaultInstance {
  return defaultFileChecksumChunkReferencesInstance;
}
- (FileChecksumChunkReferences*) defaultInstance {
  return defaultFileChecksumChunkReferencesInstance;
}
- (NSArray*) chunkReferencesList {
  return mutableChunkReferencesList;
}
- (ChunkReference*) chunkReferencesAtIndex:(int32_t) index {
  id value = [mutableChunkReferencesList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  for (ChunkReference* element in self.chunkReferencesList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  for (ChunkReference* element in self.chunkReferencesList) {
    [output writeMessage:2 value:element];
  }
  if (self.hasFileSignature) {
    [output writeData:3 value:self.fileSignature];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  for (ChunkReference* element in self.chunkReferencesList) {
    size += computeMessageSize(2, element);
  }
  if (self.hasFileSignature) {
    size += computeDataSize(3, self.fileSignature);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumChunkReferences*) parseFromData:(NSData*) data {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeFromData:data] build];
}
+ (FileChecksumChunkReferences*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumChunkReferences*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeFromInputStream:input] build];
}
+ (FileChecksumChunkReferences*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChecksumChunkReferences*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumChunkReferences*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumChunkReferences*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumChunkReferences*)[[[FileChecksumChunkReferences builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumChunkReferences_Builder*) builder {
  return [[[FileChecksumChunkReferences_Builder alloc] init] autorelease];
}
+ (FileChecksumChunkReferences_Builder*) builderWithPrototype:(FileChecksumChunkReferences*) prototype {
  return [[FileChecksumChunkReferences builder] mergeFrom:prototype];
}
- (FileChecksumChunkReferences_Builder*) builder {
  return [FileChecksumChunkReferences builder];
}
@end

@interface FileChecksumChunkReferences_Builder()
@property (retain) FileChecksumChunkReferences* result;
@end

@implementation FileChecksumChunkReferences_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumChunkReferences alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumChunkReferences_Builder*) clear {
  self.result = [[[FileChecksumChunkReferences alloc] init] autorelease];
  return self;
}
- (FileChecksumChunkReferences_Builder*) clone {
  return [FileChecksumChunkReferences builderWithPrototype:result];
}
- (FileChecksumChunkReferences*) defaultInstance {
  return [FileChecksumChunkReferences defaultInstance];
}
- (FileChecksumChunkReferences*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumChunkReferences*) buildPartial {
  FileChecksumChunkReferences* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumChunkReferences_Builder*) mergeFrom:(FileChecksumChunkReferences*) other {
  if (other == [FileChecksumChunkReferences defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.mutableChunkReferencesList.count > 0) {
    if (result.mutableChunkReferencesList == nil) {
      result.mutableChunkReferencesList = [NSMutableArray array];
    }
    [result.mutableChunkReferencesList addObjectsFromArray:other.mutableChunkReferencesList];
  }
  if (other.hasFileSignature) {
    [self setFileSignature:other.fileSignature];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumChunkReferences_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumChunkReferences_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        ChunkReference_Builder* subBuilder = [ChunkReference builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkReferences:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        [self setFileSignature:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChecksumChunkReferences_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChecksumChunkReferences_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (NSArray*) chunkReferencesList {
  if (result.mutableChunkReferencesList == nil) { return [NSArray array]; }
  return result.mutableChunkReferencesList;
}
- (ChunkReference*) chunkReferencesAtIndex:(int32_t) index {
  return [result chunkReferencesAtIndex:index];
}
- (FileChecksumChunkReferences_Builder*) replaceChunkReferencesAtIndex:(int32_t) index with:(ChunkReference*) value {
  [result.mutableChunkReferencesList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumChunkReferences_Builder*) addAllChunkReferences:(NSArray*) values {
  if (result.mutableChunkReferencesList == nil) {
    result.mutableChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableChunkReferencesList addObjectsFromArray:values];
  return self;
}
- (FileChecksumChunkReferences_Builder*) clearChunkReferencesList {
  result.mutableChunkReferencesList = nil;
  return self;
}
- (FileChecksumChunkReferences_Builder*) addChunkReferences:(ChunkReference*) value {
  if (result.mutableChunkReferencesList == nil) {
    result.mutableChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableChunkReferencesList addObject:value];
  return self;
}
- (BOOL) hasFileSignature {
  return result.hasFileSignature;
}
- (NSData*) fileSignature {
  return result.fileSignature;
}
- (FileChecksumChunkReferences_Builder*) setFileSignature:(NSData*) value {
  result.hasFileSignature = YES;
  result.fileSignature = value;
  return self;
}
- (FileChecksumChunkReferences_Builder*) clearFileSignature {
  result.hasFileSignature = NO;
  result.fileSignature = [NSData data];
  return self;
}
@end

@interface FileChecksumStorageHostChunkLists ()
@property (retain) NSMutableArray* mutableStorageHostChunkListList;
@property (retain) NSMutableArray* mutableFileChecksumChunkReferencesList;
@end

@implementation FileChecksumStorageHostChunkLists

@synthesize mutableStorageHostChunkListList;
@synthesize mutableFileChecksumChunkReferencesList;
- (void) dealloc {
  self.mutableStorageHostChunkListList = nil;
  self.mutableFileChecksumChunkReferencesList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileChecksumStorageHostChunkLists* defaultFileChecksumStorageHostChunkListsInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumStorageHostChunkLists class]) {
    defaultFileChecksumStorageHostChunkListsInstance = [[FileChecksumStorageHostChunkLists alloc] init];
  }
}
+ (FileChecksumStorageHostChunkLists*) defaultInstance {
  return defaultFileChecksumStorageHostChunkListsInstance;
}
- (FileChecksumStorageHostChunkLists*) defaultInstance {
  return defaultFileChecksumStorageHostChunkListsInstance;
}
- (NSArray*) storageHostChunkListList {
  return mutableStorageHostChunkListList;
}
- (StorageHostChunkList*) storageHostChunkListAtIndex:(int32_t) index {
  id value = [mutableStorageHostChunkListList objectAtIndex:index];
  return value;
}
- (NSArray*) fileChecksumChunkReferencesList {
  return mutableFileChecksumChunkReferencesList;
}
- (FileChecksumChunkReferences*) fileChecksumChunkReferencesAtIndex:(int32_t) index {
  id value = [mutableFileChecksumChunkReferencesList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageHostChunkList* element in self.storageHostChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileChecksumChunkReferences* element in self.fileChecksumChunkReferencesList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageHostChunkList* element in self.storageHostChunkListList) {
    [output writeMessage:1 value:element];
  }
  for (FileChecksumChunkReferences* element in self.fileChecksumChunkReferencesList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageHostChunkList* element in self.storageHostChunkListList) {
    size += computeMessageSize(1, element);
  }
  for (FileChecksumChunkReferences* element in self.fileChecksumChunkReferencesList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumStorageHostChunkLists*) parseFromData:(NSData*) data {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeFromData:data] build];
}
+ (FileChecksumStorageHostChunkLists*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumStorageHostChunkLists*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeFromInputStream:input] build];
}
+ (FileChecksumStorageHostChunkLists*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileChecksumStorageHostChunkLists*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumStorageHostChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumStorageHostChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumStorageHostChunkLists*)[[[FileChecksumStorageHostChunkLists builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumStorageHostChunkLists_Builder*) builder {
  return [[[FileChecksumStorageHostChunkLists_Builder alloc] init] autorelease];
}
+ (FileChecksumStorageHostChunkLists_Builder*) builderWithPrototype:(FileChecksumStorageHostChunkLists*) prototype {
  return [[FileChecksumStorageHostChunkLists builder] mergeFrom:prototype];
}
- (FileChecksumStorageHostChunkLists_Builder*) builder {
  return [FileChecksumStorageHostChunkLists builder];
}
@end

@interface FileChecksumStorageHostChunkLists_Builder()
@property (retain) FileChecksumStorageHostChunkLists* result;
@end

@implementation FileChecksumStorageHostChunkLists_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumStorageHostChunkLists alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumStorageHostChunkLists_Builder*) clear {
  self.result = [[[FileChecksumStorageHostChunkLists alloc] init] autorelease];
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) clone {
  return [FileChecksumStorageHostChunkLists builderWithPrototype:result];
}
- (FileChecksumStorageHostChunkLists*) defaultInstance {
  return [FileChecksumStorageHostChunkLists defaultInstance];
}
- (FileChecksumStorageHostChunkLists*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumStorageHostChunkLists*) buildPartial {
  FileChecksumStorageHostChunkLists* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumStorageHostChunkLists_Builder*) mergeFrom:(FileChecksumStorageHostChunkLists*) other {
  if (other == [FileChecksumStorageHostChunkLists defaultInstance]) {
    return self;
  }
  if (other.mutableStorageHostChunkListList.count > 0) {
    if (result.mutableStorageHostChunkListList == nil) {
      result.mutableStorageHostChunkListList = [NSMutableArray array];
    }
    [result.mutableStorageHostChunkListList addObjectsFromArray:other.mutableStorageHostChunkListList];
  }
  if (other.mutableFileChecksumChunkReferencesList.count > 0) {
    if (result.mutableFileChecksumChunkReferencesList == nil) {
      result.mutableFileChecksumChunkReferencesList = [NSMutableArray array];
    }
    [result.mutableFileChecksumChunkReferencesList addObjectsFromArray:other.mutableFileChecksumChunkReferencesList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumStorageHostChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageHostChunkList_Builder* subBuilder = [StorageHostChunkList builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageHostChunkList:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        FileChecksumChunkReferences_Builder* subBuilder = [FileChecksumChunkReferences builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChecksumChunkReferences:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) storageHostChunkListList {
  if (result.mutableStorageHostChunkListList == nil) { return [NSArray array]; }
  return result.mutableStorageHostChunkListList;
}
- (StorageHostChunkList*) storageHostChunkListAtIndex:(int32_t) index {
  return [result storageHostChunkListAtIndex:index];
}
- (FileChecksumStorageHostChunkLists_Builder*) replaceStorageHostChunkListAtIndex:(int32_t) index with:(StorageHostChunkList*) value {
  [result.mutableStorageHostChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) addAllStorageHostChunkList:(NSArray*) values {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObjectsFromArray:values];
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) clearStorageHostChunkListList {
  result.mutableStorageHostChunkListList = nil;
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) addStorageHostChunkList:(StorageHostChunkList*) value {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObject:value];
  return self;
}
- (NSArray*) fileChecksumChunkReferencesList {
  if (result.mutableFileChecksumChunkReferencesList == nil) { return [NSArray array]; }
  return result.mutableFileChecksumChunkReferencesList;
}
- (FileChecksumChunkReferences*) fileChecksumChunkReferencesAtIndex:(int32_t) index {
  return [result fileChecksumChunkReferencesAtIndex:index];
}
- (FileChecksumStorageHostChunkLists_Builder*) replaceFileChecksumChunkReferencesAtIndex:(int32_t) index with:(FileChecksumChunkReferences*) value {
  [result.mutableFileChecksumChunkReferencesList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) addAllFileChecksumChunkReferences:(NSArray*) values {
  if (result.mutableFileChecksumChunkReferencesList == nil) {
    result.mutableFileChecksumChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableFileChecksumChunkReferencesList addObjectsFromArray:values];
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) clearFileChecksumChunkReferencesList {
  result.mutableFileChecksumChunkReferencesList = nil;
  return self;
}
- (FileChecksumStorageHostChunkLists_Builder*) addFileChecksumChunkReferences:(FileChecksumChunkReferences*) value {
  if (result.mutableFileChecksumChunkReferencesList == nil) {
    result.mutableFileChecksumChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableFileChecksumChunkReferencesList addObject:value];
  return self;
}
@end

@interface FileGroups ()
@property (retain) NSMutableArray* mutableFileGroupsList;
@property (retain) NSMutableArray* mutableFileErrorList;
@property (retain) NSMutableArray* mutableFileChunkErrorList;
@property int32_t verbosityLevel;
@end

@implementation FileGroups

@synthesize mutableFileGroupsList;
@synthesize mutableFileErrorList;
@synthesize mutableFileChunkErrorList;
- (BOOL) hasVerbosityLevel {
  return !!hasVerbosityLevel_;
}
- (void) setHasVerbosityLevel:(BOOL) value {
  hasVerbosityLevel_ = !!value;
}
@synthesize verbosityLevel;
- (void) dealloc {
  self.mutableFileGroupsList = nil;
  self.mutableFileErrorList = nil;
  self.mutableFileChunkErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.verbosityLevel = 0;
  }
  return self;
}
static FileGroups* defaultFileGroupsInstance = nil;
+ (void) initialize {
  if (self == [FileGroups class]) {
    defaultFileGroupsInstance = [[FileGroups alloc] init];
  }
}
+ (FileGroups*) defaultInstance {
  return defaultFileGroupsInstance;
}
- (FileGroups*) defaultInstance {
  return defaultFileGroupsInstance;
}
- (NSArray*) fileGroupsList {
  return mutableFileGroupsList;
}
- (FileChecksumStorageHostChunkLists*) fileGroupsAtIndex:(int32_t) index {
  id value = [mutableFileGroupsList objectAtIndex:index];
  return value;
}
- (NSArray*) fileErrorList {
  return mutableFileErrorList;
}
- (FileError*) fileErrorAtIndex:(int32_t) index {
  id value = [mutableFileErrorList objectAtIndex:index];
  return value;
}
- (NSArray*) fileChunkErrorList {
  return mutableFileChunkErrorList;
}
- (FileChunkError*) fileChunkErrorAtIndex:(int32_t) index {
  id value = [mutableFileChunkErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (FileChecksumStorageHostChunkLists* element in self.fileGroupsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileError* element in self.fileErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileChunkError* element in self.fileChunkErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (FileChecksumStorageHostChunkLists* element in self.fileGroupsList) {
    [output writeMessage:1 value:element];
  }
  for (FileError* element in self.fileErrorList) {
    [output writeMessage:2 value:element];
  }
  for (FileChunkError* element in self.fileChunkErrorList) {
    [output writeMessage:3 value:element];
  }
  if (self.hasVerbosityLevel) {
    [output writeUInt32:4 value:self.verbosityLevel];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (FileChecksumStorageHostChunkLists* element in self.fileGroupsList) {
    size += computeMessageSize(1, element);
  }
  for (FileError* element in self.fileErrorList) {
    size += computeMessageSize(2, element);
  }
  for (FileChunkError* element in self.fileChunkErrorList) {
    size += computeMessageSize(3, element);
  }
  if (self.hasVerbosityLevel) {
    size += computeUInt32Size(4, self.verbosityLevel);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileGroups*) parseFromData:(NSData*) data {
  return (FileGroups*)[[[FileGroups builder] mergeFromData:data] build];
}
+ (FileGroups*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileGroups*)[[[FileGroups builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileGroups*) parseFromInputStream:(NSInputStream*) input {
  return (FileGroups*)[[[FileGroups builder] mergeFromInputStream:input] build];
}
+ (FileGroups*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (FileGroups*)[[[FileGroups builder] mergeDelimitedFromInputStream:input] build];
}
+ (FileGroups*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileGroups*)[[[FileGroups builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileGroups*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileGroups*)[[[FileGroups builder] mergeFromCodedInputStream:input] build];
}
+ (FileGroups*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileGroups*)[[[FileGroups builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileGroups_Builder*) builder {
  return [[[FileGroups_Builder alloc] init] autorelease];
}
+ (FileGroups_Builder*) builderWithPrototype:(FileGroups*) prototype {
  return [[FileGroups builder] mergeFrom:prototype];
}
- (FileGroups_Builder*) builder {
  return [FileGroups builder];
}
@end

@interface FileGroups_Builder()
@property (retain) FileGroups* result;
@end

@implementation FileGroups_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileGroups alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileGroups_Builder*) clear {
  self.result = [[[FileGroups alloc] init] autorelease];
  return self;
}
- (FileGroups_Builder*) clone {
  return [FileGroups builderWithPrototype:result];
}
- (FileGroups*) defaultInstance {
  return [FileGroups defaultInstance];
}
- (FileGroups*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileGroups*) buildPartial {
  FileGroups* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileGroups_Builder*) mergeFrom:(FileGroups*) other {
  if (other == [FileGroups defaultInstance]) {
    return self;
  }
  if (other.mutableFileGroupsList.count > 0) {
    if (result.mutableFileGroupsList == nil) {
      result.mutableFileGroupsList = [NSMutableArray array];
    }
    [result.mutableFileGroupsList addObjectsFromArray:other.mutableFileGroupsList];
  }
  if (other.mutableFileErrorList.count > 0) {
    if (result.mutableFileErrorList == nil) {
      result.mutableFileErrorList = [NSMutableArray array];
    }
    [result.mutableFileErrorList addObjectsFromArray:other.mutableFileErrorList];
  }
  if (other.mutableFileChunkErrorList.count > 0) {
    if (result.mutableFileChunkErrorList == nil) {
      result.mutableFileChunkErrorList = [NSMutableArray array];
    }
    [result.mutableFileChunkErrorList addObjectsFromArray:other.mutableFileChunkErrorList];
  }
  if (other.hasVerbosityLevel) {
    [self setVerbosityLevel:other.verbosityLevel];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileGroups_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileGroups_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        FileChecksumStorageHostChunkLists_Builder* subBuilder = [FileChecksumStorageHostChunkLists builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileGroups:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        FileError_Builder* subBuilder = [FileError builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileError:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        FileChunkError_Builder* subBuilder = [FileChunkError builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChunkError:[subBuilder buildPartial]];
        break;
      }
      case 32: {
        [self setVerbosityLevel:[input readUInt32]];
        break;
      }
    }
  }
}
- (NSArray*) fileGroupsList {
  if (result.mutableFileGroupsList == nil) { return [NSArray array]; }
  return result.mutableFileGroupsList;
}
- (FileChecksumStorageHostChunkLists*) fileGroupsAtIndex:(int32_t) index {
  return [result fileGroupsAtIndex:index];
}
- (FileGroups_Builder*) replaceFileGroupsAtIndex:(int32_t) index with:(FileChecksumStorageHostChunkLists*) value {
  [result.mutableFileGroupsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileGroups_Builder*) addAllFileGroups:(NSArray*) values {
  if (result.mutableFileGroupsList == nil) {
    result.mutableFileGroupsList = [NSMutableArray array];
  }
  [result.mutableFileGroupsList addObjectsFromArray:values];
  return self;
}
- (FileGroups_Builder*) clearFileGroupsList {
  result.mutableFileGroupsList = nil;
  return self;
}
- (FileGroups_Builder*) addFileGroups:(FileChecksumStorageHostChunkLists*) value {
  if (result.mutableFileGroupsList == nil) {
    result.mutableFileGroupsList = [NSMutableArray array];
  }
  [result.mutableFileGroupsList addObject:value];
  return self;
}
- (NSArray*) fileErrorList {
  if (result.mutableFileErrorList == nil) { return [NSArray array]; }
  return result.mutableFileErrorList;
}
- (FileError*) fileErrorAtIndex:(int32_t) index {
  return [result fileErrorAtIndex:index];
}
- (FileGroups_Builder*) replaceFileErrorAtIndex:(int32_t) index with:(FileError*) value {
  [result.mutableFileErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileGroups_Builder*) addAllFileError:(NSArray*) values {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObjectsFromArray:values];
  return self;
}
- (FileGroups_Builder*) clearFileErrorList {
  result.mutableFileErrorList = nil;
  return self;
}
- (FileGroups_Builder*) addFileError:(FileError*) value {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObject:value];
  return self;
}
- (NSArray*) fileChunkErrorList {
  if (result.mutableFileChunkErrorList == nil) { return [NSArray array]; }
  return result.mutableFileChunkErrorList;
}
- (FileChunkError*) fileChunkErrorAtIndex:(int32_t) index {
  return [result fileChunkErrorAtIndex:index];
}
- (FileGroups_Builder*) replaceFileChunkErrorAtIndex:(int32_t) index with:(FileChunkError*) value {
  [result.mutableFileChunkErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileGroups_Builder*) addAllFileChunkError:(NSArray*) values {
  if (result.mutableFileChunkErrorList == nil) {
    result.mutableFileChunkErrorList = [NSMutableArray array];
  }
  [result.mutableFileChunkErrorList addObjectsFromArray:values];
  return self;
}
- (FileGroups_Builder*) clearFileChunkErrorList {
  result.mutableFileChunkErrorList = nil;
  return self;
}
- (FileGroups_Builder*) addFileChunkError:(FileChunkError*) value {
  if (result.mutableFileChunkErrorList == nil) {
    result.mutableFileChunkErrorList = [NSMutableArray array];
  }
  [result.mutableFileChunkErrorList addObject:value];
  return self;
}
- (BOOL) hasVerbosityLevel {
  return result.hasVerbosityLevel;
}
- (int32_t) verbosityLevel {
  return result.verbosityLevel;
}
- (FileGroups_Builder*) setVerbosityLevel:(int32_t) value {
  result.hasVerbosityLevel = YES;
  result.verbosityLevel = value;
  return self;
}
- (FileGroups_Builder*) clearVerbosityLevel {
  result.hasVerbosityLevel = NO;
  result.verbosityLevel = 0;
  return self;
}
@end

@interface ChunkChecksumList ()
@property (retain) NSMutableArray* mutableChunkChecksumList;
@end

@implementation ChunkChecksumList

@synthesize mutableChunkChecksumList;
- (void) dealloc {
  self.mutableChunkChecksumList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static ChunkChecksumList* defaultChunkChecksumListInstance = nil;
+ (void) initialize {
  if (self == [ChunkChecksumList class]) {
    defaultChunkChecksumListInstance = [[ChunkChecksumList alloc] init];
  }
}
+ (ChunkChecksumList*) defaultInstance {
  return defaultChunkChecksumListInstance;
}
- (ChunkChecksumList*) defaultInstance {
  return defaultChunkChecksumListInstance;
}
- (NSArray*) chunkChecksumList {
  return mutableChunkChecksumList;
}
- (NSData*) chunkChecksumAtIndex:(int32_t) index {
  id value = [mutableChunkChecksumList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (NSData* element in self.mutableChunkChecksumList) {
    [output writeData:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableChunkChecksumList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableChunkChecksumList.count;
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkChecksumList*) parseFromData:(NSData*) data {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeFromData:data] build];
}
+ (ChunkChecksumList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkChecksumList*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeFromInputStream:input] build];
}
+ (ChunkChecksumList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeDelimitedFromInputStream:input] build];
}
+ (ChunkChecksumList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkChecksumList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkChecksumList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkChecksumList*)[[[ChunkChecksumList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkChecksumList_Builder*) builder {
  return [[[ChunkChecksumList_Builder alloc] init] autorelease];
}
+ (ChunkChecksumList_Builder*) builderWithPrototype:(ChunkChecksumList*) prototype {
  return [[ChunkChecksumList builder] mergeFrom:prototype];
}
- (ChunkChecksumList_Builder*) builder {
  return [ChunkChecksumList builder];
}
@end

@interface ChunkChecksumList_Builder()
@property (retain) ChunkChecksumList* result;
@end

@implementation ChunkChecksumList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkChecksumList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkChecksumList_Builder*) clear {
  self.result = [[[ChunkChecksumList alloc] init] autorelease];
  return self;
}
- (ChunkChecksumList_Builder*) clone {
  return [ChunkChecksumList builderWithPrototype:result];
}
- (ChunkChecksumList*) defaultInstance {
  return [ChunkChecksumList defaultInstance];
}
- (ChunkChecksumList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkChecksumList*) buildPartial {
  ChunkChecksumList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkChecksumList_Builder*) mergeFrom:(ChunkChecksumList*) other {
  if (other == [ChunkChecksumList defaultInstance]) {
    return self;
  }
  if (other.mutableChunkChecksumList.count > 0) {
    if (result.mutableChunkChecksumList == nil) {
      result.mutableChunkChecksumList = [NSMutableArray array];
    }
    [result.mutableChunkChecksumList addObjectsFromArray:other.mutableChunkChecksumList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkChecksumList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkChecksumList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self addChunkChecksum:[input readData]];
        break;
      }
    }
  }
}
- (NSArray*) chunkChecksumList {
  if (result.mutableChunkChecksumList == nil) {
    return [NSArray array];
  }
  return result.mutableChunkChecksumList;
}
- (NSData*) chunkChecksumAtIndex:(int32_t) index {
  return [result chunkChecksumAtIndex:index];
}
- (ChunkChecksumList_Builder*) replaceChunkChecksumAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableChunkChecksumList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (ChunkChecksumList_Builder*) addChunkChecksum:(NSData*) value {
  if (result.mutableChunkChecksumList == nil) {
    result.mutableChunkChecksumList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumList addObject:value];
  return self;
}
- (ChunkChecksumList_Builder*) addAllChunkChecksum:(NSArray*) values {
  if (result.mutableChunkChecksumList == nil) {
    result.mutableChunkChecksumList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumList addObjectsFromArray:values];
  return self;
}
- (ChunkChecksumList_Builder*) clearChunkChecksumList {
  result.mutableChunkChecksumList = nil;
  return self;
}
@end

@interface StorageHostChunkList ()
@property (retain) HostInfo* hostInfo;
@property (retain) NSMutableArray* mutableChunkInfoList;
@property (retain) NSString* storageContainerKey;
@property (retain) NSString* storageContainerAuthorizationToken;
@end

@implementation StorageHostChunkList

- (BOOL) hasHostInfo {
  return !!hasHostInfo_;
}
- (void) setHasHostInfo:(BOOL) value {
  hasHostInfo_ = !!value;
}
@synthesize hostInfo;
@synthesize mutableChunkInfoList;
- (BOOL) hasStorageContainerKey {
  return !!hasStorageContainerKey_;
}
- (void) setHasStorageContainerKey:(BOOL) value {
  hasStorageContainerKey_ = !!value;
}
@synthesize storageContainerKey;
- (BOOL) hasStorageContainerAuthorizationToken {
  return !!hasStorageContainerAuthorizationToken_;
}
- (void) setHasStorageContainerAuthorizationToken:(BOOL) value {
  hasStorageContainerAuthorizationToken_ = !!value;
}
@synthesize storageContainerAuthorizationToken;
- (void) dealloc {
  self.hostInfo = nil;
  self.mutableChunkInfoList = nil;
  self.storageContainerKey = nil;
  self.storageContainerAuthorizationToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.hostInfo = [HostInfo defaultInstance];
    self.storageContainerKey = @"";
    self.storageContainerAuthorizationToken = @"";
  }
  return self;
}
static StorageHostChunkList* defaultStorageHostChunkListInstance = nil;
+ (void) initialize {
  if (self == [StorageHostChunkList class]) {
    defaultStorageHostChunkListInstance = [[StorageHostChunkList alloc] init];
  }
}
+ (StorageHostChunkList*) defaultInstance {
  return defaultStorageHostChunkListInstance;
}
- (StorageHostChunkList*) defaultInstance {
  return defaultStorageHostChunkListInstance;
}
- (NSArray*) chunkInfoList {
  return mutableChunkInfoList;
}
- (ChunkInfo*) chunkInfoAtIndex:(int32_t) index {
  id value = [mutableChunkInfoList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasHostInfo) {
    return NO;
  }
  if (!self.hasStorageContainerKey) {
    return NO;
  }
  if (!self.hasStorageContainerAuthorizationToken) {
    return NO;
  }
  if (!self.hostInfo.isInitialized) {
    return NO;
  }
  for (ChunkInfo* element in self.chunkInfoList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasHostInfo) {
    [output writeMessage:1 value:self.hostInfo];
  }
  for (ChunkInfo* element in self.chunkInfoList) {
    [output writeMessage:2 value:element];
  }
  if (self.hasStorageContainerKey) {
    [output writeString:3 value:self.storageContainerKey];
  }
  if (self.hasStorageContainerAuthorizationToken) {
    [output writeString:4 value:self.storageContainerAuthorizationToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasHostInfo) {
    size += computeMessageSize(1, self.hostInfo);
  }
  for (ChunkInfo* element in self.chunkInfoList) {
    size += computeMessageSize(2, element);
  }
  if (self.hasStorageContainerKey) {
    size += computeStringSize(3, self.storageContainerKey);
  }
  if (self.hasStorageContainerAuthorizationToken) {
    size += computeStringSize(4, self.storageContainerAuthorizationToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageHostChunkList*) parseFromData:(NSData*) data {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeFromData:data] build];
}
+ (StorageHostChunkList*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkList*) parseFromInputStream:(NSInputStream*) input {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeFromInputStream:input] build];
}
+ (StorageHostChunkList*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeDelimitedFromInputStream:input] build];
}
+ (StorageHostChunkList*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkList*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeFromCodedInputStream:input] build];
}
+ (StorageHostChunkList*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkList*)[[[StorageHostChunkList builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkList_Builder*) builder {
  return [[[StorageHostChunkList_Builder alloc] init] autorelease];
}
+ (StorageHostChunkList_Builder*) builderWithPrototype:(StorageHostChunkList*) prototype {
  return [[StorageHostChunkList builder] mergeFrom:prototype];
}
- (StorageHostChunkList_Builder*) builder {
  return [StorageHostChunkList builder];
}
@end

@interface StorageHostChunkList_Builder()
@property (retain) StorageHostChunkList* result;
@end

@implementation StorageHostChunkList_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageHostChunkList alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageHostChunkList_Builder*) clear {
  self.result = [[[StorageHostChunkList alloc] init] autorelease];
  return self;
}
- (StorageHostChunkList_Builder*) clone {
  return [StorageHostChunkList builderWithPrototype:result];
}
- (StorageHostChunkList*) defaultInstance {
  return [StorageHostChunkList defaultInstance];
}
- (StorageHostChunkList*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageHostChunkList*) buildPartial {
  StorageHostChunkList* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageHostChunkList_Builder*) mergeFrom:(StorageHostChunkList*) other {
  if (other == [StorageHostChunkList defaultInstance]) {
    return self;
  }
  if (other.hasHostInfo) {
    [self mergeHostInfo:other.hostInfo];
  }
  if (other.mutableChunkInfoList.count > 0) {
    if (result.mutableChunkInfoList == nil) {
      result.mutableChunkInfoList = [NSMutableArray array];
    }
    [result.mutableChunkInfoList addObjectsFromArray:other.mutableChunkInfoList];
  }
  if (other.hasStorageContainerKey) {
    [self setStorageContainerKey:other.storageContainerKey];
  }
  if (other.hasStorageContainerAuthorizationToken) {
    [self setStorageContainerAuthorizationToken:other.storageContainerAuthorizationToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageHostChunkList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageHostChunkList_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        HostInfo_Builder* subBuilder = [HostInfo builder];
        if (self.hasHostInfo) {
          [subBuilder mergeFrom:self.hostInfo];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setHostInfo:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        ChunkInfo_Builder* subBuilder = [ChunkInfo builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkInfo:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        [self setStorageContainerKey:[input readString]];
        break;
      }
      case 34: {
        [self setStorageContainerAuthorizationToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasHostInfo {
  return result.hasHostInfo;
}
- (HostInfo*) hostInfo {
  return result.hostInfo;
}
- (StorageHostChunkList_Builder*) setHostInfo:(HostInfo*) value {
  result.hasHostInfo = YES;
  result.hostInfo = value;
  return self;
}
- (StorageHostChunkList_Builder*) setHostInfoBuilder:(HostInfo_Builder*) builderForValue {
  return [self setHostInfo:[builderForValue build]];
}
- (StorageHostChunkList_Builder*) mergeHostInfo:(HostInfo*) value {
  if (result.hasHostInfo &&
      result.hostInfo != [HostInfo defaultInstance]) {
    result.hostInfo =
      [[[HostInfo builderWithPrototype:result.hostInfo] mergeFrom:value] buildPartial];
  } else {
    result.hostInfo = value;
  }
  result.hasHostInfo = YES;
  return self;
}
- (StorageHostChunkList_Builder*) clearHostInfo {
  result.hasHostInfo = NO;
  result.hostInfo = [HostInfo defaultInstance];
  return self;
}
- (NSArray*) chunkInfoList {
  if (result.mutableChunkInfoList == nil) { return [NSArray array]; }
  return result.mutableChunkInfoList;
}
- (ChunkInfo*) chunkInfoAtIndex:(int32_t) index {
  return [result chunkInfoAtIndex:index];
}
- (StorageHostChunkList_Builder*) replaceChunkInfoAtIndex:(int32_t) index with:(ChunkInfo*) value {
  [result.mutableChunkInfoList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageHostChunkList_Builder*) addAllChunkInfo:(NSArray*) values {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObjectsFromArray:values];
  return self;
}
- (StorageHostChunkList_Builder*) clearChunkInfoList {
  result.mutableChunkInfoList = nil;
  return self;
}
- (StorageHostChunkList_Builder*) addChunkInfo:(ChunkInfo*) value {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObject:value];
  return self;
}
- (BOOL) hasStorageContainerKey {
  return result.hasStorageContainerKey;
}
- (NSString*) storageContainerKey {
  return result.storageContainerKey;
}
- (StorageHostChunkList_Builder*) setStorageContainerKey:(NSString*) value {
  result.hasStorageContainerKey = YES;
  result.storageContainerKey = value;
  return self;
}
- (StorageHostChunkList_Builder*) clearStorageContainerKey {
  result.hasStorageContainerKey = NO;
  result.storageContainerKey = @"";
  return self;
}
- (BOOL) hasStorageContainerAuthorizationToken {
  return result.hasStorageContainerAuthorizationToken;
}
- (NSString*) storageContainerAuthorizationToken {
  return result.storageContainerAuthorizationToken;
}
- (StorageHostChunkList_Builder*) setStorageContainerAuthorizationToken:(NSString*) value {
  result.hasStorageContainerAuthorizationToken = YES;
  result.storageContainerAuthorizationToken = value;
  return self;
}
- (StorageHostChunkList_Builder*) clearStorageContainerAuthorizationToken {
  result.hasStorageContainerAuthorizationToken = NO;
  result.storageContainerAuthorizationToken = @"";
  return self;
}
@end

@interface StorageHostChunkLists ()
@property (retain) NSMutableArray* mutableStorageHostChunkListList;
@property (retain) NSMutableArray* mutableChunkErrorList;
@end

@implementation StorageHostChunkLists

@synthesize mutableStorageHostChunkListList;
@synthesize mutableChunkErrorList;
- (void) dealloc {
  self.mutableStorageHostChunkListList = nil;
  self.mutableChunkErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static StorageHostChunkLists* defaultStorageHostChunkListsInstance = nil;
+ (void) initialize {
  if (self == [StorageHostChunkLists class]) {
    defaultStorageHostChunkListsInstance = [[StorageHostChunkLists alloc] init];
  }
}
+ (StorageHostChunkLists*) defaultInstance {
  return defaultStorageHostChunkListsInstance;
}
- (StorageHostChunkLists*) defaultInstance {
  return defaultStorageHostChunkListsInstance;
}
- (NSArray*) storageHostChunkListList {
  return mutableStorageHostChunkListList;
}
- (StorageHostChunkList*) storageHostChunkListAtIndex:(int32_t) index {
  id value = [mutableStorageHostChunkListList objectAtIndex:index];
  return value;
}
- (NSArray*) chunkErrorList {
  return mutableChunkErrorList;
}
- (ChunkError*) chunkErrorAtIndex:(int32_t) index {
  id value = [mutableChunkErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageHostChunkList* element in self.storageHostChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (ChunkError* element in self.chunkErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageHostChunkList* element in self.storageHostChunkListList) {
    [output writeMessage:1 value:element];
  }
  for (ChunkError* element in self.chunkErrorList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageHostChunkList* element in self.storageHostChunkListList) {
    size += computeMessageSize(1, element);
  }
  for (ChunkError* element in self.chunkErrorList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageHostChunkLists*) parseFromData:(NSData*) data {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeFromData:data] build];
}
+ (StorageHostChunkLists*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkLists*) parseFromInputStream:(NSInputStream*) input {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeFromInputStream:input] build];
}
+ (StorageHostChunkLists*) parseDelimitedFromInputStream:(NSInputStream*) input {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeDelimitedFromInputStream:input] build];
}
+ (StorageHostChunkLists*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeFromCodedInputStream:input] build];
}
+ (StorageHostChunkLists*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkLists*)[[[StorageHostChunkLists builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkLists_Builder*) builder {
  return [[[StorageHostChunkLists_Builder alloc] init] autorelease];
}
+ (StorageHostChunkLists_Builder*) builderWithPrototype:(StorageHostChunkLists*) prototype {
  return [[StorageHostChunkLists builder] mergeFrom:prototype];
}
- (StorageHostChunkLists_Builder*) builder {
  return [StorageHostChunkLists builder];
}
@end

@interface StorageHostChunkLists_Builder()
@property (retain) StorageHostChunkLists* result;
@end

@implementation StorageHostChunkLists_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageHostChunkLists alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageHostChunkLists_Builder*) clear {
  self.result = [[[StorageHostChunkLists alloc] init] autorelease];
  return self;
}
- (StorageHostChunkLists_Builder*) clone {
  return [StorageHostChunkLists builderWithPrototype:result];
}
- (StorageHostChunkLists*) defaultInstance {
  return [StorageHostChunkLists defaultInstance];
}
- (StorageHostChunkLists*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageHostChunkLists*) buildPartial {
  StorageHostChunkLists* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageHostChunkLists_Builder*) mergeFrom:(StorageHostChunkLists*) other {
  if (other == [StorageHostChunkLists defaultInstance]) {
    return self;
  }
  if (other.mutableStorageHostChunkListList.count > 0) {
    if (result.mutableStorageHostChunkListList == nil) {
      result.mutableStorageHostChunkListList = [NSMutableArray array];
    }
    [result.mutableStorageHostChunkListList addObjectsFromArray:other.mutableStorageHostChunkListList];
  }
  if (other.mutableChunkErrorList.count > 0) {
    if (result.mutableChunkErrorList == nil) {
      result.mutableChunkErrorList = [NSMutableArray array];
    }
    [result.mutableChunkErrorList addObjectsFromArray:other.mutableChunkErrorList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageHostChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageHostChunkLists_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageHostChunkList_Builder* subBuilder = [StorageHostChunkList builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageHostChunkList:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        ChunkError_Builder* subBuilder = [ChunkError builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkError:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) storageHostChunkListList {
  if (result.mutableStorageHostChunkListList == nil) { return [NSArray array]; }
  return result.mutableStorageHostChunkListList;
}
- (StorageHostChunkList*) storageHostChunkListAtIndex:(int32_t) index {
  return [result storageHostChunkListAtIndex:index];
}
- (StorageHostChunkLists_Builder*) replaceStorageHostChunkListAtIndex:(int32_t) index with:(StorageHostChunkList*) value {
  [result.mutableStorageHostChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageHostChunkLists_Builder*) addAllStorageHostChunkList:(NSArray*) values {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObjectsFromArray:values];
  return self;
}
- (StorageHostChunkLists_Builder*) clearStorageHostChunkListList {
  result.mutableStorageHostChunkListList = nil;
  return self;
}
- (StorageHostChunkLists_Builder*) addStorageHostChunkList:(StorageHostChunkList*) value {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObject:value];
  return self;
}
- (NSArray*) chunkErrorList {
  if (result.mutableChunkErrorList == nil) { return [NSArray array]; }
  return result.mutableChunkErrorList;
}
- (ChunkError*) chunkErrorAtIndex:(int32_t) index {
  return [result chunkErrorAtIndex:index];
}
- (StorageHostChunkLists_Builder*) replaceChunkErrorAtIndex:(int32_t) index with:(ChunkError*) value {
  [result.mutableChunkErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageHostChunkLists_Builder*) addAllChunkError:(NSArray*) values {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObjectsFromArray:values];
  return self;
}
- (StorageHostChunkLists_Builder*) clearChunkErrorList {
  result.mutableChunkErrorList = nil;
  return self;
}
- (StorageHostChunkLists_Builder*) addChunkError:(ChunkError*) value {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObject:value];
  return self;
}
@end

