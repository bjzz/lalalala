// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Protocol.h"

@implementation ProtocolRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [ProtocolRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface DeviceUdidsL ()
@property (retain) NSString* psid;
@property (retain) NSMutableArray* mutableUdidsList;
@property BOOL usuallyFalse;
@end

@implementation DeviceUdidsL

- (BOOL) hasPsid {
  return !!hasPsid_;
}
- (void) setHasPsid:(BOOL) value {
  hasPsid_ = !!value;
}
@synthesize psid;
@synthesize mutableUdidsList;
- (BOOL) hasUsuallyFalse {
  return !!hasUsuallyFalse_;
}
- (void) setHasUsuallyFalse:(BOOL) value {
  hasUsuallyFalse_ = !!value;
}
- (BOOL) usuallyFalse {
  return !!usuallyFalse_;
}
- (void) setUsuallyFalse:(BOOL) value {
  usuallyFalse_ = !!value;
}
- (void) dealloc {
  self.psid = nil;
  self.mutableUdidsList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.psid = @"";
    self.usuallyFalse = NO;
  }
  return self;
}
static DeviceUdidsL* defaultDeviceUdidsLInstance = nil;
+ (void) initialize {
  if (self == [DeviceUdidsL class]) {
    defaultDeviceUdidsLInstance = [[DeviceUdidsL alloc] init];
  }
}
+ (DeviceUdidsL*) defaultInstance {
  return defaultDeviceUdidsLInstance;
}
- (DeviceUdidsL*) defaultInstance {
  return defaultDeviceUdidsLInstance;
}
- (NSArray*) udidsList {
  return mutableUdidsList;
}
- (NSData*) udidsAtIndex:(int32_t) index {
  id value = [mutableUdidsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasPsid) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasPsid) {
    [output writeString:1 value:self.psid];
  }
  for (NSData* element in self.mutableUdidsList) {
    [output writeData:2 value:element];
  }
  if (self.hasUsuallyFalse) {
    [output writeBool:3 value:self.usuallyFalse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasPsid) {
    size += computeStringSize(1, self.psid);
  }
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableUdidsList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableUdidsList.count;
  }
  if (self.hasUsuallyFalse) {
    size += computeBoolSize(3, self.usuallyFalse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (DeviceUdidsL*) parseFromData:(NSData*) data {
  return (DeviceUdidsL*)[[[DeviceUdidsL builder] mergeFromData:data] build];
}
+ (DeviceUdidsL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceUdidsL*)[[[DeviceUdidsL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (DeviceUdidsL*) parseFromInputStream:(NSInputStream*) input {
  return (DeviceUdidsL*)[[[DeviceUdidsL builder] mergeFromInputStream:input] build];
}
+ (DeviceUdidsL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceUdidsL*)[[[DeviceUdidsL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceUdidsL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (DeviceUdidsL*)[[[DeviceUdidsL builder] mergeFromCodedInputStream:input] build];
}
+ (DeviceUdidsL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceUdidsL*)[[[DeviceUdidsL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceUdidsL_Builder*) builder {
  return [[[DeviceUdidsL_Builder alloc] init] autorelease];
}
+ (DeviceUdidsL_Builder*) builderWithPrototype:(DeviceUdidsL*) prototype {
  return [[DeviceUdidsL builder] mergeFrom:prototype];
}
- (DeviceUdidsL_Builder*) builder {
  return [DeviceUdidsL builder];
}
@end

@interface DeviceUdidsL_Builder()
@property (retain) DeviceUdidsL* result;
@end

@implementation DeviceUdidsL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[DeviceUdidsL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (DeviceUdidsL_Builder*) clear {
  self.result = [[[DeviceUdidsL alloc] init] autorelease];
  return self;
}
- (DeviceUdidsL_Builder*) clone {
  return [DeviceUdidsL builderWithPrototype:result];
}
- (DeviceUdidsL*) defaultInstance {
  return [DeviceUdidsL defaultInstance];
}
- (DeviceUdidsL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (DeviceUdidsL*) buildPartial {
  DeviceUdidsL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (DeviceUdidsL_Builder*) mergeFrom:(DeviceUdidsL*) other {
  if (other == [DeviceUdidsL defaultInstance]) {
    return self;
  }
  if (other.hasPsid) {
    [self setPsid:other.psid];
  }
  if (other.mutableUdidsList.count > 0) {
    if (result.mutableUdidsList == nil) {
      result.mutableUdidsList = [NSMutableArray array];
    }
    [result.mutableUdidsList addObjectsFromArray:other.mutableUdidsList];
  }
  if (other.hasUsuallyFalse) {
    [self setUsuallyFalse:other.usuallyFalse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceUdidsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceUdidsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setPsid:[input readString]];
        break;
      }
      case 18: {
        [self addUdids:[input readData]];
        break;
      }
      case 24: {
        [self setUsuallyFalse:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasPsid {
  return result.hasPsid;
}
- (NSString*) psid {
  return result.psid;
}
- (DeviceUdidsL_Builder*) setPsid:(NSString*) value {
  result.hasPsid = YES;
  result.psid = value;
  return self;
}
- (DeviceUdidsL_Builder*) clearPsid {
  result.hasPsid = NO;
  result.psid = @"";
  return self;
}
- (NSArray*) udidsList {
  if (result.mutableUdidsList == nil) {
    return [NSArray array];
  }
  return result.mutableUdidsList;
}
- (NSData*) udidsAtIndex:(int32_t) index {
  return [result udidsAtIndex:index];
}
- (DeviceUdidsL_Builder*) replaceUdidsAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableUdidsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (DeviceUdidsL_Builder*) addUdids:(NSData*) value {
  if (result.mutableUdidsList == nil) {
    result.mutableUdidsList = [NSMutableArray array];
  }
  [result.mutableUdidsList addObject:value];
  return self;
}
- (DeviceUdidsL_Builder*) addAllUdids:(NSArray*) values {
  if (result.mutableUdidsList == nil) {
    result.mutableUdidsList = [NSMutableArray array];
  }
  [result.mutableUdidsList addObjectsFromArray:values];
  return self;
}
- (DeviceUdidsL_Builder*) clearUdidsList {
  result.mutableUdidsList = nil;
  return self;
}
- (BOOL) hasUsuallyFalse {
  return result.hasUsuallyFalse;
}
- (BOOL) usuallyFalse {
  return result.usuallyFalse;
}
- (DeviceUdidsL_Builder*) setUsuallyFalse:(BOOL) value {
  result.hasUsuallyFalse = YES;
  result.usuallyFalse = value;
  return self;
}
- (DeviceUdidsL_Builder*) clearUsuallyFalse {
  result.hasUsuallyFalse = NO;
  result.usuallyFalse = NO;
  return self;
}
@end

@interface DeviceL ()
@property (retain) NSData* udid;
@property int64_t fullSize;
@property (retain) NSMutableArray* mutableBackupList;
@property (retain) DeviceInfoL* device;
@property int64_t keysLastModified;
@end

@implementation DeviceL

- (BOOL) hasUdid {
  return !!hasUdid_;
}
- (void) setHasUdid:(BOOL) value {
  hasUdid_ = !!value;
}
@synthesize udid;
- (BOOL) hasFullSize {
  return !!hasFullSize_;
}
- (void) setHasFullSize:(BOOL) value {
  hasFullSize_ = !!value;
}
@synthesize fullSize;
@synthesize mutableBackupList;
- (BOOL) hasDevice {
  return !!hasDevice_;
}
- (void) setHasDevice:(BOOL) value {
  hasDevice_ = !!value;
}
@synthesize device;
- (BOOL) hasKeysLastModified {
  return !!hasKeysLastModified_;
}
- (void) setHasKeysLastModified:(BOOL) value {
  hasKeysLastModified_ = !!value;
}
@synthesize keysLastModified;
- (void) dealloc {
  self.udid = nil;
  self.mutableBackupList = nil;
  self.device = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.udid = [NSData data];
    self.fullSize = 0L;
    self.device = [DeviceInfoL defaultInstance];
    self.keysLastModified = 0L;
  }
  return self;
}
static DeviceL* defaultDeviceLInstance = nil;
+ (void) initialize {
  if (self == [DeviceL class]) {
    defaultDeviceLInstance = [[DeviceL alloc] init];
  }
}
+ (DeviceL*) defaultInstance {
  return defaultDeviceLInstance;
}
- (DeviceL*) defaultInstance {
  return defaultDeviceLInstance;
}
- (NSArray*) backupList {
  return mutableBackupList;
}
- (BackupL*) backupAtIndex:(int32_t) index {
  id value = [mutableBackupList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasUdid) {
    return NO;
  }
  if (!self.hasFullSize) {
    return NO;
  }
  if (!self.hasDevice) {
    return NO;
  }
  if (!self.hasKeysLastModified) {
    return NO;
  }
  for (BackupL* element in self.backupList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  if (!self.device.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasUdid) {
    [output writeData:1 value:self.udid];
  }
  if (self.hasFullSize) {
    [output writeInt64:2 value:self.fullSize];
  }
  for (BackupL* element in self.backupList) {
    [output writeMessage:3 value:element];
  }
  if (self.hasDevice) {
    [output writeMessage:4 value:self.device];
  }
  if (self.hasKeysLastModified) {
    [output writeInt64:5 value:self.keysLastModified];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasUdid) {
    size += computeDataSize(1, self.udid);
  }
  if (self.hasFullSize) {
    size += computeInt64Size(2, self.fullSize);
  }
  for (BackupL* element in self.backupList) {
    size += computeMessageSize(3, element);
  }
  if (self.hasDevice) {
    size += computeMessageSize(4, self.device);
  }
  if (self.hasKeysLastModified) {
    size += computeInt64Size(5, self.keysLastModified);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (DeviceL*) parseFromData:(NSData*) data {
  return (DeviceL*)[[[DeviceL builder] mergeFromData:data] build];
}
+ (DeviceL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceL*)[[[DeviceL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (DeviceL*) parseFromInputStream:(NSInputStream*) input {
  return (DeviceL*)[[[DeviceL builder] mergeFromInputStream:input] build];
}
+ (DeviceL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceL*)[[[DeviceL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (DeviceL*)[[[DeviceL builder] mergeFromCodedInputStream:input] build];
}
+ (DeviceL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceL*)[[[DeviceL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceL_Builder*) builder {
  return [[[DeviceL_Builder alloc] init] autorelease];
}
+ (DeviceL_Builder*) builderWithPrototype:(DeviceL*) prototype {
  return [[DeviceL builder] mergeFrom:prototype];
}
- (DeviceL_Builder*) builder {
  return [DeviceL builder];
}
@end

@interface DeviceL_Builder()
@property (retain) DeviceL* result;
@end

@implementation DeviceL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[DeviceL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (DeviceL_Builder*) clear {
  self.result = [[[DeviceL alloc] init] autorelease];
  return self;
}
- (DeviceL_Builder*) clone {
  return [DeviceL builderWithPrototype:result];
}
- (DeviceL*) defaultInstance {
  return [DeviceL defaultInstance];
}
- (DeviceL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (DeviceL*) buildPartial {
  DeviceL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (DeviceL_Builder*) mergeFrom:(DeviceL*) other {
  if (other == [DeviceL defaultInstance]) {
    return self;
  }
  if (other.hasUdid) {
    [self setUdid:other.udid];
  }
  if (other.hasFullSize) {
    [self setFullSize:other.fullSize];
  }
  if (other.mutableBackupList.count > 0) {
    if (result.mutableBackupList == nil) {
      result.mutableBackupList = [NSMutableArray array];
    }
    [result.mutableBackupList addObjectsFromArray:other.mutableBackupList];
  }
  if (other.hasDevice) {
    [self mergeDevice:other.device];
  }
  if (other.hasKeysLastModified) {
    [self setKeysLastModified:other.keysLastModified];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setUdid:[input readData]];
        break;
      }
      case 16: {
        [self setFullSize:[input readInt64]];
        break;
      }
      case 26: {
        BackupL_Builder* subBuilder = [BackupL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addBackup:[subBuilder buildPartial]];
        break;
      }
      case 34: {
        DeviceInfoL_Builder* subBuilder = [DeviceInfoL builder];
        if (self.hasDevice) {
          [subBuilder mergeFrom:self.device];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setDevice:[subBuilder buildPartial]];
        break;
      }
      case 40: {
        [self setKeysLastModified:[input readInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasUdid {
  return result.hasUdid;
}
- (NSData*) udid {
  return result.udid;
}
- (DeviceL_Builder*) setUdid:(NSData*) value {
  result.hasUdid = YES;
  result.udid = value;
  return self;
}
- (DeviceL_Builder*) clearUdid {
  result.hasUdid = NO;
  result.udid = [NSData data];
  return self;
}
- (BOOL) hasFullSize {
  return result.hasFullSize;
}
- (int64_t) fullSize {
  return result.fullSize;
}
- (DeviceL_Builder*) setFullSize:(int64_t) value {
  result.hasFullSize = YES;
  result.fullSize = value;
  return self;
}
- (DeviceL_Builder*) clearFullSize {
  result.hasFullSize = NO;
  result.fullSize = 0L;
  return self;
}
- (NSArray*) backupList {
  if (result.mutableBackupList == nil) { return [NSArray array]; }
  return result.mutableBackupList;
}
- (BackupL*) backupAtIndex:(int32_t) index {
  return [result backupAtIndex:index];
}
- (DeviceL_Builder*) replaceBackupAtIndex:(int32_t) index with:(BackupL*) value {
  [result.mutableBackupList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (DeviceL_Builder*) addAllBackup:(NSArray*) values {
  if (result.mutableBackupList == nil) {
    result.mutableBackupList = [NSMutableArray array];
  }
  [result.mutableBackupList addObjectsFromArray:values];
  return self;
}
- (DeviceL_Builder*) clearBackupList {
  result.mutableBackupList = nil;
  return self;
}
- (DeviceL_Builder*) addBackup:(BackupL*) value {
  if (result.mutableBackupList == nil) {
    result.mutableBackupList = [NSMutableArray array];
  }
  [result.mutableBackupList addObject:value];
  return self;
}
- (BOOL) hasDevice {
  return result.hasDevice;
}
- (DeviceInfoL*) device {
  return result.device;
}
- (DeviceL_Builder*) setDevice:(DeviceInfoL*) value {
  result.hasDevice = YES;
  result.device = value;
  return self;
}
- (DeviceL_Builder*) setDeviceBuilder:(DeviceInfoL_Builder*) builderForValue {
  return [self setDevice:[builderForValue build]];
}
- (DeviceL_Builder*) mergeDevice:(DeviceInfoL*) value {
  if (result.hasDevice &&
      result.device != [DeviceInfoL defaultInstance]) {
    result.device =
      [[[DeviceInfoL builderWithPrototype:result.device] mergeFrom:value] buildPartial];
  } else {
    result.device = value;
  }
  result.hasDevice = YES;
  return self;
}
- (DeviceL_Builder*) clearDevice {
  result.hasDevice = NO;
  result.device = [DeviceInfoL defaultInstance];
  return self;
}
- (BOOL) hasKeysLastModified {
  return result.hasKeysLastModified;
}
- (int64_t) keysLastModified {
  return result.keysLastModified;
}
- (DeviceL_Builder*) setKeysLastModified:(int64_t) value {
  result.hasKeysLastModified = YES;
  result.keysLastModified = value;
  return self;
}
- (DeviceL_Builder*) clearKeysLastModified {
  result.hasKeysLastModified = NO;
  result.keysLastModified = 0L;
  return self;
}
@end

@interface BackupL ()
@property int32_t snapshotId;
@property int64_t size;
@property int64_t lastModified;
@property (retain) BackupInfoL* info;
@property int64_t committed;
@end

@implementation BackupL

- (BOOL) hasSnapshotId {
  return !!hasSnapshotId_;
}
- (void) setHasSnapshotId:(BOOL) value {
  hasSnapshotId_ = !!value;
}
@synthesize snapshotId;
- (BOOL) hasSize {
  return !!hasSize_;
}
- (void) setHasSize:(BOOL) value {
  hasSize_ = !!value;
}
@synthesize size;
- (BOOL) hasLastModified {
  return !!hasLastModified_;
}
- (void) setHasLastModified:(BOOL) value {
  hasLastModified_ = !!value;
}
@synthesize lastModified;
- (BOOL) hasInfo {
  return !!hasInfo_;
}
- (void) setHasInfo:(BOOL) value {
  hasInfo_ = !!value;
}
@synthesize info;
- (BOOL) hasCommitted {
  return !!hasCommitted_;
}
- (void) setHasCommitted:(BOOL) value {
  hasCommitted_ = !!value;
}
@synthesize committed;
- (void) dealloc {
  self.info = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.snapshotId = 0;
    self.size = 0L;
    self.lastModified = 0L;
    self.info = [BackupInfoL defaultInstance];
    self.committed = 0L;
  }
  return self;
}
static BackupL* defaultBackupLInstance = nil;
+ (void) initialize {
  if (self == [BackupL class]) {
    defaultBackupLInstance = [[BackupL alloc] init];
  }
}
+ (BackupL*) defaultInstance {
  return defaultBackupLInstance;
}
- (BackupL*) defaultInstance {
  return defaultBackupLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasSnapshotId) {
    return NO;
  }
  if (!self.hasSize) {
    return NO;
  }
  if (!self.hasLastModified) {
    return NO;
  }
  if (!self.hasInfo) {
    return NO;
  }
  if (!self.hasCommitted) {
    return NO;
  }
  if (!self.info.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasSnapshotId) {
    [output writeInt32:1 value:self.snapshotId];
  }
  if (self.hasSize) {
    [output writeInt64:2 value:self.size];
  }
  if (self.hasLastModified) {
    [output writeInt64:3 value:self.lastModified];
  }
  if (self.hasInfo) {
    [output writeMessage:5 value:self.info];
  }
  if (self.hasCommitted) {
    [output writeInt64:6 value:self.committed];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasSnapshotId) {
    size += computeInt32Size(1, self.snapshotId);
  }
  if (self.hasSize) {
    size += computeInt64Size(2, self.size);
  }
  if (self.hasLastModified) {
    size += computeInt64Size(3, self.lastModified);
  }
  if (self.hasInfo) {
    size += computeMessageSize(5, self.info);
  }
  if (self.hasCommitted) {
    size += computeInt64Size(6, self.committed);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (BackupL*) parseFromData:(NSData*) data {
  return (BackupL*)[[[BackupL builder] mergeFromData:data] build];
}
+ (BackupL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BackupL*)[[[BackupL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BackupL*) parseFromInputStream:(NSInputStream*) input {
  return (BackupL*)[[[BackupL builder] mergeFromInputStream:input] build];
}
+ (BackupL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BackupL*)[[[BackupL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BackupL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BackupL*)[[[BackupL builder] mergeFromCodedInputStream:input] build];
}
+ (BackupL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BackupL*)[[[BackupL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BackupL_Builder*) builder {
  return [[[BackupL_Builder alloc] init] autorelease];
}
+ (BackupL_Builder*) builderWithPrototype:(BackupL*) prototype {
  return [[BackupL builder] mergeFrom:prototype];
}
- (BackupL_Builder*) builder {
  return [BackupL builder];
}
@end

@interface BackupL_Builder()
@property (retain) BackupL* result;
@end

@implementation BackupL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[BackupL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (BackupL_Builder*) clear {
  self.result = [[[BackupL alloc] init] autorelease];
  return self;
}
- (BackupL_Builder*) clone {
  return [BackupL builderWithPrototype:result];
}
- (BackupL*) defaultInstance {
  return [BackupL defaultInstance];
}
- (BackupL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BackupL*) buildPartial {
  BackupL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (BackupL_Builder*) mergeFrom:(BackupL*) other {
  if (other == [BackupL defaultInstance]) {
    return self;
  }
  if (other.hasSnapshotId) {
    [self setSnapshotId:other.snapshotId];
  }
  if (other.hasSize) {
    [self setSize:other.size];
  }
  if (other.hasLastModified) {
    [self setLastModified:other.lastModified];
  }
  if (other.hasInfo) {
    [self mergeInfo:other.info];
  }
  if (other.hasCommitted) {
    [self setCommitted:other.committed];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BackupL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BackupL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setSnapshotId:[input readInt32]];
        break;
      }
      case 16: {
        [self setSize:[input readInt64]];
        break;
      }
      case 24: {
        [self setLastModified:[input readInt64]];
        break;
      }
      case 42: {
        BackupInfoL_Builder* subBuilder = [BackupInfoL builder];
        if (self.hasInfo) {
          [subBuilder mergeFrom:self.info];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setInfo:[subBuilder buildPartial]];
        break;
      }
      case 48: {
        [self setCommitted:[input readInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasSnapshotId {
  return result.hasSnapshotId;
}
- (int32_t) snapshotId {
  return result.snapshotId;
}
- (BackupL_Builder*) setSnapshotId:(int32_t) value {
  result.hasSnapshotId = YES;
  result.snapshotId = value;
  return self;
}
- (BackupL_Builder*) clearSnapshotId {
  result.hasSnapshotId = NO;
  result.snapshotId = 0;
  return self;
}
- (BOOL) hasSize {
  return result.hasSize;
}
- (int64_t) size {
  return result.size;
}
- (BackupL_Builder*) setSize:(int64_t) value {
  result.hasSize = YES;
  result.size = value;
  return self;
}
- (BackupL_Builder*) clearSize {
  result.hasSize = NO;
  result.size = 0L;
  return self;
}
- (BOOL) hasLastModified {
  return result.hasLastModified;
}
- (int64_t) lastModified {
  return result.lastModified;
}
- (BackupL_Builder*) setLastModified:(int64_t) value {
  result.hasLastModified = YES;
  result.lastModified = value;
  return self;
}
- (BackupL_Builder*) clearLastModified {
  result.hasLastModified = NO;
  result.lastModified = 0L;
  return self;
}
- (BOOL) hasInfo {
  return result.hasInfo;
}
- (BackupInfoL*) info {
  return result.info;
}
- (BackupL_Builder*) setInfo:(BackupInfoL*) value {
  result.hasInfo = YES;
  result.info = value;
  return self;
}
- (BackupL_Builder*) setInfoBuilder:(BackupInfoL_Builder*) builderForValue {
  return [self setInfo:[builderForValue build]];
}
- (BackupL_Builder*) mergeInfo:(BackupInfoL*) value {
  if (result.hasInfo &&
      result.info != [BackupInfoL defaultInstance]) {
    result.info =
      [[[BackupInfoL builderWithPrototype:result.info] mergeFrom:value] buildPartial];
  } else {
    result.info = value;
  }
  result.hasInfo = YES;
  return self;
}
- (BackupL_Builder*) clearInfo {
  result.hasInfo = NO;
  result.info = [BackupInfoL defaultInstance];
  return self;
}
- (BOOL) hasCommitted {
  return result.hasCommitted;
}
- (int64_t) committed {
  return result.committed;
}
- (BackupL_Builder*) setCommitted:(int64_t) value {
  result.hasCommitted = YES;
  result.committed = value;
  return self;
}
- (BackupL_Builder*) clearCommitted {
  result.hasCommitted = NO;
  result.committed = 0L;
  return self;
}
@end

@interface BackupInfoL ()
@property (retain) NSString* name;
@property (retain) NSString* firmware;
@property (retain) NSString* buildEx;
@property int32_t usually21;
@property (retain) NSData* idk;
@property int32_t usually22;
@property int32_t usually1;
@end

@implementation BackupInfoL

- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value {
  hasName_ = !!value;
}
@synthesize name;
- (BOOL) hasFirmware {
  return !!hasFirmware_;
}
- (void) setHasFirmware:(BOOL) value {
  hasFirmware_ = !!value;
}
@synthesize firmware;
- (BOOL) hasBuildEx {
  return !!hasBuildEx_;
}
- (void) setHasBuildEx:(BOOL) value {
  hasBuildEx_ = !!value;
}
@synthesize buildEx;
- (BOOL) hasUsually21 {
  return !!hasUsually21_;
}
- (void) setHasUsually21:(BOOL) value {
  hasUsually21_ = !!value;
}
@synthesize usually21;
- (BOOL) hasIdk {
  return !!hasIdk_;
}
- (void) setHasIdk:(BOOL) value {
  hasIdk_ = !!value;
}
@synthesize idk;
- (BOOL) hasUsually22 {
  return !!hasUsually22_;
}
- (void) setHasUsually22:(BOOL) value {
  hasUsually22_ = !!value;
}
@synthesize usually22;
- (BOOL) hasUsually1 {
  return !!hasUsually1_;
}
- (void) setHasUsually1:(BOOL) value {
  hasUsually1_ = !!value;
}
@synthesize usually1;
- (void) dealloc {
  self.name = nil;
  self.firmware = nil;
  self.buildEx = nil;
  self.idk = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.name = @"";
    self.firmware = @"";
    self.buildEx = @"";
    self.usually21 = 0;
    self.idk = [NSData data];
    self.usually22 = 0;
    self.usually1 = 0;
  }
  return self;
}
static BackupInfoL* defaultBackupInfoLInstance = nil;
+ (void) initialize {
  if (self == [BackupInfoL class]) {
    defaultBackupInfoLInstance = [[BackupInfoL alloc] init];
  }
}
+ (BackupInfoL*) defaultInstance {
  return defaultBackupInfoLInstance;
}
- (BackupInfoL*) defaultInstance {
  return defaultBackupInfoLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasName) {
    return NO;
  }
  if (!self.hasFirmware) {
    return NO;
  }
  if (!self.hasBuildEx) {
    return NO;
  }
  if (!self.hasUsually21) {
    return NO;
  }
  if (!self.hasIdk) {
    return NO;
  }
  if (!self.hasUsually22) {
    return NO;
  }
  if (!self.hasUsually1) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasName) {
    [output writeString:1 value:self.name];
  }
  if (self.hasFirmware) {
    [output writeString:2 value:self.firmware];
  }
  if (self.hasBuildEx) {
    [output writeString:3 value:self.buildEx];
  }
  if (self.hasUsually21) {
    [output writeInt32:4 value:self.usually21];
  }
  if (self.hasIdk) {
    [output writeData:5 value:self.idk];
  }
  if (self.hasUsually22) {
    [output writeInt32:6 value:self.usually22];
  }
  if (self.hasUsually1) {
    [output writeInt32:7 value:self.usually1];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasName) {
    size += computeStringSize(1, self.name);
  }
  if (self.hasFirmware) {
    size += computeStringSize(2, self.firmware);
  }
  if (self.hasBuildEx) {
    size += computeStringSize(3, self.buildEx);
  }
  if (self.hasUsually21) {
    size += computeInt32Size(4, self.usually21);
  }
  if (self.hasIdk) {
    size += computeDataSize(5, self.idk);
  }
  if (self.hasUsually22) {
    size += computeInt32Size(6, self.usually22);
  }
  if (self.hasUsually1) {
    size += computeInt32Size(7, self.usually1);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (BackupInfoL*) parseFromData:(NSData*) data {
  return (BackupInfoL*)[[[BackupInfoL builder] mergeFromData:data] build];
}
+ (BackupInfoL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BackupInfoL*)[[[BackupInfoL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BackupInfoL*) parseFromInputStream:(NSInputStream*) input {
  return (BackupInfoL*)[[[BackupInfoL builder] mergeFromInputStream:input] build];
}
+ (BackupInfoL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BackupInfoL*)[[[BackupInfoL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BackupInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BackupInfoL*)[[[BackupInfoL builder] mergeFromCodedInputStream:input] build];
}
+ (BackupInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BackupInfoL*)[[[BackupInfoL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BackupInfoL_Builder*) builder {
  return [[[BackupInfoL_Builder alloc] init] autorelease];
}
+ (BackupInfoL_Builder*) builderWithPrototype:(BackupInfoL*) prototype {
  return [[BackupInfoL builder] mergeFrom:prototype];
}
- (BackupInfoL_Builder*) builder {
  return [BackupInfoL builder];
}
@end

@interface BackupInfoL_Builder()
@property (retain) BackupInfoL* result;
@end

@implementation BackupInfoL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[BackupInfoL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (BackupInfoL_Builder*) clear {
  self.result = [[[BackupInfoL alloc] init] autorelease];
  return self;
}
- (BackupInfoL_Builder*) clone {
  return [BackupInfoL builderWithPrototype:result];
}
- (BackupInfoL*) defaultInstance {
  return [BackupInfoL defaultInstance];
}
- (BackupInfoL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BackupInfoL*) buildPartial {
  BackupInfoL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (BackupInfoL_Builder*) mergeFrom:(BackupInfoL*) other {
  if (other == [BackupInfoL defaultInstance]) {
    return self;
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasFirmware) {
    [self setFirmware:other.firmware];
  }
  if (other.hasBuildEx) {
    [self setBuildEx:other.buildEx];
  }
  if (other.hasUsually21) {
    [self setUsually21:other.usually21];
  }
  if (other.hasIdk) {
    [self setIdk:other.idk];
  }
  if (other.hasUsually22) {
    [self setUsually22:other.usually22];
  }
  if (other.hasUsually1) {
    [self setUsually1:other.usually1];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BackupInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BackupInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setName:[input readString]];
        break;
      }
      case 18: {
        [self setFirmware:[input readString]];
        break;
      }
      case 26: {
        [self setBuildEx:[input readString]];
        break;
      }
      case 32: {
        [self setUsually21:[input readInt32]];
        break;
      }
      case 42: {
        [self setIdk:[input readData]];
        break;
      }
      case 48: {
        [self setUsually22:[input readInt32]];
        break;
      }
      case 56: {
        [self setUsually1:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasName {
  return result.hasName;
}
- (NSString*) name {
  return result.name;
}
- (BackupInfoL_Builder*) setName:(NSString*) value {
  result.hasName = YES;
  result.name = value;
  return self;
}
- (BackupInfoL_Builder*) clearName {
  result.hasName = NO;
  result.name = @"";
  return self;
}
- (BOOL) hasFirmware {
  return result.hasFirmware;
}
- (NSString*) firmware {
  return result.firmware;
}
- (BackupInfoL_Builder*) setFirmware:(NSString*) value {
  result.hasFirmware = YES;
  result.firmware = value;
  return self;
}
- (BackupInfoL_Builder*) clearFirmware {
  result.hasFirmware = NO;
  result.firmware = @"";
  return self;
}
- (BOOL) hasBuildEx {
  return result.hasBuildEx;
}
- (NSString*) buildEx {
  return result.buildEx;
}
- (BackupInfoL_Builder*) setBuildEx:(NSString*) value {
  result.hasBuildEx = YES;
  result.buildEx = value;
  return self;
}
- (BackupInfoL_Builder*) clearBuildEx {
  result.hasBuildEx = NO;
  result.buildEx = @"";
  return self;
}
- (BOOL) hasUsually21 {
  return result.hasUsually21;
}
- (int32_t) usually21 {
  return result.usually21;
}
- (BackupInfoL_Builder*) setUsually21:(int32_t) value {
  result.hasUsually21 = YES;
  result.usually21 = value;
  return self;
}
- (BackupInfoL_Builder*) clearUsually21 {
  result.hasUsually21 = NO;
  result.usually21 = 0;
  return self;
}
- (BOOL) hasIdk {
  return result.hasIdk;
}
- (NSData*) idk {
  return result.idk;
}
- (BackupInfoL_Builder*) setIdk:(NSData*) value {
  result.hasIdk = YES;
  result.idk = value;
  return self;
}
- (BackupInfoL_Builder*) clearIdk {
  result.hasIdk = NO;
  result.idk = [NSData data];
  return self;
}
- (BOOL) hasUsually22 {
  return result.hasUsually22;
}
- (int32_t) usually22 {
  return result.usually22;
}
- (BackupInfoL_Builder*) setUsually22:(int32_t) value {
  result.hasUsually22 = YES;
  result.usually22 = value;
  return self;
}
- (BackupInfoL_Builder*) clearUsually22 {
  result.hasUsually22 = NO;
  result.usually22 = 0;
  return self;
}
- (BOOL) hasUsually1 {
  return result.hasUsually1;
}
- (int32_t) usually1 {
  return result.usually1;
}
- (BackupInfoL_Builder*) setUsually1:(int32_t) value {
  result.hasUsually1 = YES;
  result.usually1 = value;
  return self;
}
- (BackupInfoL_Builder*) clearUsually1 {
  result.hasUsually1 = NO;
  result.usually1 = 0;
  return self;
}
@end

@interface DeviceInfoL ()
@property (retain) NSString* deviceClass;
@property (retain) NSString* productType;
@property (retain) NSString* serialNumber;
@property (retain) NSString* deviceColor;
@property (retain) NSString* hardwareModel;
@property (retain) NSString* marketingName;
@end

@implementation DeviceInfoL

- (BOOL) hasDeviceClass {
  return !!hasDeviceClass_;
}
- (void) setHasDeviceClass:(BOOL) value {
  hasDeviceClass_ = !!value;
}
@synthesize deviceClass;
- (BOOL) hasProductType {
  return !!hasProductType_;
}
- (void) setHasProductType:(BOOL) value {
  hasProductType_ = !!value;
}
@synthesize productType;
- (BOOL) hasSerialNumber {
  return !!hasSerialNumber_;
}
- (void) setHasSerialNumber:(BOOL) value {
  hasSerialNumber_ = !!value;
}
@synthesize serialNumber;
- (BOOL) hasDeviceColor {
  return !!hasDeviceColor_;
}
- (void) setHasDeviceColor:(BOOL) value {
  hasDeviceColor_ = !!value;
}
@synthesize deviceColor;
- (BOOL) hasHardwareModel {
  return !!hasHardwareModel_;
}
- (void) setHasHardwareModel:(BOOL) value {
  hasHardwareModel_ = !!value;
}
@synthesize hardwareModel;
- (BOOL) hasMarketingName {
  return !!hasMarketingName_;
}
- (void) setHasMarketingName:(BOOL) value {
  hasMarketingName_ = !!value;
}
@synthesize marketingName;
- (void) dealloc {
  self.deviceClass = nil;
  self.productType = nil;
  self.serialNumber = nil;
  self.deviceColor = nil;
  self.hardwareModel = nil;
  self.marketingName = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.deviceClass = @"";
    self.productType = @"";
    self.serialNumber = @"";
    self.deviceColor = @"";
    self.hardwareModel = @"";
    self.marketingName = @"";
  }
  return self;
}
static DeviceInfoL* defaultDeviceInfoLInstance = nil;
+ (void) initialize {
  if (self == [DeviceInfoL class]) {
    defaultDeviceInfoLInstance = [[DeviceInfoL alloc] init];
  }
}
+ (DeviceInfoL*) defaultInstance {
  return defaultDeviceInfoLInstance;
}
- (DeviceInfoL*) defaultInstance {
  return defaultDeviceInfoLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasDeviceClass) {
    return NO;
  }
  if (!self.hasProductType) {
    return NO;
  }
  if (!self.hasSerialNumber) {
    return NO;
  }
  if (!self.hasDeviceColor) {
    return NO;
  }
  if (!self.hasHardwareModel) {
    return NO;
  }
  if (!self.hasMarketingName) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasDeviceClass) {
    [output writeString:1 value:self.deviceClass];
  }
  if (self.hasProductType) {
    [output writeString:2 value:self.productType];
  }
  if (self.hasSerialNumber) {
    [output writeString:3 value:self.serialNumber];
  }
  if (self.hasDeviceColor) {
    [output writeString:4 value:self.deviceColor];
  }
  if (self.hasHardwareModel) {
    [output writeString:5 value:self.hardwareModel];
  }
  if (self.hasMarketingName) {
    [output writeString:6 value:self.marketingName];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasDeviceClass) {
    size += computeStringSize(1, self.deviceClass);
  }
  if (self.hasProductType) {
    size += computeStringSize(2, self.productType);
  }
  if (self.hasSerialNumber) {
    size += computeStringSize(3, self.serialNumber);
  }
  if (self.hasDeviceColor) {
    size += computeStringSize(4, self.deviceColor);
  }
  if (self.hasHardwareModel) {
    size += computeStringSize(5, self.hardwareModel);
  }
  if (self.hasMarketingName) {
    size += computeStringSize(6, self.marketingName);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (DeviceInfoL*) parseFromData:(NSData*) data {
  return (DeviceInfoL*)[[[DeviceInfoL builder] mergeFromData:data] build];
}
+ (DeviceInfoL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceInfoL*)[[[DeviceInfoL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (DeviceInfoL*) parseFromInputStream:(NSInputStream*) input {
  return (DeviceInfoL*)[[[DeviceInfoL builder] mergeFromInputStream:input] build];
}
+ (DeviceInfoL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceInfoL*)[[[DeviceInfoL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (DeviceInfoL*)[[[DeviceInfoL builder] mergeFromCodedInputStream:input] build];
}
+ (DeviceInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (DeviceInfoL*)[[[DeviceInfoL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (DeviceInfoL_Builder*) builder {
  return [[[DeviceInfoL_Builder alloc] init] autorelease];
}
+ (DeviceInfoL_Builder*) builderWithPrototype:(DeviceInfoL*) prototype {
  return [[DeviceInfoL builder] mergeFrom:prototype];
}
- (DeviceInfoL_Builder*) builder {
  return [DeviceInfoL builder];
}
@end

@interface DeviceInfoL_Builder()
@property (retain) DeviceInfoL* result;
@end

@implementation DeviceInfoL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[DeviceInfoL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (DeviceInfoL_Builder*) clear {
  self.result = [[[DeviceInfoL alloc] init] autorelease];
  return self;
}
- (DeviceInfoL_Builder*) clone {
  return [DeviceInfoL builderWithPrototype:result];
}
- (DeviceInfoL*) defaultInstance {
  return [DeviceInfoL defaultInstance];
}
- (DeviceInfoL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (DeviceInfoL*) buildPartial {
  DeviceInfoL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (DeviceInfoL_Builder*) mergeFrom:(DeviceInfoL*) other {
  if (other == [DeviceInfoL defaultInstance]) {
    return self;
  }
  if (other.hasDeviceClass) {
    [self setDeviceClass:other.deviceClass];
  }
  if (other.hasProductType) {
    [self setProductType:other.productType];
  }
  if (other.hasSerialNumber) {
    [self setSerialNumber:other.serialNumber];
  }
  if (other.hasDeviceColor) {
    [self setDeviceColor:other.deviceColor];
  }
  if (other.hasHardwareModel) {
    [self setHardwareModel:other.hardwareModel];
  }
  if (other.hasMarketingName) {
    [self setMarketingName:other.marketingName];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (DeviceInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (DeviceInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setDeviceClass:[input readString]];
        break;
      }
      case 18: {
        [self setProductType:[input readString]];
        break;
      }
      case 26: {
        [self setSerialNumber:[input readString]];
        break;
      }
      case 34: {
        [self setDeviceColor:[input readString]];
        break;
      }
      case 42: {
        [self setHardwareModel:[input readString]];
        break;
      }
      case 50: {
        [self setMarketingName:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasDeviceClass {
  return result.hasDeviceClass;
}
- (NSString*) deviceClass {
  return result.deviceClass;
}
- (DeviceInfoL_Builder*) setDeviceClass:(NSString*) value {
  result.hasDeviceClass = YES;
  result.deviceClass = value;
  return self;
}
- (DeviceInfoL_Builder*) clearDeviceClass {
  result.hasDeviceClass = NO;
  result.deviceClass = @"";
  return self;
}
- (BOOL) hasProductType {
  return result.hasProductType;
}
- (NSString*) productType {
  return result.productType;
}
- (DeviceInfoL_Builder*) setProductType:(NSString*) value {
  result.hasProductType = YES;
  result.productType = value;
  return self;
}
- (DeviceInfoL_Builder*) clearProductType {
  result.hasProductType = NO;
  result.productType = @"";
  return self;
}
- (BOOL) hasSerialNumber {
  return result.hasSerialNumber;
}
- (NSString*) serialNumber {
  return result.serialNumber;
}
- (DeviceInfoL_Builder*) setSerialNumber:(NSString*) value {
  result.hasSerialNumber = YES;
  result.serialNumber = value;
  return self;
}
- (DeviceInfoL_Builder*) clearSerialNumber {
  result.hasSerialNumber = NO;
  result.serialNumber = @"";
  return self;
}
- (BOOL) hasDeviceColor {
  return result.hasDeviceColor;
}
- (NSString*) deviceColor {
  return result.deviceColor;
}
- (DeviceInfoL_Builder*) setDeviceColor:(NSString*) value {
  result.hasDeviceColor = YES;
  result.deviceColor = value;
  return self;
}
- (DeviceInfoL_Builder*) clearDeviceColor {
  result.hasDeviceColor = NO;
  result.deviceColor = @"";
  return self;
}
- (BOOL) hasHardwareModel {
  return result.hasHardwareModel;
}
- (NSString*) hardwareModel {
  return result.hardwareModel;
}
- (DeviceInfoL_Builder*) setHardwareModel:(NSString*) value {
  result.hasHardwareModel = YES;
  result.hardwareModel = value;
  return self;
}
- (DeviceInfoL_Builder*) clearHardwareModel {
  result.hasHardwareModel = NO;
  result.hardwareModel = @"";
  return self;
}
- (BOOL) hasMarketingName {
  return result.hasMarketingName;
}
- (NSString*) marketingName {
  return result.marketingName;
}
- (DeviceInfoL_Builder*) setMarketingName:(NSString*) value {
  result.hasMarketingName = YES;
  result.marketingName = value;
  return self;
}
- (DeviceInfoL_Builder*) clearMarketingName {
  result.hasMarketingName = NO;
  result.marketingName = @"";
  return self;
}
@end

@interface KeysL ()
@property (retain) NSMutableArray* mutableKeySetList;
@end

@implementation KeysL

@synthesize mutableKeySetList;
- (void) dealloc {
  self.mutableKeySetList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static KeysL* defaultKeysLInstance = nil;
+ (void) initialize {
  if (self == [KeysL class]) {
    defaultKeysLInstance = [[KeysL alloc] init];
  }
}
+ (KeysL*) defaultInstance {
  return defaultKeysLInstance;
}
- (KeysL*) defaultInstance {
  return defaultKeysLInstance;
}
- (NSArray*) keySetList {
  return mutableKeySetList;
}
- (KeyL*) keySetAtIndex:(int32_t) index {
  id value = [mutableKeySetList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (KeyL* element in self.keySetList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (KeyL* element in self.keySetList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (KeyL* element in self.keySetList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (KeysL*) parseFromData:(NSData*) data {
  return (KeysL*)[[[KeysL builder] mergeFromData:data] build];
}
+ (KeysL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeysL*)[[[KeysL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (KeysL*) parseFromInputStream:(NSInputStream*) input {
  return (KeysL*)[[[KeysL builder] mergeFromInputStream:input] build];
}
+ (KeysL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeysL*)[[[KeysL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeysL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (KeysL*)[[[KeysL builder] mergeFromCodedInputStream:input] build];
}
+ (KeysL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeysL*)[[[KeysL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeysL_Builder*) builder {
  return [[[KeysL_Builder alloc] init] autorelease];
}
+ (KeysL_Builder*) builderWithPrototype:(KeysL*) prototype {
  return [[KeysL builder] mergeFrom:prototype];
}
- (KeysL_Builder*) builder {
  return [KeysL builder];
}
@end

@interface KeysL_Builder()
@property (retain) KeysL* result;
@end

@implementation KeysL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[KeysL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (KeysL_Builder*) clear {
  self.result = [[[KeysL alloc] init] autorelease];
  return self;
}
- (KeysL_Builder*) clone {
  return [KeysL builderWithPrototype:result];
}
- (KeysL*) defaultInstance {
  return [KeysL defaultInstance];
}
- (KeysL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (KeysL*) buildPartial {
  KeysL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (KeysL_Builder*) mergeFrom:(KeysL*) other {
  if (other == [KeysL defaultInstance]) {
    return self;
  }
  if (other.mutableKeySetList.count > 0) {
    if (result.mutableKeySetList == nil) {
      result.mutableKeySetList = [NSMutableArray array];
    }
    [result.mutableKeySetList addObjectsFromArray:other.mutableKeySetList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (KeysL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (KeysL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        KeyL_Builder* subBuilder = [KeyL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addKeySet:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) keySetList {
  if (result.mutableKeySetList == nil) { return [NSArray array]; }
  return result.mutableKeySetList;
}
- (KeyL*) keySetAtIndex:(int32_t) index {
  return [result keySetAtIndex:index];
}
- (KeysL_Builder*) replaceKeySetAtIndex:(int32_t) index with:(KeyL*) value {
  [result.mutableKeySetList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (KeysL_Builder*) addAllKeySet:(NSArray*) values {
  if (result.mutableKeySetList == nil) {
    result.mutableKeySetList = [NSMutableArray array];
  }
  [result.mutableKeySetList addObjectsFromArray:values];
  return self;
}
- (KeysL_Builder*) clearKeySetList {
  result.mutableKeySetList = nil;
  return self;
}
- (KeysL_Builder*) addKeySet:(KeyL*) value {
  if (result.mutableKeySetList == nil) {
    result.mutableKeySetList = [NSMutableArray array];
  }
  [result.mutableKeySetList addObject:value];
  return self;
}
@end

@interface KeyL ()
@property int32_t index;
@property (retain) NSData* data;
@end

@implementation KeyL

- (BOOL) hasIndex {
  return !!hasIndex_;
}
- (void) setHasIndex:(BOOL) value {
  hasIndex_ = !!value;
}
@synthesize index;
- (BOOL) hasData {
  return !!hasData_;
}
- (void) setHasData:(BOOL) value {
  hasData_ = !!value;
}
@synthesize data;
- (void) dealloc {
  self.data = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.index = 0;
    self.data = [NSData data];
  }
  return self;
}
static KeyL* defaultKeyLInstance = nil;
+ (void) initialize {
  if (self == [KeyL class]) {
    defaultKeyLInstance = [[KeyL alloc] init];
  }
}
+ (KeyL*) defaultInstance {
  return defaultKeyLInstance;
}
- (KeyL*) defaultInstance {
  return defaultKeyLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasIndex) {
    return NO;
  }
  if (!self.hasData) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasIndex) {
    [output writeInt32:1 value:self.index];
  }
  if (self.hasData) {
    [output writeData:2 value:self.data];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasIndex) {
    size += computeInt32Size(1, self.index);
  }
  if (self.hasData) {
    size += computeDataSize(2, self.data);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (KeyL*) parseFromData:(NSData*) data {
  return (KeyL*)[[[KeyL builder] mergeFromData:data] build];
}
+ (KeyL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeyL*)[[[KeyL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (KeyL*) parseFromInputStream:(NSInputStream*) input {
  return (KeyL*)[[[KeyL builder] mergeFromInputStream:input] build];
}
+ (KeyL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeyL*)[[[KeyL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeyL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (KeyL*)[[[KeyL builder] mergeFromCodedInputStream:input] build];
}
+ (KeyL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (KeyL*)[[[KeyL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (KeyL_Builder*) builder {
  return [[[KeyL_Builder alloc] init] autorelease];
}
+ (KeyL_Builder*) builderWithPrototype:(KeyL*) prototype {
  return [[KeyL builder] mergeFrom:prototype];
}
- (KeyL_Builder*) builder {
  return [KeyL builder];
}
@end

@interface KeyL_Builder()
@property (retain) KeyL* result;
@end

@implementation KeyL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[KeyL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (KeyL_Builder*) clear {
  self.result = [[[KeyL alloc] init] autorelease];
  return self;
}
- (KeyL_Builder*) clone {
  return [KeyL builderWithPrototype:result];
}
- (KeyL*) defaultInstance {
  return [KeyL defaultInstance];
}
- (KeyL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (KeyL*) buildPartial {
  KeyL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (KeyL_Builder*) mergeFrom:(KeyL*) other {
  if (other == [KeyL defaultInstance]) {
    return self;
  }
  if (other.hasIndex) {
    [self setIndex:other.index];
  }
  if (other.hasData) {
    [self setData:other.data];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (KeyL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (KeyL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setIndex:[input readInt32]];
        break;
      }
      case 18: {
        [self setData:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasIndex {
  return result.hasIndex;
}
- (int32_t) index {
  return result.index;
}
- (KeyL_Builder*) setIndex:(int32_t) value {
  result.hasIndex = YES;
  result.index = value;
  return self;
}
- (KeyL_Builder*) clearIndex {
  result.hasIndex = NO;
  result.index = 0;
  return self;
}
- (BOOL) hasData {
  return result.hasData;
}
- (NSData*) data {
  return result.data;
}
- (KeyL_Builder*) setData:(NSData*) value {
  result.hasData = YES;
  result.data = value;
  return self;
}
- (KeyL_Builder*) clearData {
  result.hasData = NO;
  result.data = [NSData data];
  return self;
}
@end

@interface GetFilesL ()
@property (retain) NSData* hash;
@end

@implementation GetFilesL

- (BOOL) hasHash {
  return !!hasHash_;
}
- (void) setHasHash:(BOOL) value {
  hasHash_ = !!value;
}
@synthesize hash;
- (void) dealloc {
  self.hash = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.hash = [NSData data];
  }
  return self;
}
static GetFilesL* defaultGetFilesLInstance = nil;
+ (void) initialize {
  if (self == [GetFilesL class]) {
    defaultGetFilesLInstance = [[GetFilesL alloc] init];
  }
}
+ (GetFilesL*) defaultInstance {
  return defaultGetFilesLInstance;
}
- (GetFilesL*) defaultInstance {
  return defaultGetFilesLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasHash) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasHash) {
    [output writeData:1 value:self.hash];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasHash) {
    size += computeDataSize(1, self.hash);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (GetFilesL*) parseFromData:(NSData*) data {
  return (GetFilesL*)[[[GetFilesL builder] mergeFromData:data] build];
}
+ (GetFilesL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GetFilesL*)[[[GetFilesL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (GetFilesL*) parseFromInputStream:(NSInputStream*) input {
  return (GetFilesL*)[[[GetFilesL builder] mergeFromInputStream:input] build];
}
+ (GetFilesL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GetFilesL*)[[[GetFilesL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (GetFilesL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (GetFilesL*)[[[GetFilesL builder] mergeFromCodedInputStream:input] build];
}
+ (GetFilesL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (GetFilesL*)[[[GetFilesL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (GetFilesL_Builder*) builder {
  return [[[GetFilesL_Builder alloc] init] autorelease];
}
+ (GetFilesL_Builder*) builderWithPrototype:(GetFilesL*) prototype {
  return [[GetFilesL builder] mergeFrom:prototype];
}
- (GetFilesL_Builder*) builder {
  return [GetFilesL builder];
}
@end

@interface GetFilesL_Builder()
@property (retain) GetFilesL* result;
@end

@implementation GetFilesL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[GetFilesL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (GetFilesL_Builder*) clear {
  self.result = [[[GetFilesL alloc] init] autorelease];
  return self;
}
- (GetFilesL_Builder*) clone {
  return [GetFilesL builderWithPrototype:result];
}
- (GetFilesL*) defaultInstance {
  return [GetFilesL defaultInstance];
}
- (GetFilesL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (GetFilesL*) buildPartial {
  GetFilesL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (GetFilesL_Builder*) mergeFrom:(GetFilesL*) other {
  if (other == [GetFilesL defaultInstance]) {
    return self;
  }
  if (other.hasHash) {
    [self setHash:other.hash];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (GetFilesL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (GetFilesL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setHash:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasHash {
  return result.hasHash;
}
- (NSData*) hash {
  return result.hash;
}
- (GetFilesL_Builder*) setHash:(NSData*) value {
  result.hasHash = YES;
  result.hash = value;
  return self;
}
- (GetFilesL_Builder*) clearHash {
  result.hasHash = NO;
  result.hash = [NSData data];
  return self;
}
@end

@interface FileAuthL ()
@property (retain) NSMutableArray* mutableMainList;
@end

@implementation FileAuthL

@synthesize mutableMainList;
- (void) dealloc {
  self.mutableMainList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileAuthL* defaultFileAuthLInstance = nil;
+ (void) initialize {
  if (self == [FileAuthL class]) {
    defaultFileAuthLInstance = [[FileAuthL alloc] init];
  }
}
+ (FileAuthL*) defaultInstance {
  return defaultFileAuthLInstance;
}
- (FileAuthL*) defaultInstance {
  return defaultFileAuthLInstance;
}
- (NSArray*) mainList {
  return mutableMainList;
}
- (AuthChunkL*) mainAtIndex:(int32_t) index {
  id value = [mutableMainList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (AuthChunkL* element in self.mainList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (AuthChunkL* element in self.mainList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (AuthChunkL* element in self.mainList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileAuthL*) parseFromData:(NSData*) data {
  return (FileAuthL*)[[[FileAuthL builder] mergeFromData:data] build];
}
+ (FileAuthL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileAuthL*)[[[FileAuthL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileAuthL*) parseFromInputStream:(NSInputStream*) input {
  return (FileAuthL*)[[[FileAuthL builder] mergeFromInputStream:input] build];
}
+ (FileAuthL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileAuthL*)[[[FileAuthL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileAuthL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileAuthL*)[[[FileAuthL builder] mergeFromCodedInputStream:input] build];
}
+ (FileAuthL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileAuthL*)[[[FileAuthL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileAuthL_Builder*) builder {
  return [[[FileAuthL_Builder alloc] init] autorelease];
}
+ (FileAuthL_Builder*) builderWithPrototype:(FileAuthL*) prototype {
  return [[FileAuthL builder] mergeFrom:prototype];
}
- (FileAuthL_Builder*) builder {
  return [FileAuthL builder];
}
@end

@interface FileAuthL_Builder()
@property (retain) FileAuthL* result;
@end

@implementation FileAuthL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileAuthL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileAuthL_Builder*) clear {
  self.result = [[[FileAuthL alloc] init] autorelease];
  return self;
}
- (FileAuthL_Builder*) clone {
  return [FileAuthL builderWithPrototype:result];
}
- (FileAuthL*) defaultInstance {
  return [FileAuthL defaultInstance];
}
- (FileAuthL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileAuthL*) buildPartial {
  FileAuthL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileAuthL_Builder*) mergeFrom:(FileAuthL*) other {
  if (other == [FileAuthL defaultInstance]) {
    return self;
  }
  if (other.mutableMainList.count > 0) {
    if (result.mutableMainList == nil) {
      result.mutableMainList = [NSMutableArray array];
    }
    [result.mutableMainList addObjectsFromArray:other.mutableMainList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileAuthL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileAuthL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        AuthChunkL_Builder* subBuilder = [AuthChunkL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addMain:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) mainList {
  if (result.mutableMainList == nil) { return [NSArray array]; }
  return result.mutableMainList;
}
- (AuthChunkL*) mainAtIndex:(int32_t) index {
  return [result mainAtIndex:index];
}
- (FileAuthL_Builder*) replaceMainAtIndex:(int32_t) index with:(AuthChunkL*) value {
  [result.mutableMainList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileAuthL_Builder*) addAllMain:(NSArray*) values {
  if (result.mutableMainList == nil) {
    result.mutableMainList = [NSMutableArray array];
  }
  [result.mutableMainList addObjectsFromArray:values];
  return self;
}
- (FileAuthL_Builder*) clearMainList {
  result.mutableMainList = nil;
  return self;
}
- (FileAuthL_Builder*) addMain:(AuthChunkL*) value {
  if (result.mutableMainList == nil) {
    result.mutableMainList = [NSMutableArray array];
  }
  [result.mutableMainList addObject:value];
  return self;
}
@end

@interface AuthChunkL ()
@property (retain) NSData* checksum;
@property (retain) NSString* authToken;
@end

@implementation AuthChunkL

- (BOOL) hasChecksum {
  return !!hasChecksum_;
}
- (void) setHasChecksum:(BOOL) value {
  hasChecksum_ = !!value;
}
@synthesize checksum;
- (BOOL) hasAuthToken {
  return !!hasAuthToken_;
}
- (void) setHasAuthToken:(BOOL) value {
  hasAuthToken_ = !!value;
}
@synthesize authToken;
- (void) dealloc {
  self.checksum = nil;
  self.authToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.checksum = [NSData data];
    self.authToken = @"";
  }
  return self;
}
static AuthChunkL* defaultAuthChunkLInstance = nil;
+ (void) initialize {
  if (self == [AuthChunkL class]) {
    defaultAuthChunkLInstance = [[AuthChunkL alloc] init];
  }
}
+ (AuthChunkL*) defaultInstance {
  return defaultAuthChunkLInstance;
}
- (AuthChunkL*) defaultInstance {
  return defaultAuthChunkLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChecksum) {
    return NO;
  }
  if (!self.hasAuthToken) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChecksum) {
    [output writeData:1 value:self.checksum];
  }
  if (self.hasAuthToken) {
    [output writeString:2 value:self.authToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChecksum) {
    size += computeDataSize(1, self.checksum);
  }
  if (self.hasAuthToken) {
    size += computeStringSize(2, self.authToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (AuthChunkL*) parseFromData:(NSData*) data {
  return (AuthChunkL*)[[[AuthChunkL builder] mergeFromData:data] build];
}
+ (AuthChunkL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (AuthChunkL*)[[[AuthChunkL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (AuthChunkL*) parseFromInputStream:(NSInputStream*) input {
  return (AuthChunkL*)[[[AuthChunkL builder] mergeFromInputStream:input] build];
}
+ (AuthChunkL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (AuthChunkL*)[[[AuthChunkL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (AuthChunkL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (AuthChunkL*)[[[AuthChunkL builder] mergeFromCodedInputStream:input] build];
}
+ (AuthChunkL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (AuthChunkL*)[[[AuthChunkL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (AuthChunkL_Builder*) builder {
  return [[[AuthChunkL_Builder alloc] init] autorelease];
}
+ (AuthChunkL_Builder*) builderWithPrototype:(AuthChunkL*) prototype {
  return [[AuthChunkL builder] mergeFrom:prototype];
}
- (AuthChunkL_Builder*) builder {
  return [AuthChunkL builder];
}
@end

@interface AuthChunkL_Builder()
@property (retain) AuthChunkL* result;
@end

@implementation AuthChunkL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[AuthChunkL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (AuthChunkL_Builder*) clear {
  self.result = [[[AuthChunkL alloc] init] autorelease];
  return self;
}
- (AuthChunkL_Builder*) clone {
  return [AuthChunkL builderWithPrototype:result];
}
- (AuthChunkL*) defaultInstance {
  return [AuthChunkL defaultInstance];
}
- (AuthChunkL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (AuthChunkL*) buildPartial {
  AuthChunkL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (AuthChunkL_Builder*) mergeFrom:(AuthChunkL*) other {
  if (other == [AuthChunkL defaultInstance]) {
    return self;
  }
  if (other.hasChecksum) {
    [self setChecksum:other.checksum];
  }
  if (other.hasAuthToken) {
    [self setAuthToken:other.authToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (AuthChunkL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (AuthChunkL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setAuthToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasChecksum {
  return result.hasChecksum;
}
- (NSData*) checksum {
  return result.checksum;
}
- (AuthChunkL_Builder*) setChecksum:(NSData*) value {
  result.hasChecksum = YES;
  result.checksum = value;
  return self;
}
- (AuthChunkL_Builder*) clearChecksum {
  result.hasChecksum = NO;
  result.checksum = [NSData data];
  return self;
}
- (BOOL) hasAuthToken {
  return result.hasAuthToken;
}
- (NSString*) authToken {
  return result.authToken;
}
- (AuthChunkL_Builder*) setAuthToken:(NSString*) value {
  result.hasAuthToken = YES;
  result.authToken = value;
  return self;
}
- (AuthChunkL_Builder*) clearAuthToken {
  result.hasAuthToken = NO;
  result.authToken = @"";
  return self;
}
@end

@interface FileAttributeL ()
@property (retain) NSString* name;
@property (retain) NSData* value;
@end

@implementation FileAttributeL

- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value {
  hasName_ = !!value;
}
@synthesize name;
- (BOOL) hasValue {
  return !!hasValue_;
}
- (void) setHasValue:(BOOL) value {
  hasValue_ = !!value;
}
@synthesize value;
- (void) dealloc {
  self.name = nil;
  self.value = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.name = @"";
    self.value = [NSData data];
  }
  return self;
}
static FileAttributeL* defaultFileAttributeLInstance = nil;
+ (void) initialize {
  if (self == [FileAttributeL class]) {
    defaultFileAttributeLInstance = [[FileAttributeL alloc] init];
  }
}
+ (FileAttributeL*) defaultInstance {
  return defaultFileAttributeLInstance;
}
- (FileAttributeL*) defaultInstance {
  return defaultFileAttributeLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasName) {
    return NO;
  }
  if (!self.hasValue) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasName) {
    [output writeString:1 value:self.name];
  }
  if (self.hasValue) {
    [output writeData:2 value:self.value];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasName) {
    size += computeStringSize(1, self.name);
  }
  if (self.hasValue) {
    size += computeDataSize(2, self.value);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileAttributeL*) parseFromData:(NSData*) data {
  return (FileAttributeL*)[[[FileAttributeL builder] mergeFromData:data] build];
}
+ (FileAttributeL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileAttributeL*)[[[FileAttributeL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileAttributeL*) parseFromInputStream:(NSInputStream*) input {
  return (FileAttributeL*)[[[FileAttributeL builder] mergeFromInputStream:input] build];
}
+ (FileAttributeL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileAttributeL*)[[[FileAttributeL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileAttributeL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileAttributeL*)[[[FileAttributeL builder] mergeFromCodedInputStream:input] build];
}
+ (FileAttributeL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileAttributeL*)[[[FileAttributeL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileAttributeL_Builder*) builder {
  return [[[FileAttributeL_Builder alloc] init] autorelease];
}
+ (FileAttributeL_Builder*) builderWithPrototype:(FileAttributeL*) prototype {
  return [[FileAttributeL builder] mergeFrom:prototype];
}
- (FileAttributeL_Builder*) builder {
  return [FileAttributeL builder];
}
@end

@interface FileAttributeL_Builder()
@property (retain) FileAttributeL* result;
@end

@implementation FileAttributeL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileAttributeL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileAttributeL_Builder*) clear {
  self.result = [[[FileAttributeL alloc] init] autorelease];
  return self;
}
- (FileAttributeL_Builder*) clone {
  return [FileAttributeL builderWithPrototype:result];
}
- (FileAttributeL*) defaultInstance {
  return [FileAttributeL defaultInstance];
}
- (FileAttributeL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileAttributeL*) buildPartial {
  FileAttributeL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileAttributeL_Builder*) mergeFrom:(FileAttributeL*) other {
  if (other == [FileAttributeL defaultInstance]) {
    return self;
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasValue) {
    [self setValue:other.value];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileAttributeL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileAttributeL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setName:[input readString]];
        break;
      }
      case 18: {
        [self setValue:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasName {
  return result.hasName;
}
- (NSString*) name {
  return result.name;
}
- (FileAttributeL_Builder*) setName:(NSString*) value {
  result.hasName = YES;
  result.name = value;
  return self;
}
- (FileAttributeL_Builder*) clearName {
  result.hasName = NO;
  result.name = @"";
  return self;
}
- (BOOL) hasValue {
  return result.hasValue;
}
- (NSData*) value {
  return result.value;
}
- (FileAttributeL_Builder*) setValue:(NSData*) value {
  result.hasValue = YES;
  result.value = value;
  return self;
}
- (FileAttributeL_Builder*) clearValue {
  result.hasValue = NO;
  result.value = [NSData data];
  return self;
}
@end

@interface FileInfoL ()
@property int32_t keybagId;
@property (retain) NSString* target;
@property (retain) NSData* encryptionKey;
@property int64_t inodeNumber;
@property int32_t mode;
@property int32_t user;
@property int32_t group;
@property int64_t mtime;
@property int64_t atime;
@property int64_t ctime;
@property int32_t protectionClass;
@property (retain) NSMutableArray* mutableAttributesList;
@property int32_t encryptionKeyVersion;
@property int32_t decryptedSize;
@end

@implementation FileInfoL

- (BOOL) hasKeybagId {
  return !!hasKeybagId_;
}
- (void) setHasKeybagId:(BOOL) value {
  hasKeybagId_ = !!value;
}
@synthesize keybagId;
- (BOOL) hasTarget {
  return !!hasTarget_;
}
- (void) setHasTarget:(BOOL) value {
  hasTarget_ = !!value;
}
@synthesize target;
- (BOOL) hasEncryptionKey {
  return !!hasEncryptionKey_;
}
- (void) setHasEncryptionKey:(BOOL) value {
  hasEncryptionKey_ = !!value;
}
@synthesize encryptionKey;
- (BOOL) hasInodeNumber {
  return !!hasInodeNumber_;
}
- (void) setHasInodeNumber:(BOOL) value {
  hasInodeNumber_ = !!value;
}
@synthesize inodeNumber;
- (BOOL) hasMode {
  return !!hasMode_;
}
- (void) setHasMode:(BOOL) value {
  hasMode_ = !!value;
}
@synthesize mode;
- (BOOL) hasUser {
  return !!hasUser_;
}
- (void) setHasUser:(BOOL) value {
  hasUser_ = !!value;
}
@synthesize user;
- (BOOL) hasGroup {
  return !!hasGroup_;
}
- (void) setHasGroup:(BOOL) value {
  hasGroup_ = !!value;
}
@synthesize group;
- (BOOL) hasMtime {
  return !!hasMtime_;
}
- (void) setHasMtime:(BOOL) value {
  hasMtime_ = !!value;
}
@synthesize mtime;
- (BOOL) hasAtime {
  return !!hasAtime_;
}
- (void) setHasAtime:(BOOL) value {
  hasAtime_ = !!value;
}
@synthesize atime;
- (BOOL) hasCtime {
  return !!hasCtime_;
}
- (void) setHasCtime:(BOOL) value {
  hasCtime_ = !!value;
}
@synthesize ctime;
- (BOOL) hasProtectionClass {
  return !!hasProtectionClass_;
}
- (void) setHasProtectionClass:(BOOL) value {
  hasProtectionClass_ = !!value;
}
@synthesize protectionClass;
@synthesize mutableAttributesList;
- (BOOL) hasEncryptionKeyVersion {
  return !!hasEncryptionKeyVersion_;
}
- (void) setHasEncryptionKeyVersion:(BOOL) value {
  hasEncryptionKeyVersion_ = !!value;
}
@synthesize encryptionKeyVersion;
- (BOOL) hasDecryptedSize {
  return !!hasDecryptedSize_;
}
- (void) setHasDecryptedSize:(BOOL) value {
  hasDecryptedSize_ = !!value;
}
@synthesize decryptedSize;
- (void) dealloc {
  self.target = nil;
  self.encryptionKey = nil;
  self.mutableAttributesList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.keybagId = 0;
    self.target = @"";
    self.encryptionKey = [NSData data];
    self.inodeNumber = 0L;
    self.mode = 0;
    self.user = 0;
    self.group = 0;
    self.mtime = 0L;
    self.atime = 0L;
    self.ctime = 0L;
    self.protectionClass = 0;
    self.encryptionKeyVersion = 0;
    self.decryptedSize = 0;
  }
  return self;
}
static FileInfoL* defaultFileInfoLInstance = nil;
+ (void) initialize {
  if (self == [FileInfoL class]) {
    defaultFileInfoLInstance = [[FileInfoL alloc] init];
  }
}
+ (FileInfoL*) defaultInstance {
  return defaultFileInfoLInstance;
}
- (FileInfoL*) defaultInstance {
  return defaultFileInfoLInstance;
}
- (NSArray*) attributesList {
  return mutableAttributesList;
}
- (FileAttributeL*) attributesAtIndex:(int32_t) index {
  id value = [mutableAttributesList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasInodeNumber) {
    return NO;
  }
  if (!self.hasMode) {
    return NO;
  }
  if (!self.hasUser) {
    return NO;
  }
  if (!self.hasGroup) {
    return NO;
  }
  if (!self.hasMtime) {
    return NO;
  }
  if (!self.hasAtime) {
    return NO;
  }
  if (!self.hasCtime) {
    return NO;
  }
  if (!self.hasProtectionClass) {
    return NO;
  }
  for (FileAttributeL* element in self.attributesList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKeybagId) {
    [output writeInt32:1 value:self.keybagId];
  }
  if (self.hasTarget) {
    [output writeString:2 value:self.target];
  }
  if (self.hasEncryptionKey) {
    [output writeData:3 value:self.encryptionKey];
  }
  if (self.hasInodeNumber) {
    [output writeInt64:4 value:self.inodeNumber];
  }
  if (self.hasMode) {
    [output writeInt32:5 value:self.mode];
  }
  if (self.hasUser) {
    [output writeInt32:6 value:self.user];
  }
  if (self.hasGroup) {
    [output writeInt32:7 value:self.group];
  }
  if (self.hasMtime) {
    [output writeInt64:8 value:self.mtime];
  }
  if (self.hasAtime) {
    [output writeInt64:9 value:self.atime];
  }
  if (self.hasCtime) {
    [output writeInt64:10 value:self.ctime];
  }
  if (self.hasProtectionClass) {
    [output writeInt32:12 value:self.protectionClass];
  }
  for (FileAttributeL* element in self.attributesList) {
    [output writeMessage:13 value:element];
  }
  if (self.hasEncryptionKeyVersion) {
    [output writeInt32:14 value:self.encryptionKeyVersion];
  }
  if (self.hasDecryptedSize) {
    [output writeInt32:15 value:self.decryptedSize];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasKeybagId) {
    size += computeInt32Size(1, self.keybagId);
  }
  if (self.hasTarget) {
    size += computeStringSize(2, self.target);
  }
  if (self.hasEncryptionKey) {
    size += computeDataSize(3, self.encryptionKey);
  }
  if (self.hasInodeNumber) {
    size += computeInt64Size(4, self.inodeNumber);
  }
  if (self.hasMode) {
    size += computeInt32Size(5, self.mode);
  }
  if (self.hasUser) {
    size += computeInt32Size(6, self.user);
  }
  if (self.hasGroup) {
    size += computeInt32Size(7, self.group);
  }
  if (self.hasMtime) {
    size += computeInt64Size(8, self.mtime);
  }
  if (self.hasAtime) {
    size += computeInt64Size(9, self.atime);
  }
  if (self.hasCtime) {
    size += computeInt64Size(10, self.ctime);
  }
  if (self.hasProtectionClass) {
    size += computeInt32Size(12, self.protectionClass);
  }
  for (FileAttributeL* element in self.attributesList) {
    size += computeMessageSize(13, element);
  }
  if (self.hasEncryptionKeyVersion) {
    size += computeInt32Size(14, self.encryptionKeyVersion);
  }
  if (self.hasDecryptedSize) {
    size += computeInt32Size(15, self.decryptedSize);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileInfoL*) parseFromData:(NSData*) data {
  return (FileInfoL*)[[[FileInfoL builder] mergeFromData:data] build];
}
+ (FileInfoL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileInfoL*)[[[FileInfoL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileInfoL*) parseFromInputStream:(NSInputStream*) input {
  return (FileInfoL*)[[[FileInfoL builder] mergeFromInputStream:input] build];
}
+ (FileInfoL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileInfoL*)[[[FileInfoL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileInfoL*)[[[FileInfoL builder] mergeFromCodedInputStream:input] build];
}
+ (FileInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileInfoL*)[[[FileInfoL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileInfoL_Builder*) builder {
  return [[[FileInfoL_Builder alloc] init] autorelease];
}
+ (FileInfoL_Builder*) builderWithPrototype:(FileInfoL*) prototype {
  return [[FileInfoL builder] mergeFrom:prototype];
}
- (FileInfoL_Builder*) builder {
  return [FileInfoL builder];
}
@end

@interface FileInfoL_Builder()
@property (retain) FileInfoL* result;
@end

@implementation FileInfoL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileInfoL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileInfoL_Builder*) clear {
  self.result = [[[FileInfoL alloc] init] autorelease];
  return self;
}
- (FileInfoL_Builder*) clone {
  return [FileInfoL builderWithPrototype:result];
}
- (FileInfoL*) defaultInstance {
  return [FileInfoL defaultInstance];
}
- (FileInfoL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileInfoL*) buildPartial {
  FileInfoL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileInfoL_Builder*) mergeFrom:(FileInfoL*) other {
  if (other == [FileInfoL defaultInstance]) {
    return self;
  }
  if (other.hasKeybagId) {
    [self setKeybagId:other.keybagId];
  }
  if (other.hasTarget) {
    [self setTarget:other.target];
  }
  if (other.hasEncryptionKey) {
    [self setEncryptionKey:other.encryptionKey];
  }
  if (other.hasInodeNumber) {
    [self setInodeNumber:other.inodeNumber];
  }
  if (other.hasMode) {
    [self setMode:other.mode];
  }
  if (other.hasUser) {
    [self setUser:other.user];
  }
  if (other.hasGroup) {
    [self setGroup:other.group];
  }
  if (other.hasMtime) {
    [self setMtime:other.mtime];
  }
  if (other.hasAtime) {
    [self setAtime:other.atime];
  }
  if (other.hasCtime) {
    [self setCtime:other.ctime];
  }
  if (other.hasProtectionClass) {
    [self setProtectionClass:other.protectionClass];
  }
  if (other.mutableAttributesList.count > 0) {
    if (result.mutableAttributesList == nil) {
      result.mutableAttributesList = [NSMutableArray array];
    }
    [result.mutableAttributesList addObjectsFromArray:other.mutableAttributesList];
  }
  if (other.hasEncryptionKeyVersion) {
    [self setEncryptionKeyVersion:other.encryptionKeyVersion];
  }
  if (other.hasDecryptedSize) {
    [self setDecryptedSize:other.decryptedSize];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setKeybagId:[input readInt32]];
        break;
      }
      case 18: {
        [self setTarget:[input readString]];
        break;
      }
      case 26: {
        [self setEncryptionKey:[input readData]];
        break;
      }
      case 32: {
        [self setInodeNumber:[input readInt64]];
        break;
      }
      case 40: {
        [self setMode:[input readInt32]];
        break;
      }
      case 48: {
        [self setUser:[input readInt32]];
        break;
      }
      case 56: {
        [self setGroup:[input readInt32]];
        break;
      }
      case 64: {
        [self setMtime:[input readInt64]];
        break;
      }
      case 72: {
        [self setAtime:[input readInt64]];
        break;
      }
      case 80: {
        [self setCtime:[input readInt64]];
        break;
      }
      case 96: {
        [self setProtectionClass:[input readInt32]];
        break;
      }
      case 106: {
        FileAttributeL_Builder* subBuilder = [FileAttributeL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addAttributes:[subBuilder buildPartial]];
        break;
      }
      case 112: {
        [self setEncryptionKeyVersion:[input readInt32]];
        break;
      }
      case 120: {
        [self setDecryptedSize:[input readInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasKeybagId {
  return result.hasKeybagId;
}
- (int32_t) keybagId {
  return result.keybagId;
}
- (FileInfoL_Builder*) setKeybagId:(int32_t) value {
  result.hasKeybagId = YES;
  result.keybagId = value;
  return self;
}
- (FileInfoL_Builder*) clearKeybagId {
  result.hasKeybagId = NO;
  result.keybagId = 0;
  return self;
}
- (BOOL) hasTarget {
  return result.hasTarget;
}
- (NSString*) target {
  return result.target;
}
- (FileInfoL_Builder*) setTarget:(NSString*) value {
  result.hasTarget = YES;
  result.target = value;
  return self;
}
- (FileInfoL_Builder*) clearTarget {
  result.hasTarget = NO;
  result.target = @"";
  return self;
}
- (BOOL) hasEncryptionKey {
  return result.hasEncryptionKey;
}
- (NSData*) encryptionKey {
  return result.encryptionKey;
}
- (FileInfoL_Builder*) setEncryptionKey:(NSData*) value {
  result.hasEncryptionKey = YES;
  result.encryptionKey = value;
  return self;
}
- (FileInfoL_Builder*) clearEncryptionKey {
  result.hasEncryptionKey = NO;
  result.encryptionKey = [NSData data];
  return self;
}
- (BOOL) hasInodeNumber {
  return result.hasInodeNumber;
}
- (int64_t) inodeNumber {
  return result.inodeNumber;
}
- (FileInfoL_Builder*) setInodeNumber:(int64_t) value {
  result.hasInodeNumber = YES;
  result.inodeNumber = value;
  return self;
}
- (FileInfoL_Builder*) clearInodeNumber {
  result.hasInodeNumber = NO;
  result.inodeNumber = 0L;
  return self;
}
- (BOOL) hasMode {
  return result.hasMode;
}
- (int32_t) mode {
  return result.mode;
}
- (FileInfoL_Builder*) setMode:(int32_t) value {
  result.hasMode = YES;
  result.mode = value;
  return self;
}
- (FileInfoL_Builder*) clearMode {
  result.hasMode = NO;
  result.mode = 0;
  return self;
}
- (BOOL) hasUser {
  return result.hasUser;
}
- (int32_t) user {
  return result.user;
}
- (FileInfoL_Builder*) setUser:(int32_t) value {
  result.hasUser = YES;
  result.user = value;
  return self;
}
- (FileInfoL_Builder*) clearUser {
  result.hasUser = NO;
  result.user = 0;
  return self;
}
- (BOOL) hasGroup {
  return result.hasGroup;
}
- (int32_t) group {
  return result.group;
}
- (FileInfoL_Builder*) setGroup:(int32_t) value {
  result.hasGroup = YES;
  result.group = value;
  return self;
}
- (FileInfoL_Builder*) clearGroup {
  result.hasGroup = NO;
  result.group = 0;
  return self;
}
- (BOOL) hasMtime {
  return result.hasMtime;
}
- (int64_t) mtime {
  return result.mtime;
}
- (FileInfoL_Builder*) setMtime:(int64_t) value {
  result.hasMtime = YES;
  result.mtime = value;
  return self;
}
- (FileInfoL_Builder*) clearMtime {
  result.hasMtime = NO;
  result.mtime = 0L;
  return self;
}
- (BOOL) hasAtime {
  return result.hasAtime;
}
- (int64_t) atime {
  return result.atime;
}
- (FileInfoL_Builder*) setAtime:(int64_t) value {
  result.hasAtime = YES;
  result.atime = value;
  return self;
}
- (FileInfoL_Builder*) clearAtime {
  result.hasAtime = NO;
  result.atime = 0L;
  return self;
}
- (BOOL) hasCtime {
  return result.hasCtime;
}
- (int64_t) ctime {
  return result.ctime;
}
- (FileInfoL_Builder*) setCtime:(int64_t) value {
  result.hasCtime = YES;
  result.ctime = value;
  return self;
}
- (FileInfoL_Builder*) clearCtime {
  result.hasCtime = NO;
  result.ctime = 0L;
  return self;
}
- (BOOL) hasProtectionClass {
  return result.hasProtectionClass;
}
- (int32_t) protectionClass {
  return result.protectionClass;
}
- (FileInfoL_Builder*) setProtectionClass:(int32_t) value {
  result.hasProtectionClass = YES;
  result.protectionClass = value;
  return self;
}
- (FileInfoL_Builder*) clearProtectionClass {
  result.hasProtectionClass = NO;
  result.protectionClass = 0;
  return self;
}
- (NSArray*) attributesList {
  if (result.mutableAttributesList == nil) { return [NSArray array]; }
  return result.mutableAttributesList;
}
- (FileAttributeL*) attributesAtIndex:(int32_t) index {
  return [result attributesAtIndex:index];
}
- (FileInfoL_Builder*) replaceAttributesAtIndex:(int32_t) index with:(FileAttributeL*) value {
  [result.mutableAttributesList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileInfoL_Builder*) addAllAttributes:(NSArray*) values {
  if (result.mutableAttributesList == nil) {
    result.mutableAttributesList = [NSMutableArray array];
  }
  [result.mutableAttributesList addObjectsFromArray:values];
  return self;
}
- (FileInfoL_Builder*) clearAttributesList {
  result.mutableAttributesList = nil;
  return self;
}
- (FileInfoL_Builder*) addAttributes:(FileAttributeL*) value {
  if (result.mutableAttributesList == nil) {
    result.mutableAttributesList = [NSMutableArray array];
  }
  [result.mutableAttributesList addObject:value];
  return self;
}
- (BOOL) hasEncryptionKeyVersion {
  return result.hasEncryptionKeyVersion;
}
- (int32_t) encryptionKeyVersion {
  return result.encryptionKeyVersion;
}
- (FileInfoL_Builder*) setEncryptionKeyVersion:(int32_t) value {
  result.hasEncryptionKeyVersion = YES;
  result.encryptionKeyVersion = value;
  return self;
}
- (FileInfoL_Builder*) clearEncryptionKeyVersion {
  result.hasEncryptionKeyVersion = NO;
  result.encryptionKeyVersion = 0;
  return self;
}
- (BOOL) hasDecryptedSize {
  return result.hasDecryptedSize;
}
- (int32_t) decryptedSize {
  return result.decryptedSize;
}
- (FileInfoL_Builder*) setDecryptedSize:(int32_t) value {
  result.hasDecryptedSize = YES;
  result.decryptedSize = value;
  return self;
}
- (FileInfoL_Builder*) clearDecryptedSize {
  result.hasDecryptedSize = NO;
  result.decryptedSize = 0;
  return self;
}
@end

@interface FileL ()
@property (retain) NSData* fileName;
@property (retain) NSString* domain;
@property (retain) NSString* path;
@property (retain) NSData* altFileName;
@property int64_t fileSize;
@property (retain) FileInfoL* info;
@property int64_t date;
@property BOOL boolVal;
@end

@implementation FileL

- (BOOL) hasFileName {
  return !!hasFileName_;
}
- (void) setHasFileName:(BOOL) value {
  hasFileName_ = !!value;
}
@synthesize fileName;
- (BOOL) hasDomain {
  return !!hasDomain_;
}
- (void) setHasDomain:(BOOL) value {
  hasDomain_ = !!value;
}
@synthesize domain;
- (BOOL) hasPath {
  return !!hasPath_;
}
- (void) setHasPath:(BOOL) value {
  hasPath_ = !!value;
}
@synthesize path;
- (BOOL) hasAltFileName {
  return !!hasAltFileName_;
}
- (void) setHasAltFileName:(BOOL) value {
  hasAltFileName_ = !!value;
}
@synthesize altFileName;
- (BOOL) hasFileSize {
  return !!hasFileSize_;
}
- (void) setHasFileSize:(BOOL) value {
  hasFileSize_ = !!value;
}
@synthesize fileSize;
- (BOOL) hasInfo {
  return !!hasInfo_;
}
- (void) setHasInfo:(BOOL) value {
  hasInfo_ = !!value;
}
@synthesize info;
- (BOOL) hasDate {
  return !!hasDate_;
}
- (void) setHasDate:(BOOL) value {
  hasDate_ = !!value;
}
@synthesize date;
- (BOOL) hasBoolVal {
  return !!hasBoolVal_;
}
- (void) setHasBoolVal:(BOOL) value {
  hasBoolVal_ = !!value;
}
- (BOOL) boolVal {
  return !!boolVal_;
}
- (void) setBoolVal:(BOOL) value {
  boolVal_ = !!value;
}
- (void) dealloc {
  self.fileName = nil;
  self.domain = nil;
  self.path = nil;
  self.altFileName = nil;
  self.info = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileName = [NSData data];
    self.domain = @"";
    self.path = @"";
    self.altFileName = [NSData data];
    self.fileSize = 0L;
    self.info = [FileInfoL defaultInstance];
    self.date = 0L;
    self.boolVal = NO;
  }
  return self;
}
static FileL* defaultFileLInstance = nil;
+ (void) initialize {
  if (self == [FileL class]) {
    defaultFileLInstance = [[FileL alloc] init];
  }
}
+ (FileL*) defaultInstance {
  return defaultFileLInstance;
}
- (FileL*) defaultInstance {
  return defaultFileLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasFileName) {
    return NO;
  }
  if (!self.hasDomain) {
    return NO;
  }
  if (!self.hasPath) {
    return NO;
  }
  if (!self.hasFileSize) {
    return NO;
  }
  if (!self.hasDate) {
    return NO;
  }
  if (self.hasInfo) {
    if (!self.info.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileName) {
    [output writeData:1 value:self.fileName];
  }
  if (self.hasDomain) {
    [output writeString:2 value:self.domain];
  }
  if (self.hasPath) {
    [output writeString:3 value:self.path];
  }
  if (self.hasAltFileName) {
    [output writeData:4 value:self.altFileName];
  }
  if (self.hasFileSize) {
    [output writeInt64:5 value:self.fileSize];
  }
  if (self.hasInfo) {
    [output writeMessage:6 value:self.info];
  }
  if (self.hasDate) {
    [output writeInt64:7 value:self.date];
  }
  if (self.hasBoolVal) {
    [output writeBool:9 value:self.boolVal];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileName) {
    size += computeDataSize(1, self.fileName);
  }
  if (self.hasDomain) {
    size += computeStringSize(2, self.domain);
  }
  if (self.hasPath) {
    size += computeStringSize(3, self.path);
  }
  if (self.hasAltFileName) {
    size += computeDataSize(4, self.altFileName);
  }
  if (self.hasFileSize) {
    size += computeInt64Size(5, self.fileSize);
  }
  if (self.hasInfo) {
    size += computeMessageSize(6, self.info);
  }
  if (self.hasDate) {
    size += computeInt64Size(7, self.date);
  }
  if (self.hasBoolVal) {
    size += computeBoolSize(9, self.boolVal);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileL*) parseFromData:(NSData*) data {
  return (FileL*)[[[FileL builder] mergeFromData:data] build];
}
+ (FileL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileL*)[[[FileL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileL*) parseFromInputStream:(NSInputStream*) input {
  return (FileL*)[[[FileL builder] mergeFromInputStream:input] build];
}
+ (FileL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileL*)[[[FileL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileL*)[[[FileL builder] mergeFromCodedInputStream:input] build];
}
+ (FileL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileL*)[[[FileL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileL_Builder*) builder {
  return [[[FileL_Builder alloc] init] autorelease];
}
+ (FileL_Builder*) builderWithPrototype:(FileL*) prototype {
  return [[FileL builder] mergeFrom:prototype];
}
- (FileL_Builder*) builder {
  return [FileL builder];
}
@end

@interface FileL_Builder()
@property (retain) FileL* result;
@end

@implementation FileL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileL_Builder*) clear {
  self.result = [[[FileL alloc] init] autorelease];
  return self;
}
- (FileL_Builder*) clone {
  return [FileL builderWithPrototype:result];
}
- (FileL*) defaultInstance {
  return [FileL defaultInstance];
}
- (FileL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileL*) buildPartial {
  FileL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileL_Builder*) mergeFrom:(FileL*) other {
  if (other == [FileL defaultInstance]) {
    return self;
  }
  if (other.hasFileName) {
    [self setFileName:other.fileName];
  }
  if (other.hasDomain) {
    [self setDomain:other.domain];
  }
  if (other.hasPath) {
    [self setPath:other.path];
  }
  if (other.hasAltFileName) {
    [self setAltFileName:other.altFileName];
  }
  if (other.hasFileSize) {
    [self setFileSize:other.fileSize];
  }
  if (other.hasInfo) {
    [self mergeInfo:other.info];
  }
  if (other.hasDate) {
    [self setDate:other.date];
  }
  if (other.hasBoolVal) {
    [self setBoolVal:other.boolVal];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileName:[input readData]];
        break;
      }
      case 18: {
        [self setDomain:[input readString]];
        break;
      }
      case 26: {
        [self setPath:[input readString]];
        break;
      }
      case 34: {
        [self setAltFileName:[input readData]];
        break;
      }
      case 40: {
        [self setFileSize:[input readInt64]];
        break;
      }
      case 50: {
        FileInfoL_Builder* subBuilder = [FileInfoL builder];
        if (self.hasInfo) {
          [subBuilder mergeFrom:self.info];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setInfo:[subBuilder buildPartial]];
        break;
      }
      case 56: {
        [self setDate:[input readInt64]];
        break;
      }
      case 72: {
        [self setBoolVal:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasFileName {
  return result.hasFileName;
}
- (NSData*) fileName {
  return result.fileName;
}
- (FileL_Builder*) setFileName:(NSData*) value {
  result.hasFileName = YES;
  result.fileName = value;
  return self;
}
- (FileL_Builder*) clearFileName {
  result.hasFileName = NO;
  result.fileName = [NSData data];
  return self;
}
- (BOOL) hasDomain {
  return result.hasDomain;
}
- (NSString*) domain {
  return result.domain;
}
- (FileL_Builder*) setDomain:(NSString*) value {
  result.hasDomain = YES;
  result.domain = value;
  return self;
}
- (FileL_Builder*) clearDomain {
  result.hasDomain = NO;
  result.domain = @"";
  return self;
}
- (BOOL) hasPath {
  return result.hasPath;
}
- (NSString*) path {
  return result.path;
}
- (FileL_Builder*) setPath:(NSString*) value {
  result.hasPath = YES;
  result.path = value;
  return self;
}
- (FileL_Builder*) clearPath {
  result.hasPath = NO;
  result.path = @"";
  return self;
}
- (BOOL) hasAltFileName {
  return result.hasAltFileName;
}
- (NSData*) altFileName {
  return result.altFileName;
}
- (FileL_Builder*) setAltFileName:(NSData*) value {
  result.hasAltFileName = YES;
  result.altFileName = value;
  return self;
}
- (FileL_Builder*) clearAltFileName {
  result.hasAltFileName = NO;
  result.altFileName = [NSData data];
  return self;
}
- (BOOL) hasFileSize {
  return result.hasFileSize;
}
- (int64_t) fileSize {
  return result.fileSize;
}
- (FileL_Builder*) setFileSize:(int64_t) value {
  result.hasFileSize = YES;
  result.fileSize = value;
  return self;
}
- (FileL_Builder*) clearFileSize {
  result.hasFileSize = NO;
  result.fileSize = 0L;
  return self;
}
- (BOOL) hasInfo {
  return result.hasInfo;
}
- (FileInfoL*) info {
  return result.info;
}
- (FileL_Builder*) setInfo:(FileInfoL*) value {
  result.hasInfo = YES;
  result.info = value;
  return self;
}
- (FileL_Builder*) setInfoBuilder:(FileInfoL_Builder*) builderForValue {
  return [self setInfo:[builderForValue build]];
}
- (FileL_Builder*) mergeInfo:(FileInfoL*) value {
  if (result.hasInfo &&
      result.info != [FileInfoL defaultInstance]) {
    result.info =
      [[[FileInfoL builderWithPrototype:result.info] mergeFrom:value] buildPartial];
  } else {
    result.info = value;
  }
  result.hasInfo = YES;
  return self;
}
- (FileL_Builder*) clearInfo {
  result.hasInfo = NO;
  result.info = [FileInfoL defaultInstance];
  return self;
}
- (BOOL) hasDate {
  return result.hasDate;
}
- (int64_t) date {
  return result.date;
}
- (FileL_Builder*) setDate:(int64_t) value {
  result.hasDate = YES;
  result.date = value;
  return self;
}
- (FileL_Builder*) clearDate {
  result.hasDate = NO;
  result.date = 0L;
  return self;
}
- (BOOL) hasBoolVal {
  return result.hasBoolVal;
}
- (BOOL) boolVal {
  return result.boolVal;
}
- (FileL_Builder*) setBoolVal:(BOOL) value {
  result.hasBoolVal = YES;
  result.boolVal = value;
  return self;
}
- (FileL_Builder*) clearBoolVal {
  result.hasBoolVal = NO;
  result.boolVal = NO;
  return self;
}
@end

@interface HeaderL ()
@property (retain) NSString* key;
@property (retain) NSString* value;
@end

@implementation HeaderL

- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) value {
  hasKey_ = !!value;
}
@synthesize key;
- (BOOL) hasValue {
  return !!hasValue_;
}
- (void) setHasValue:(BOOL) value {
  hasValue_ = !!value;
}
@synthesize value;
- (void) dealloc {
  self.key = nil;
  self.value = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.key = @"";
    self.value = @"";
  }
  return self;
}
static HeaderL* defaultHeaderLInstance = nil;
+ (void) initialize {
  if (self == [HeaderL class]) {
    defaultHeaderLInstance = [[HeaderL alloc] init];
  }
}
+ (HeaderL*) defaultInstance {
  return defaultHeaderLInstance;
}
- (HeaderL*) defaultInstance {
  return defaultHeaderLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasKey) {
    return NO;
  }
  if (!self.hasValue) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKey) {
    [output writeString:1 value:self.key];
  }
  if (self.hasValue) {
    [output writeString:2 value:self.value];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasKey) {
    size += computeStringSize(1, self.key);
  }
  if (self.hasValue) {
    size += computeStringSize(2, self.value);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (HeaderL*) parseFromData:(NSData*) data {
  return (HeaderL*)[[[HeaderL builder] mergeFromData:data] build];
}
+ (HeaderL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HeaderL*)[[[HeaderL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (HeaderL*) parseFromInputStream:(NSInputStream*) input {
  return (HeaderL*)[[[HeaderL builder] mergeFromInputStream:input] build];
}
+ (HeaderL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HeaderL*)[[[HeaderL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HeaderL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (HeaderL*)[[[HeaderL builder] mergeFromCodedInputStream:input] build];
}
+ (HeaderL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HeaderL*)[[[HeaderL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HeaderL_Builder*) builder {
  return [[[HeaderL_Builder alloc] init] autorelease];
}
+ (HeaderL_Builder*) builderWithPrototype:(HeaderL*) prototype {
  return [[HeaderL builder] mergeFrom:prototype];
}
- (HeaderL_Builder*) builder {
  return [HeaderL builder];
}
@end

@interface HeaderL_Builder()
@property (retain) HeaderL* result;
@end

@implementation HeaderL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[HeaderL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (HeaderL_Builder*) clear {
  self.result = [[[HeaderL alloc] init] autorelease];
  return self;
}
- (HeaderL_Builder*) clone {
  return [HeaderL builderWithPrototype:result];
}
- (HeaderL*) defaultInstance {
  return [HeaderL defaultInstance];
}
- (HeaderL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (HeaderL*) buildPartial {
  HeaderL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (HeaderL_Builder*) mergeFrom:(HeaderL*) other {
  if (other == [HeaderL defaultInstance]) {
    return self;
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  if (other.hasValue) {
    [self setValue:other.value];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (HeaderL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (HeaderL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setKey:[input readString]];
        break;
      }
      case 18: {
        [self setValue:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasKey {
  return result.hasKey;
}
- (NSString*) key {
  return result.key;
}
- (HeaderL_Builder*) setKey:(NSString*) value {
  result.hasKey = YES;
  result.key = value;
  return self;
}
- (HeaderL_Builder*) clearKey {
  result.hasKey = NO;
  result.key = @"";
  return self;
}
- (BOOL) hasValue {
  return result.hasValue;
}
- (NSString*) value {
  return result.value;
}
- (HeaderL_Builder*) setValue:(NSString*) value {
  result.hasValue = YES;
  result.value = value;
  return self;
}
- (HeaderL_Builder*) clearValue {
  result.hasValue = NO;
  result.value = @"";
  return self;
}
@end

@interface ChunkInfoL ()
@property (retain) NSData* chunkChecksum;
@property (retain) NSData* chunkEncryptionKey;
@property int32_t chunkLength;
@end

@implementation ChunkInfoL

- (BOOL) hasChunkChecksum {
  return !!hasChunkChecksum_;
}
- (void) setHasChunkChecksum:(BOOL) value {
  hasChunkChecksum_ = !!value;
}
@synthesize chunkChecksum;
- (BOOL) hasChunkEncryptionKey {
  return !!hasChunkEncryptionKey_;
}
- (void) setHasChunkEncryptionKey:(BOOL) value {
  hasChunkEncryptionKey_ = !!value;
}
@synthesize chunkEncryptionKey;
- (BOOL) hasChunkLength {
  return !!hasChunkLength_;
}
- (void) setHasChunkLength:(BOOL) value {
  hasChunkLength_ = !!value;
}
@synthesize chunkLength;
- (void) dealloc {
  self.chunkChecksum = nil;
  self.chunkEncryptionKey = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.chunkChecksum = [NSData data];
    self.chunkEncryptionKey = [NSData data];
    self.chunkLength = 0;
  }
  return self;
}
static ChunkInfoL* defaultChunkInfoLInstance = nil;
+ (void) initialize {
  if (self == [ChunkInfoL class]) {
    defaultChunkInfoLInstance = [[ChunkInfoL alloc] init];
  }
}
+ (ChunkInfoL*) defaultInstance {
  return defaultChunkInfoLInstance;
}
- (ChunkInfoL*) defaultInstance {
  return defaultChunkInfoLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChunkChecksum) {
    return NO;
  }
  if (!self.hasChunkLength) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChunkChecksum) {
    [output writeData:1 value:self.chunkChecksum];
  }
  if (self.hasChunkEncryptionKey) {
    [output writeData:2 value:self.chunkEncryptionKey];
  }
  if (self.hasChunkLength) {
    [output writeUInt32:3 value:self.chunkLength];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChunkChecksum) {
    size += computeDataSize(1, self.chunkChecksum);
  }
  if (self.hasChunkEncryptionKey) {
    size += computeDataSize(2, self.chunkEncryptionKey);
  }
  if (self.hasChunkLength) {
    size += computeUInt32Size(3, self.chunkLength);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkInfoL*) parseFromData:(NSData*) data {
  return (ChunkInfoL*)[[[ChunkInfoL builder] mergeFromData:data] build];
}
+ (ChunkInfoL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkInfoL*)[[[ChunkInfoL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkInfoL*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkInfoL*)[[[ChunkInfoL builder] mergeFromInputStream:input] build];
}
+ (ChunkInfoL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkInfoL*)[[[ChunkInfoL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkInfoL*)[[[ChunkInfoL builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkInfoL*)[[[ChunkInfoL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkInfoL_Builder*) builder {
  return [[[ChunkInfoL_Builder alloc] init] autorelease];
}
+ (ChunkInfoL_Builder*) builderWithPrototype:(ChunkInfoL*) prototype {
  return [[ChunkInfoL builder] mergeFrom:prototype];
}
- (ChunkInfoL_Builder*) builder {
  return [ChunkInfoL builder];
}
@end

@interface ChunkInfoL_Builder()
@property (retain) ChunkInfoL* result;
@end

@implementation ChunkInfoL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkInfoL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkInfoL_Builder*) clear {
  self.result = [[[ChunkInfoL alloc] init] autorelease];
  return self;
}
- (ChunkInfoL_Builder*) clone {
  return [ChunkInfoL builderWithPrototype:result];
}
- (ChunkInfoL*) defaultInstance {
  return [ChunkInfoL defaultInstance];
}
- (ChunkInfoL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkInfoL*) buildPartial {
  ChunkInfoL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkInfoL_Builder*) mergeFrom:(ChunkInfoL*) other {
  if (other == [ChunkInfoL defaultInstance]) {
    return self;
  }
  if (other.hasChunkChecksum) {
    [self setChunkChecksum:other.chunkChecksum];
  }
  if (other.hasChunkEncryptionKey) {
    [self setChunkEncryptionKey:other.chunkEncryptionKey];
  }
  if (other.hasChunkLength) {
    [self setChunkLength:other.chunkLength];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChunkChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setChunkEncryptionKey:[input readData]];
        break;
      }
      case 24: {
        [self setChunkLength:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasChunkChecksum {
  return result.hasChunkChecksum;
}
- (NSData*) chunkChecksum {
  return result.chunkChecksum;
}
- (ChunkInfoL_Builder*) setChunkChecksum:(NSData*) value {
  result.hasChunkChecksum = YES;
  result.chunkChecksum = value;
  return self;
}
- (ChunkInfoL_Builder*) clearChunkChecksum {
  result.hasChunkChecksum = NO;
  result.chunkChecksum = [NSData data];
  return self;
}
- (BOOL) hasChunkEncryptionKey {
  return result.hasChunkEncryptionKey;
}
- (NSData*) chunkEncryptionKey {
  return result.chunkEncryptionKey;
}
- (ChunkInfoL_Builder*) setChunkEncryptionKey:(NSData*) value {
  result.hasChunkEncryptionKey = YES;
  result.chunkEncryptionKey = value;
  return self;
}
- (ChunkInfoL_Builder*) clearChunkEncryptionKey {
  result.hasChunkEncryptionKey = NO;
  result.chunkEncryptionKey = [NSData data];
  return self;
}
- (BOOL) hasChunkLength {
  return result.hasChunkLength;
}
- (int32_t) chunkLength {
  return result.chunkLength;
}
- (ChunkInfoL_Builder*) setChunkLength:(int32_t) value {
  result.hasChunkLength = YES;
  result.chunkLength = value;
  return self;
}
- (ChunkInfoL_Builder*) clearChunkLength {
  result.hasChunkLength = NO;
  result.chunkLength = 0;
  return self;
}
@end

@interface NameValuePairL ()
@property (retain) NSString* name;
@property (retain) NSString* value;
@end

@implementation NameValuePairL

- (BOOL) hasName {
  return !!hasName_;
}
- (void) setHasName:(BOOL) value {
  hasName_ = !!value;
}
@synthesize name;
- (BOOL) hasValue {
  return !!hasValue_;
}
- (void) setHasValue:(BOOL) value {
  hasValue_ = !!value;
}
@synthesize value;
- (void) dealloc {
  self.name = nil;
  self.value = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.name = @"";
    self.value = @"";
  }
  return self;
}
static NameValuePairL* defaultNameValuePairLInstance = nil;
+ (void) initialize {
  if (self == [NameValuePairL class]) {
    defaultNameValuePairLInstance = [[NameValuePairL alloc] init];
  }
}
+ (NameValuePairL*) defaultInstance {
  return defaultNameValuePairLInstance;
}
- (NameValuePairL*) defaultInstance {
  return defaultNameValuePairLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasName) {
    return NO;
  }
  if (!self.hasValue) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasName) {
    [output writeString:1 value:self.name];
  }
  if (self.hasValue) {
    [output writeString:2 value:self.value];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasName) {
    size += computeStringSize(1, self.name);
  }
  if (self.hasValue) {
    size += computeStringSize(2, self.value);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (NameValuePairL*) parseFromData:(NSData*) data {
  return (NameValuePairL*)[[[NameValuePairL builder] mergeFromData:data] build];
}
+ (NameValuePairL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (NameValuePairL*)[[[NameValuePairL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (NameValuePairL*) parseFromInputStream:(NSInputStream*) input {
  return (NameValuePairL*)[[[NameValuePairL builder] mergeFromInputStream:input] build];
}
+ (NameValuePairL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (NameValuePairL*)[[[NameValuePairL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (NameValuePairL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (NameValuePairL*)[[[NameValuePairL builder] mergeFromCodedInputStream:input] build];
}
+ (NameValuePairL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (NameValuePairL*)[[[NameValuePairL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (NameValuePairL_Builder*) builder {
  return [[[NameValuePairL_Builder alloc] init] autorelease];
}
+ (NameValuePairL_Builder*) builderWithPrototype:(NameValuePairL*) prototype {
  return [[NameValuePairL builder] mergeFrom:prototype];
}
- (NameValuePairL_Builder*) builder {
  return [NameValuePairL builder];
}
@end

@interface NameValuePairL_Builder()
@property (retain) NameValuePairL* result;
@end

@implementation NameValuePairL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[NameValuePairL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (NameValuePairL_Builder*) clear {
  self.result = [[[NameValuePairL alloc] init] autorelease];
  return self;
}
- (NameValuePairL_Builder*) clone {
  return [NameValuePairL builderWithPrototype:result];
}
- (NameValuePairL*) defaultInstance {
  return [NameValuePairL defaultInstance];
}
- (NameValuePairL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (NameValuePairL*) buildPartial {
  NameValuePairL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (NameValuePairL_Builder*) mergeFrom:(NameValuePairL*) other {
  if (other == [NameValuePairL defaultInstance]) {
    return self;
  }
  if (other.hasName) {
    [self setName:other.name];
  }
  if (other.hasValue) {
    [self setValue:other.value];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (NameValuePairL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (NameValuePairL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setName:[input readString]];
        break;
      }
      case 18: {
        [self setValue:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasName {
  return result.hasName;
}
- (NSString*) name {
  return result.name;
}
- (NameValuePairL_Builder*) setName:(NSString*) value {
  result.hasName = YES;
  result.name = value;
  return self;
}
- (NameValuePairL_Builder*) clearName {
  result.hasName = NO;
  result.name = @"";
  return self;
}
- (BOOL) hasValue {
  return result.hasValue;
}
- (NSString*) value {
  return result.value;
}
- (NameValuePairL_Builder*) setValue:(NSString*) value {
  result.hasValue = YES;
  result.value = value;
  return self;
}
- (NameValuePairL_Builder*) clearValue {
  result.hasValue = NO;
  result.value = @"";
  return self;
}
@end

@interface HostInfoL ()
@property (retain) NSString* hostname;
@property int32_t port;
@property (retain) NSString* method;
@property (retain) NSString* uri;
@property (retain) NSString* transportProtocol;
@property (retain) NSString* transportProtocolVersion;
@property (retain) NSString* scheme;
@property (retain) NSMutableArray* mutableHeadersList;
@property (retain) NSString* provider;
@end

@implementation HostInfoL

- (BOOL) hasHostname {
  return !!hasHostname_;
}
- (void) setHasHostname:(BOOL) value {
  hasHostname_ = !!value;
}
@synthesize hostname;
- (BOOL) hasPort {
  return !!hasPort_;
}
- (void) setHasPort:(BOOL) value {
  hasPort_ = !!value;
}
@synthesize port;
- (BOOL) hasMethod {
  return !!hasMethod_;
}
- (void) setHasMethod:(BOOL) value {
  hasMethod_ = !!value;
}
@synthesize method;
- (BOOL) hasUri {
  return !!hasUri_;
}
- (void) setHasUri:(BOOL) value {
  hasUri_ = !!value;
}
@synthesize uri;
- (BOOL) hasTransportProtocol {
  return !!hasTransportProtocol_;
}
- (void) setHasTransportProtocol:(BOOL) value {
  hasTransportProtocol_ = !!value;
}
@synthesize transportProtocol;
- (BOOL) hasTransportProtocolVersion {
  return !!hasTransportProtocolVersion_;
}
- (void) setHasTransportProtocolVersion:(BOOL) value {
  hasTransportProtocolVersion_ = !!value;
}
@synthesize transportProtocolVersion;
- (BOOL) hasScheme {
  return !!hasScheme_;
}
- (void) setHasScheme:(BOOL) value {
  hasScheme_ = !!value;
}
@synthesize scheme;
@synthesize mutableHeadersList;
- (BOOL) hasProvider {
  return !!hasProvider_;
}
- (void) setHasProvider:(BOOL) value {
  hasProvider_ = !!value;
}
@synthesize provider;
- (void) dealloc {
  self.hostname = nil;
  self.method = nil;
  self.uri = nil;
  self.transportProtocol = nil;
  self.transportProtocolVersion = nil;
  self.scheme = nil;
  self.mutableHeadersList = nil;
  self.provider = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.hostname = @"";
    self.port = 0;
    self.method = @"";
    self.uri = @"";
    self.transportProtocol = @"";
    self.transportProtocolVersion = @"";
    self.scheme = @"";
    self.provider = @"";
  }
  return self;
}
static HostInfoL* defaultHostInfoLInstance = nil;
+ (void) initialize {
  if (self == [HostInfoL class]) {
    defaultHostInfoLInstance = [[HostInfoL alloc] init];
  }
}
+ (HostInfoL*) defaultInstance {
  return defaultHostInfoLInstance;
}
- (HostInfoL*) defaultInstance {
  return defaultHostInfoLInstance;
}
- (NSArray*) headersList {
  return mutableHeadersList;
}
- (NameValuePairL*) headersAtIndex:(int32_t) index {
  id value = [mutableHeadersList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasHostname) {
    return NO;
  }
  if (!self.hasPort) {
    return NO;
  }
  if (!self.hasMethod) {
    return NO;
  }
  if (!self.hasUri) {
    return NO;
  }
  if (!self.hasTransportProtocol) {
    return NO;
  }
  if (!self.hasTransportProtocolVersion) {
    return NO;
  }
  if (!self.hasScheme) {
    return NO;
  }
  for (NameValuePairL* element in self.headersList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasHostname) {
    [output writeString:1 value:self.hostname];
  }
  if (self.hasPort) {
    [output writeUInt32:2 value:self.port];
  }
  if (self.hasMethod) {
    [output writeString:3 value:self.method];
  }
  if (self.hasUri) {
    [output writeString:4 value:self.uri];
  }
  if (self.hasTransportProtocol) {
    [output writeString:5 value:self.transportProtocol];
  }
  if (self.hasTransportProtocolVersion) {
    [output writeString:6 value:self.transportProtocolVersion];
  }
  if (self.hasScheme) {
    [output writeString:7 value:self.scheme];
  }
  for (NameValuePairL* element in self.headersList) {
    [output writeMessage:8 value:element];
  }
  if (self.hasProvider) {
    [output writeString:9 value:self.provider];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasHostname) {
    size += computeStringSize(1, self.hostname);
  }
  if (self.hasPort) {
    size += computeUInt32Size(2, self.port);
  }
  if (self.hasMethod) {
    size += computeStringSize(3, self.method);
  }
  if (self.hasUri) {
    size += computeStringSize(4, self.uri);
  }
  if (self.hasTransportProtocol) {
    size += computeStringSize(5, self.transportProtocol);
  }
  if (self.hasTransportProtocolVersion) {
    size += computeStringSize(6, self.transportProtocolVersion);
  }
  if (self.hasScheme) {
    size += computeStringSize(7, self.scheme);
  }
  for (NameValuePairL* element in self.headersList) {
    size += computeMessageSize(8, element);
  }
  if (self.hasProvider) {
    size += computeStringSize(9, self.provider);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (HostInfoL*) parseFromData:(NSData*) data {
  return (HostInfoL*)[[[HostInfoL builder] mergeFromData:data] build];
}
+ (HostInfoL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HostInfoL*)[[[HostInfoL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (HostInfoL*) parseFromInputStream:(NSInputStream*) input {
  return (HostInfoL*)[[[HostInfoL builder] mergeFromInputStream:input] build];
}
+ (HostInfoL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HostInfoL*)[[[HostInfoL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HostInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (HostInfoL*)[[[HostInfoL builder] mergeFromCodedInputStream:input] build];
}
+ (HostInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (HostInfoL*)[[[HostInfoL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (HostInfoL_Builder*) builder {
  return [[[HostInfoL_Builder alloc] init] autorelease];
}
+ (HostInfoL_Builder*) builderWithPrototype:(HostInfoL*) prototype {
  return [[HostInfoL builder] mergeFrom:prototype];
}
- (HostInfoL_Builder*) builder {
  return [HostInfoL builder];
}
@end

@interface HostInfoL_Builder()
@property (retain) HostInfoL* result;
@end

@implementation HostInfoL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[HostInfoL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (HostInfoL_Builder*) clear {
  self.result = [[[HostInfoL alloc] init] autorelease];
  return self;
}
- (HostInfoL_Builder*) clone {
  return [HostInfoL builderWithPrototype:result];
}
- (HostInfoL*) defaultInstance {
  return [HostInfoL defaultInstance];
}
- (HostInfoL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (HostInfoL*) buildPartial {
  HostInfoL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (HostInfoL_Builder*) mergeFrom:(HostInfoL*) other {
  if (other == [HostInfoL defaultInstance]) {
    return self;
  }
  if (other.hasHostname) {
    [self setHostname:other.hostname];
  }
  if (other.hasPort) {
    [self setPort:other.port];
  }
  if (other.hasMethod) {
    [self setMethod:other.method];
  }
  if (other.hasUri) {
    [self setUri:other.uri];
  }
  if (other.hasTransportProtocol) {
    [self setTransportProtocol:other.transportProtocol];
  }
  if (other.hasTransportProtocolVersion) {
    [self setTransportProtocolVersion:other.transportProtocolVersion];
  }
  if (other.hasScheme) {
    [self setScheme:other.scheme];
  }
  if (other.mutableHeadersList.count > 0) {
    if (result.mutableHeadersList == nil) {
      result.mutableHeadersList = [NSMutableArray array];
    }
    [result.mutableHeadersList addObjectsFromArray:other.mutableHeadersList];
  }
  if (other.hasProvider) {
    [self setProvider:other.provider];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (HostInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (HostInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setHostname:[input readString]];
        break;
      }
      case 16: {
        [self setPort:[input readUInt32]];
        break;
      }
      case 26: {
        [self setMethod:[input readString]];
        break;
      }
      case 34: {
        [self setUri:[input readString]];
        break;
      }
      case 42: {
        [self setTransportProtocol:[input readString]];
        break;
      }
      case 50: {
        [self setTransportProtocolVersion:[input readString]];
        break;
      }
      case 58: {
        [self setScheme:[input readString]];
        break;
      }
      case 66: {
        NameValuePairL_Builder* subBuilder = [NameValuePairL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addHeaders:[subBuilder buildPartial]];
        break;
      }
      case 74: {
        [self setProvider:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasHostname {
  return result.hasHostname;
}
- (NSString*) hostname {
  return result.hostname;
}
- (HostInfoL_Builder*) setHostname:(NSString*) value {
  result.hasHostname = YES;
  result.hostname = value;
  return self;
}
- (HostInfoL_Builder*) clearHostname {
  result.hasHostname = NO;
  result.hostname = @"";
  return self;
}
- (BOOL) hasPort {
  return result.hasPort;
}
- (int32_t) port {
  return result.port;
}
- (HostInfoL_Builder*) setPort:(int32_t) value {
  result.hasPort = YES;
  result.port = value;
  return self;
}
- (HostInfoL_Builder*) clearPort {
  result.hasPort = NO;
  result.port = 0;
  return self;
}
- (BOOL) hasMethod {
  return result.hasMethod;
}
- (NSString*) method {
  return result.method;
}
- (HostInfoL_Builder*) setMethod:(NSString*) value {
  result.hasMethod = YES;
  result.method = value;
  return self;
}
- (HostInfoL_Builder*) clearMethod {
  result.hasMethod = NO;
  result.method = @"";
  return self;
}
- (BOOL) hasUri {
  return result.hasUri;
}
- (NSString*) uri {
  return result.uri;
}
- (HostInfoL_Builder*) setUri:(NSString*) value {
  result.hasUri = YES;
  result.uri = value;
  return self;
}
- (HostInfoL_Builder*) clearUri {
  result.hasUri = NO;
  result.uri = @"";
  return self;
}
- (BOOL) hasTransportProtocol {
  return result.hasTransportProtocol;
}
- (NSString*) transportProtocol {
  return result.transportProtocol;
}
- (HostInfoL_Builder*) setTransportProtocol:(NSString*) value {
  result.hasTransportProtocol = YES;
  result.transportProtocol = value;
  return self;
}
- (HostInfoL_Builder*) clearTransportProtocol {
  result.hasTransportProtocol = NO;
  result.transportProtocol = @"";
  return self;
}
- (BOOL) hasTransportProtocolVersion {
  return result.hasTransportProtocolVersion;
}
- (NSString*) transportProtocolVersion {
  return result.transportProtocolVersion;
}
- (HostInfoL_Builder*) setTransportProtocolVersion:(NSString*) value {
  result.hasTransportProtocolVersion = YES;
  result.transportProtocolVersion = value;
  return self;
}
- (HostInfoL_Builder*) clearTransportProtocolVersion {
  result.hasTransportProtocolVersion = NO;
  result.transportProtocolVersion = @"";
  return self;
}
- (BOOL) hasScheme {
  return result.hasScheme;
}
- (NSString*) scheme {
  return result.scheme;
}
- (HostInfoL_Builder*) setScheme:(NSString*) value {
  result.hasScheme = YES;
  result.scheme = value;
  return self;
}
- (HostInfoL_Builder*) clearScheme {
  result.hasScheme = NO;
  result.scheme = @"";
  return self;
}
- (NSArray*) headersList {
  if (result.mutableHeadersList == nil) { return [NSArray array]; }
  return result.mutableHeadersList;
}
- (NameValuePairL*) headersAtIndex:(int32_t) index {
  return [result headersAtIndex:index];
}
- (HostInfoL_Builder*) replaceHeadersAtIndex:(int32_t) index with:(NameValuePairL*) value {
  [result.mutableHeadersList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (HostInfoL_Builder*) addAllHeaders:(NSArray*) values {
  if (result.mutableHeadersList == nil) {
    result.mutableHeadersList = [NSMutableArray array];
  }
  [result.mutableHeadersList addObjectsFromArray:values];
  return self;
}
- (HostInfoL_Builder*) clearHeadersList {
  result.mutableHeadersList = nil;
  return self;
}
- (HostInfoL_Builder*) addHeaders:(NameValuePairL*) value {
  if (result.mutableHeadersList == nil) {
    result.mutableHeadersList = [NSMutableArray array];
  }
  [result.mutableHeadersList addObject:value];
  return self;
}
- (BOOL) hasProvider {
  return result.hasProvider;
}
- (NSString*) provider {
  return result.provider;
}
- (HostInfoL_Builder*) setProvider:(NSString*) value {
  result.hasProvider = YES;
  result.provider = value;
  return self;
}
- (HostInfoL_Builder*) clearProvider {
  result.hasProvider = NO;
  result.provider = @"";
  return self;
}
@end

@interface ErrorResponseL ()
@property (retain) NSString* domain;
@property int32_t errorCode;
@property (retain) NSString* errorDescription;
@property (retain) NSMutableArray* mutableUnderlyingErrorsList;
@property (retain) NSMutableArray* mutableNameValuePairList;
@end

@implementation ErrorResponseL

- (BOOL) hasDomain {
  return !!hasDomain_;
}
- (void) setHasDomain:(BOOL) value {
  hasDomain_ = !!value;
}
@synthesize domain;
- (BOOL) hasErrorCode {
  return !!hasErrorCode_;
}
- (void) setHasErrorCode:(BOOL) value {
  hasErrorCode_ = !!value;
}
@synthesize errorCode;
- (BOOL) hasErrorDescription {
  return !!hasErrorDescription_;
}
- (void) setHasErrorDescription:(BOOL) value {
  hasErrorDescription_ = !!value;
}
@synthesize errorDescription;
@synthesize mutableUnderlyingErrorsList;
@synthesize mutableNameValuePairList;
- (void) dealloc {
  self.domain = nil;
  self.errorDescription = nil;
  self.mutableUnderlyingErrorsList = nil;
  self.mutableNameValuePairList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.domain = @"";
    self.errorCode = 0;
    self.errorDescription = @"";
  }
  return self;
}
static ErrorResponseL* defaultErrorResponseLInstance = nil;
+ (void) initialize {
  if (self == [ErrorResponseL class]) {
    defaultErrorResponseLInstance = [[ErrorResponseL alloc] init];
  }
}
+ (ErrorResponseL*) defaultInstance {
  return defaultErrorResponseLInstance;
}
- (ErrorResponseL*) defaultInstance {
  return defaultErrorResponseLInstance;
}
- (NSArray*) underlyingErrorsList {
  return mutableUnderlyingErrorsList;
}
- (ErrorResponseL*) underlyingErrorsAtIndex:(int32_t) index {
  id value = [mutableUnderlyingErrorsList objectAtIndex:index];
  return value;
}
- (NSArray*) nameValuePairList {
  return mutableNameValuePairList;
}
- (NameValuePairL*) nameValuePairAtIndex:(int32_t) index {
  id value = [mutableNameValuePairList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasDomain) {
    return NO;
  }
  if (!self.hasErrorCode) {
    return NO;
  }
  for (ErrorResponseL* element in self.underlyingErrorsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (NameValuePairL* element in self.nameValuePairList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasDomain) {
    [output writeString:1 value:self.domain];
  }
  if (self.hasErrorCode) {
    [output writeInt32:2 value:self.errorCode];
  }
  if (self.hasErrorDescription) {
    [output writeString:3 value:self.errorDescription];
  }
  for (ErrorResponseL* element in self.underlyingErrorsList) {
    [output writeMessage:4 value:element];
  }
  for (NameValuePairL* element in self.nameValuePairList) {
    [output writeMessage:5 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasDomain) {
    size += computeStringSize(1, self.domain);
  }
  if (self.hasErrorCode) {
    size += computeInt32Size(2, self.errorCode);
  }
  if (self.hasErrorDescription) {
    size += computeStringSize(3, self.errorDescription);
  }
  for (ErrorResponseL* element in self.underlyingErrorsList) {
    size += computeMessageSize(4, element);
  }
  for (NameValuePairL* element in self.nameValuePairList) {
    size += computeMessageSize(5, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ErrorResponseL*) parseFromData:(NSData*) data {
  return (ErrorResponseL*)[[[ErrorResponseL builder] mergeFromData:data] build];
}
+ (ErrorResponseL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ErrorResponseL*)[[[ErrorResponseL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ErrorResponseL*) parseFromInputStream:(NSInputStream*) input {
  return (ErrorResponseL*)[[[ErrorResponseL builder] mergeFromInputStream:input] build];
}
+ (ErrorResponseL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ErrorResponseL*)[[[ErrorResponseL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ErrorResponseL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ErrorResponseL*)[[[ErrorResponseL builder] mergeFromCodedInputStream:input] build];
}
+ (ErrorResponseL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ErrorResponseL*)[[[ErrorResponseL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ErrorResponseL_Builder*) builder {
  return [[[ErrorResponseL_Builder alloc] init] autorelease];
}
+ (ErrorResponseL_Builder*) builderWithPrototype:(ErrorResponseL*) prototype {
  return [[ErrorResponseL builder] mergeFrom:prototype];
}
- (ErrorResponseL_Builder*) builder {
  return [ErrorResponseL builder];
}
@end

@interface ErrorResponseL_Builder()
@property (retain) ErrorResponseL* result;
@end

@implementation ErrorResponseL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ErrorResponseL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ErrorResponseL_Builder*) clear {
  self.result = [[[ErrorResponseL alloc] init] autorelease];
  return self;
}
- (ErrorResponseL_Builder*) clone {
  return [ErrorResponseL builderWithPrototype:result];
}
- (ErrorResponseL*) defaultInstance {
  return [ErrorResponseL defaultInstance];
}
- (ErrorResponseL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ErrorResponseL*) buildPartial {
  ErrorResponseL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ErrorResponseL_Builder*) mergeFrom:(ErrorResponseL*) other {
  if (other == [ErrorResponseL defaultInstance]) {
    return self;
  }
  if (other.hasDomain) {
    [self setDomain:other.domain];
  }
  if (other.hasErrorCode) {
    [self setErrorCode:other.errorCode];
  }
  if (other.hasErrorDescription) {
    [self setErrorDescription:other.errorDescription];
  }
  if (other.mutableUnderlyingErrorsList.count > 0) {
    if (result.mutableUnderlyingErrorsList == nil) {
      result.mutableUnderlyingErrorsList = [NSMutableArray array];
    }
    [result.mutableUnderlyingErrorsList addObjectsFromArray:other.mutableUnderlyingErrorsList];
  }
  if (other.mutableNameValuePairList.count > 0) {
    if (result.mutableNameValuePairList == nil) {
      result.mutableNameValuePairList = [NSMutableArray array];
    }
    [result.mutableNameValuePairList addObjectsFromArray:other.mutableNameValuePairList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ErrorResponseL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ErrorResponseL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setDomain:[input readString]];
        break;
      }
      case 16: {
        [self setErrorCode:[input readInt32]];
        break;
      }
      case 26: {
        [self setErrorDescription:[input readString]];
        break;
      }
      case 34: {
        ErrorResponseL_Builder* subBuilder = [ErrorResponseL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addUnderlyingErrors:[subBuilder buildPartial]];
        break;
      }
      case 42: {
        NameValuePairL_Builder* subBuilder = [NameValuePairL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addNameValuePair:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasDomain {
  return result.hasDomain;
}
- (NSString*) domain {
  return result.domain;
}
- (ErrorResponseL_Builder*) setDomain:(NSString*) value {
  result.hasDomain = YES;
  result.domain = value;
  return self;
}
- (ErrorResponseL_Builder*) clearDomain {
  result.hasDomain = NO;
  result.domain = @"";
  return self;
}
- (BOOL) hasErrorCode {
  return result.hasErrorCode;
}
- (int32_t) errorCode {
  return result.errorCode;
}
- (ErrorResponseL_Builder*) setErrorCode:(int32_t) value {
  result.hasErrorCode = YES;
  result.errorCode = value;
  return self;
}
- (ErrorResponseL_Builder*) clearErrorCode {
  result.hasErrorCode = NO;
  result.errorCode = 0;
  return self;
}
- (BOOL) hasErrorDescription {
  return result.hasErrorDescription;
}
- (NSString*) errorDescription {
  return result.errorDescription;
}
- (ErrorResponseL_Builder*) setErrorDescription:(NSString*) value {
  result.hasErrorDescription = YES;
  result.errorDescription = value;
  return self;
}
- (ErrorResponseL_Builder*) clearErrorDescription {
  result.hasErrorDescription = NO;
  result.errorDescription = @"";
  return self;
}
- (NSArray*) underlyingErrorsList {
  if (result.mutableUnderlyingErrorsList == nil) { return [NSArray array]; }
  return result.mutableUnderlyingErrorsList;
}
- (ErrorResponseL*) underlyingErrorsAtIndex:(int32_t) index {
  return [result underlyingErrorsAtIndex:index];
}
- (ErrorResponseL_Builder*) replaceUnderlyingErrorsAtIndex:(int32_t) index with:(ErrorResponseL*) value {
  [result.mutableUnderlyingErrorsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (ErrorResponseL_Builder*) addAllUnderlyingErrors:(NSArray*) values {
  if (result.mutableUnderlyingErrorsList == nil) {
    result.mutableUnderlyingErrorsList = [NSMutableArray array];
  }
  [result.mutableUnderlyingErrorsList addObjectsFromArray:values];
  return self;
}
- (ErrorResponseL_Builder*) clearUnderlyingErrorsList {
  result.mutableUnderlyingErrorsList = nil;
  return self;
}
- (ErrorResponseL_Builder*) addUnderlyingErrors:(ErrorResponseL*) value {
  if (result.mutableUnderlyingErrorsList == nil) {
    result.mutableUnderlyingErrorsList = [NSMutableArray array];
  }
  [result.mutableUnderlyingErrorsList addObject:value];
  return self;
}
- (NSArray*) nameValuePairList {
  if (result.mutableNameValuePairList == nil) { return [NSArray array]; }
  return result.mutableNameValuePairList;
}
- (NameValuePairL*) nameValuePairAtIndex:(int32_t) index {
  return [result nameValuePairAtIndex:index];
}
- (ErrorResponseL_Builder*) replaceNameValuePairAtIndex:(int32_t) index with:(NameValuePairL*) value {
  [result.mutableNameValuePairList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (ErrorResponseL_Builder*) addAllNameValuePair:(NSArray*) values {
  if (result.mutableNameValuePairList == nil) {
    result.mutableNameValuePairList = [NSMutableArray array];
  }
  [result.mutableNameValuePairList addObjectsFromArray:values];
  return self;
}
- (ErrorResponseL_Builder*) clearNameValuePairList {
  result.mutableNameValuePairList = nil;
  return self;
}
- (ErrorResponseL_Builder*) addNameValuePair:(NameValuePairL*) value {
  if (result.mutableNameValuePairList == nil) {
    result.mutableNameValuePairList = [NSMutableArray array];
  }
  [result.mutableNameValuePairList addObject:value];
  return self;
}
@end

@interface FileErrorL ()
@property (retain) NSData* fileChecksum;
@property (retain) ErrorResponseL* errorResponse;
@end

@implementation FileErrorL

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (void) dealloc {
  self.fileChecksum = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.errorResponse = [ErrorResponseL defaultInstance];
  }
  return self;
}
static FileErrorL* defaultFileErrorLInstance = nil;
+ (void) initialize {
  if (self == [FileErrorL class]) {
    defaultFileErrorLInstance = [[FileErrorL alloc] init];
  }
}
+ (FileErrorL*) defaultInstance {
  return defaultFileErrorLInstance;
}
- (FileErrorL*) defaultInstance {
  return defaultFileErrorLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileErrorL*) parseFromData:(NSData*) data {
  return (FileErrorL*)[[[FileErrorL builder] mergeFromData:data] build];
}
+ (FileErrorL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileErrorL*)[[[FileErrorL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileErrorL*) parseFromInputStream:(NSInputStream*) input {
  return (FileErrorL*)[[[FileErrorL builder] mergeFromInputStream:input] build];
}
+ (FileErrorL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileErrorL*)[[[FileErrorL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileErrorL*)[[[FileErrorL builder] mergeFromCodedInputStream:input] build];
}
+ (FileErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileErrorL*)[[[FileErrorL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileErrorL_Builder*) builder {
  return [[[FileErrorL_Builder alloc] init] autorelease];
}
+ (FileErrorL_Builder*) builderWithPrototype:(FileErrorL*) prototype {
  return [[FileErrorL builder] mergeFrom:prototype];
}
- (FileErrorL_Builder*) builder {
  return [FileErrorL builder];
}
@end

@interface FileErrorL_Builder()
@property (retain) FileErrorL* result;
@end

@implementation FileErrorL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileErrorL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileErrorL_Builder*) clear {
  self.result = [[[FileErrorL alloc] init] autorelease];
  return self;
}
- (FileErrorL_Builder*) clone {
  return [FileErrorL builderWithPrototype:result];
}
- (FileErrorL*) defaultInstance {
  return [FileErrorL defaultInstance];
}
- (FileErrorL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileErrorL*) buildPartial {
  FileErrorL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileErrorL_Builder*) mergeFrom:(FileErrorL*) other {
  if (other == [FileErrorL defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        ErrorResponseL_Builder* subBuilder = [ErrorResponseL builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileErrorL_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileErrorL_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponseL*) errorResponse {
  return result.errorResponse;
}
- (FileErrorL_Builder*) setErrorResponse:(ErrorResponseL*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (FileErrorL_Builder*) setErrorResponseBuilder:(ErrorResponseL_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (FileErrorL_Builder*) mergeErrorResponse:(ErrorResponseL*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponseL defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponseL builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (FileErrorL_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponseL defaultInstance];
  return self;
}
@end

@interface ChunkErrorL ()
@property (retain) NSData* chunkChecksum;
@property (retain) ErrorResponseL* errorResponse;
@end

@implementation ChunkErrorL

- (BOOL) hasChunkChecksum {
  return !!hasChunkChecksum_;
}
- (void) setHasChunkChecksum:(BOOL) value {
  hasChunkChecksum_ = !!value;
}
@synthesize chunkChecksum;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (void) dealloc {
  self.chunkChecksum = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.chunkChecksum = [NSData data];
    self.errorResponse = [ErrorResponseL defaultInstance];
  }
  return self;
}
static ChunkErrorL* defaultChunkErrorLInstance = nil;
+ (void) initialize {
  if (self == [ChunkErrorL class]) {
    defaultChunkErrorLInstance = [[ChunkErrorL alloc] init];
  }
}
+ (ChunkErrorL*) defaultInstance {
  return defaultChunkErrorLInstance;
}
- (ChunkErrorL*) defaultInstance {
  return defaultChunkErrorLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChunkChecksum) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChunkChecksum) {
    [output writeData:1 value:self.chunkChecksum];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChunkChecksum) {
    size += computeDataSize(1, self.chunkChecksum);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkErrorL*) parseFromData:(NSData*) data {
  return (ChunkErrorL*)[[[ChunkErrorL builder] mergeFromData:data] build];
}
+ (ChunkErrorL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorL*)[[[ChunkErrorL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorL*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkErrorL*)[[[ChunkErrorL builder] mergeFromInputStream:input] build];
}
+ (ChunkErrorL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorL*)[[[ChunkErrorL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkErrorL*)[[[ChunkErrorL builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorL*)[[[ChunkErrorL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorL_Builder*) builder {
  return [[[ChunkErrorL_Builder alloc] init] autorelease];
}
+ (ChunkErrorL_Builder*) builderWithPrototype:(ChunkErrorL*) prototype {
  return [[ChunkErrorL builder] mergeFrom:prototype];
}
- (ChunkErrorL_Builder*) builder {
  return [ChunkErrorL builder];
}
@end

@interface ChunkErrorL_Builder()
@property (retain) ChunkErrorL* result;
@end

@implementation ChunkErrorL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkErrorL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkErrorL_Builder*) clear {
  self.result = [[[ChunkErrorL alloc] init] autorelease];
  return self;
}
- (ChunkErrorL_Builder*) clone {
  return [ChunkErrorL builderWithPrototype:result];
}
- (ChunkErrorL*) defaultInstance {
  return [ChunkErrorL defaultInstance];
}
- (ChunkErrorL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkErrorL*) buildPartial {
  ChunkErrorL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkErrorL_Builder*) mergeFrom:(ChunkErrorL*) other {
  if (other == [ChunkErrorL defaultInstance]) {
    return self;
  }
  if (other.hasChunkChecksum) {
    [self setChunkChecksum:other.chunkChecksum];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChunkChecksum:[input readData]];
        break;
      }
      case 18: {
        ErrorResponseL_Builder* subBuilder = [ErrorResponseL builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasChunkChecksum {
  return result.hasChunkChecksum;
}
- (NSData*) chunkChecksum {
  return result.chunkChecksum;
}
- (ChunkErrorL_Builder*) setChunkChecksum:(NSData*) value {
  result.hasChunkChecksum = YES;
  result.chunkChecksum = value;
  return self;
}
- (ChunkErrorL_Builder*) clearChunkChecksum {
  result.hasChunkChecksum = NO;
  result.chunkChecksum = [NSData data];
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponseL*) errorResponse {
  return result.errorResponse;
}
- (ChunkErrorL_Builder*) setErrorResponse:(ErrorResponseL*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (ChunkErrorL_Builder*) setErrorResponseBuilder:(ErrorResponseL_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (ChunkErrorL_Builder*) mergeErrorResponse:(ErrorResponseL*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponseL defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponseL builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (ChunkErrorL_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponseL defaultInstance];
  return self;
}
@end

@interface ChunkErrorIndexL ()
@property (retain) NSData* chunkChecksum;
@property (retain) ErrorResponseL* errorResponse;
@property int32_t chunkIndex;
@end

@implementation ChunkErrorIndexL

- (BOOL) hasChunkChecksum {
  return !!hasChunkChecksum_;
}
- (void) setHasChunkChecksum:(BOOL) value {
  hasChunkChecksum_ = !!value;
}
@synthesize chunkChecksum;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (BOOL) hasChunkIndex {
  return !!hasChunkIndex_;
}
- (void) setHasChunkIndex:(BOOL) value {
  hasChunkIndex_ = !!value;
}
@synthesize chunkIndex;
- (void) dealloc {
  self.chunkChecksum = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.chunkChecksum = [NSData data];
    self.errorResponse = [ErrorResponseL defaultInstance];
    self.chunkIndex = 0;
  }
  return self;
}
static ChunkErrorIndexL* defaultChunkErrorIndexLInstance = nil;
+ (void) initialize {
  if (self == [ChunkErrorIndexL class]) {
    defaultChunkErrorIndexLInstance = [[ChunkErrorIndexL alloc] init];
  }
}
+ (ChunkErrorIndexL*) defaultInstance {
  return defaultChunkErrorIndexLInstance;
}
- (ChunkErrorIndexL*) defaultInstance {
  return defaultChunkErrorIndexLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasChunkChecksum) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.hasChunkIndex) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasChunkChecksum) {
    [output writeData:1 value:self.chunkChecksum];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  if (self.hasChunkIndex) {
    [output writeUInt32:3 value:self.chunkIndex];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasChunkChecksum) {
    size += computeDataSize(1, self.chunkChecksum);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  if (self.hasChunkIndex) {
    size += computeUInt32Size(3, self.chunkIndex);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkErrorIndexL*) parseFromData:(NSData*) data {
  return (ChunkErrorIndexL*)[[[ChunkErrorIndexL builder] mergeFromData:data] build];
}
+ (ChunkErrorIndexL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorIndexL*)[[[ChunkErrorIndexL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorIndexL*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkErrorIndexL*)[[[ChunkErrorIndexL builder] mergeFromInputStream:input] build];
}
+ (ChunkErrorIndexL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorIndexL*)[[[ChunkErrorIndexL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorIndexL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkErrorIndexL*)[[[ChunkErrorIndexL builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkErrorIndexL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkErrorIndexL*)[[[ChunkErrorIndexL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkErrorIndexL_Builder*) builder {
  return [[[ChunkErrorIndexL_Builder alloc] init] autorelease];
}
+ (ChunkErrorIndexL_Builder*) builderWithPrototype:(ChunkErrorIndexL*) prototype {
  return [[ChunkErrorIndexL builder] mergeFrom:prototype];
}
- (ChunkErrorIndexL_Builder*) builder {
  return [ChunkErrorIndexL builder];
}
@end

@interface ChunkErrorIndexL_Builder()
@property (retain) ChunkErrorIndexL* result;
@end

@implementation ChunkErrorIndexL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkErrorIndexL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkErrorIndexL_Builder*) clear {
  self.result = [[[ChunkErrorIndexL alloc] init] autorelease];
  return self;
}
- (ChunkErrorIndexL_Builder*) clone {
  return [ChunkErrorIndexL builderWithPrototype:result];
}
- (ChunkErrorIndexL*) defaultInstance {
  return [ChunkErrorIndexL defaultInstance];
}
- (ChunkErrorIndexL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkErrorIndexL*) buildPartial {
  ChunkErrorIndexL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkErrorIndexL_Builder*) mergeFrom:(ChunkErrorIndexL*) other {
  if (other == [ChunkErrorIndexL defaultInstance]) {
    return self;
  }
  if (other.hasChunkChecksum) {
    [self setChunkChecksum:other.chunkChecksum];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  if (other.hasChunkIndex) {
    [self setChunkIndex:other.chunkIndex];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkErrorIndexL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkErrorIndexL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setChunkChecksum:[input readData]];
        break;
      }
      case 18: {
        ErrorResponseL_Builder* subBuilder = [ErrorResponseL builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setChunkIndex:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasChunkChecksum {
  return result.hasChunkChecksum;
}
- (NSData*) chunkChecksum {
  return result.chunkChecksum;
}
- (ChunkErrorIndexL_Builder*) setChunkChecksum:(NSData*) value {
  result.hasChunkChecksum = YES;
  result.chunkChecksum = value;
  return self;
}
- (ChunkErrorIndexL_Builder*) clearChunkChecksum {
  result.hasChunkChecksum = NO;
  result.chunkChecksum = [NSData data];
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponseL*) errorResponse {
  return result.errorResponse;
}
- (ChunkErrorIndexL_Builder*) setErrorResponse:(ErrorResponseL*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (ChunkErrorIndexL_Builder*) setErrorResponseBuilder:(ErrorResponseL_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (ChunkErrorIndexL_Builder*) mergeErrorResponse:(ErrorResponseL*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponseL defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponseL builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (ChunkErrorIndexL_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponseL defaultInstance];
  return self;
}
- (BOOL) hasChunkIndex {
  return result.hasChunkIndex;
}
- (int32_t) chunkIndex {
  return result.chunkIndex;
}
- (ChunkErrorIndexL_Builder*) setChunkIndex:(int32_t) value {
  result.hasChunkIndex = YES;
  result.chunkIndex = value;
  return self;
}
- (ChunkErrorIndexL_Builder*) clearChunkIndex {
  result.hasChunkIndex = NO;
  result.chunkIndex = 0;
  return self;
}
@end

@interface FileChunkErrorL ()
@property (retain) NSData* fileChecksum;
@property (retain) NSMutableArray* mutableChunkErrorList;
@end

@implementation FileChunkErrorL

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
@synthesize mutableChunkErrorList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.mutableChunkErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
  }
  return self;
}
static FileChunkErrorL* defaultFileChunkErrorLInstance = nil;
+ (void) initialize {
  if (self == [FileChunkErrorL class]) {
    defaultFileChunkErrorLInstance = [[FileChunkErrorL alloc] init];
  }
}
+ (FileChunkErrorL*) defaultInstance {
  return defaultFileChunkErrorLInstance;
}
- (FileChunkErrorL*) defaultInstance {
  return defaultFileChunkErrorLInstance;
}
- (NSArray*) chunkErrorList {
  return mutableChunkErrorList;
}
- (ChunkErrorIndexL*) chunkErrorAtIndex:(int32_t) index {
  id value = [mutableChunkErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  for (ChunkErrorIndexL* element in self.chunkErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  for (ChunkErrorIndexL* element in self.chunkErrorList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  for (ChunkErrorIndexL* element in self.chunkErrorList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChunkErrorL*) parseFromData:(NSData*) data {
  return (FileChunkErrorL*)[[[FileChunkErrorL builder] mergeFromData:data] build];
}
+ (FileChunkErrorL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkErrorL*)[[[FileChunkErrorL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChunkErrorL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChunkErrorL*)[[[FileChunkErrorL builder] mergeFromInputStream:input] build];
}
+ (FileChunkErrorL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkErrorL*)[[[FileChunkErrorL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChunkErrorL*)[[[FileChunkErrorL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChunkErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkErrorL*)[[[FileChunkErrorL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkErrorL_Builder*) builder {
  return [[[FileChunkErrorL_Builder alloc] init] autorelease];
}
+ (FileChunkErrorL_Builder*) builderWithPrototype:(FileChunkErrorL*) prototype {
  return [[FileChunkErrorL builder] mergeFrom:prototype];
}
- (FileChunkErrorL_Builder*) builder {
  return [FileChunkErrorL builder];
}
@end

@interface FileChunkErrorL_Builder()
@property (retain) FileChunkErrorL* result;
@end

@implementation FileChunkErrorL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChunkErrorL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChunkErrorL_Builder*) clear {
  self.result = [[[FileChunkErrorL alloc] init] autorelease];
  return self;
}
- (FileChunkErrorL_Builder*) clone {
  return [FileChunkErrorL builderWithPrototype:result];
}
- (FileChunkErrorL*) defaultInstance {
  return [FileChunkErrorL defaultInstance];
}
- (FileChunkErrorL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChunkErrorL*) buildPartial {
  FileChunkErrorL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChunkErrorL_Builder*) mergeFrom:(FileChunkErrorL*) other {
  if (other == [FileChunkErrorL defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.mutableChunkErrorList.count > 0) {
    if (result.mutableChunkErrorList == nil) {
      result.mutableChunkErrorList = [NSMutableArray array];
    }
    [result.mutableChunkErrorList addObjectsFromArray:other.mutableChunkErrorList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChunkErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChunkErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        ChunkErrorIndexL_Builder* subBuilder = [ChunkErrorIndexL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkError:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChunkErrorL_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChunkErrorL_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (NSArray*) chunkErrorList {
  if (result.mutableChunkErrorList == nil) { return [NSArray array]; }
  return result.mutableChunkErrorList;
}
- (ChunkErrorIndexL*) chunkErrorAtIndex:(int32_t) index {
  return [result chunkErrorAtIndex:index];
}
- (FileChunkErrorL_Builder*) replaceChunkErrorAtIndex:(int32_t) index with:(ChunkErrorIndexL*) value {
  [result.mutableChunkErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChunkErrorL_Builder*) addAllChunkError:(NSArray*) values {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObjectsFromArray:values];
  return self;
}
- (FileChunkErrorL_Builder*) clearChunkErrorList {
  result.mutableChunkErrorList = nil;
  return self;
}
- (FileChunkErrorL_Builder*) addChunkError:(ChunkErrorIndexL*) value {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObject:value];
  return self;
}
@end

@interface StorageContainerErrorL ()
@property (retain) NSString* storageContainerKey;
@property (retain) ErrorResponseL* errorResponse;
@end

@implementation StorageContainerErrorL

- (BOOL) hasStorageContainerKey {
  return !!hasStorageContainerKey_;
}
- (void) setHasStorageContainerKey:(BOOL) value {
  hasStorageContainerKey_ = !!value;
}
@synthesize storageContainerKey;
- (BOOL) hasErrorResponse {
  return !!hasErrorResponse_;
}
- (void) setHasErrorResponse:(BOOL) value {
  hasErrorResponse_ = !!value;
}
@synthesize errorResponse;
- (void) dealloc {
  self.storageContainerKey = nil;
  self.errorResponse = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.storageContainerKey = @"";
    self.errorResponse = [ErrorResponseL defaultInstance];
  }
  return self;
}
static StorageContainerErrorL* defaultStorageContainerErrorLInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerErrorL class]) {
    defaultStorageContainerErrorLInstance = [[StorageContainerErrorL alloc] init];
  }
}
+ (StorageContainerErrorL*) defaultInstance {
  return defaultStorageContainerErrorLInstance;
}
- (StorageContainerErrorL*) defaultInstance {
  return defaultStorageContainerErrorLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasStorageContainerKey) {
    return NO;
  }
  if (!self.hasErrorResponse) {
    return NO;
  }
  if (!self.errorResponse.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStorageContainerKey) {
    [output writeString:1 value:self.storageContainerKey];
  }
  if (self.hasErrorResponse) {
    [output writeMessage:2 value:self.errorResponse];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStorageContainerKey) {
    size += computeStringSize(1, self.storageContainerKey);
  }
  if (self.hasErrorResponse) {
    size += computeMessageSize(2, self.errorResponse);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerErrorL*) parseFromData:(NSData*) data {
  return (StorageContainerErrorL*)[[[StorageContainerErrorL builder] mergeFromData:data] build];
}
+ (StorageContainerErrorL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorL*)[[[StorageContainerErrorL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorL*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerErrorL*)[[[StorageContainerErrorL builder] mergeFromInputStream:input] build];
}
+ (StorageContainerErrorL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorL*)[[[StorageContainerErrorL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerErrorL*)[[[StorageContainerErrorL builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerErrorL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorL*)[[[StorageContainerErrorL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorL_Builder*) builder {
  return [[[StorageContainerErrorL_Builder alloc] init] autorelease];
}
+ (StorageContainerErrorL_Builder*) builderWithPrototype:(StorageContainerErrorL*) prototype {
  return [[StorageContainerErrorL builder] mergeFrom:prototype];
}
- (StorageContainerErrorL_Builder*) builder {
  return [StorageContainerErrorL builder];
}
@end

@interface StorageContainerErrorL_Builder()
@property (retain) StorageContainerErrorL* result;
@end

@implementation StorageContainerErrorL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerErrorL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerErrorL_Builder*) clear {
  self.result = [[[StorageContainerErrorL alloc] init] autorelease];
  return self;
}
- (StorageContainerErrorL_Builder*) clone {
  return [StorageContainerErrorL builderWithPrototype:result];
}
- (StorageContainerErrorL*) defaultInstance {
  return [StorageContainerErrorL defaultInstance];
}
- (StorageContainerErrorL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerErrorL*) buildPartial {
  StorageContainerErrorL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerErrorL_Builder*) mergeFrom:(StorageContainerErrorL*) other {
  if (other == [StorageContainerErrorL defaultInstance]) {
    return self;
  }
  if (other.hasStorageContainerKey) {
    [self setStorageContainerKey:other.storageContainerKey];
  }
  if (other.hasErrorResponse) {
    [self mergeErrorResponse:other.errorResponse];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerErrorL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setStorageContainerKey:[input readString]];
        break;
      }
      case 18: {
        ErrorResponseL_Builder* subBuilder = [ErrorResponseL builder];
        if (self.hasErrorResponse) {
          [subBuilder mergeFrom:self.errorResponse];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setErrorResponse:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasStorageContainerKey {
  return result.hasStorageContainerKey;
}
- (NSString*) storageContainerKey {
  return result.storageContainerKey;
}
- (StorageContainerErrorL_Builder*) setStorageContainerKey:(NSString*) value {
  result.hasStorageContainerKey = YES;
  result.storageContainerKey = value;
  return self;
}
- (StorageContainerErrorL_Builder*) clearStorageContainerKey {
  result.hasStorageContainerKey = NO;
  result.storageContainerKey = @"";
  return self;
}
- (BOOL) hasErrorResponse {
  return result.hasErrorResponse;
}
- (ErrorResponseL*) errorResponse {
  return result.errorResponse;
}
- (StorageContainerErrorL_Builder*) setErrorResponse:(ErrorResponseL*) value {
  result.hasErrorResponse = YES;
  result.errorResponse = value;
  return self;
}
- (StorageContainerErrorL_Builder*) setErrorResponseBuilder:(ErrorResponseL_Builder*) builderForValue {
  return [self setErrorResponse:[builderForValue build]];
}
- (StorageContainerErrorL_Builder*) mergeErrorResponse:(ErrorResponseL*) value {
  if (result.hasErrorResponse &&
      result.errorResponse != [ErrorResponseL defaultInstance]) {
    result.errorResponse =
      [[[ErrorResponseL builderWithPrototype:result.errorResponse] mergeFrom:value] buildPartial];
  } else {
    result.errorResponse = value;
  }
  result.hasErrorResponse = YES;
  return self;
}
- (StorageContainerErrorL_Builder*) clearErrorResponse {
  result.hasErrorResponse = NO;
  result.errorResponse = [ErrorResponseL defaultInstance];
  return self;
}
@end

@interface MethodCompletionInfoL ()
@property (retain) NSString* url;
@property int32_t responseStatusCode;
@property (retain) NSString* responseStatusLine;
@property (retain) NSMutableArray* mutableVendorResponseHeadersList;
@property (retain) NSData* responseBody;
@property (retain) ErrorResponseL* error;
@property (retain) NSData* clientComputedMd5;
@property (retain) NSMutableArray* mutableVendorNvPairsList;
@property (retain) NSMutableArray* mutableClientNvPairsList;
@property (retain) NSString* storageContainerAuthorizationToken;
@end

@implementation MethodCompletionInfoL

- (BOOL) hasUrl {
  return !!hasUrl_;
}
- (void) setHasUrl:(BOOL) value {
  hasUrl_ = !!value;
}
@synthesize url;
- (BOOL) hasResponseStatusCode {
  return !!hasResponseStatusCode_;
}
- (void) setHasResponseStatusCode:(BOOL) value {
  hasResponseStatusCode_ = !!value;
}
@synthesize responseStatusCode;
- (BOOL) hasResponseStatusLine {
  return !!hasResponseStatusLine_;
}
- (void) setHasResponseStatusLine:(BOOL) value {
  hasResponseStatusLine_ = !!value;
}
@synthesize responseStatusLine;
@synthesize mutableVendorResponseHeadersList;
- (BOOL) hasResponseBody {
  return !!hasResponseBody_;
}
- (void) setHasResponseBody:(BOOL) value {
  hasResponseBody_ = !!value;
}
@synthesize responseBody;
- (BOOL) hasError {
  return !!hasError_;
}
- (void) setHasError:(BOOL) value {
  hasError_ = !!value;
}
@synthesize error;
- (BOOL) hasClientComputedMd5 {
  return !!hasClientComputedMd5_;
}
- (void) setHasClientComputedMd5:(BOOL) value {
  hasClientComputedMd5_ = !!value;
}
@synthesize clientComputedMd5;
@synthesize mutableVendorNvPairsList;
@synthesize mutableClientNvPairsList;
- (BOOL) hasStorageContainerAuthorizationToken {
  return !!hasStorageContainerAuthorizationToken_;
}
- (void) setHasStorageContainerAuthorizationToken:(BOOL) value {
  hasStorageContainerAuthorizationToken_ = !!value;
}
@synthesize storageContainerAuthorizationToken;
- (void) dealloc {
  self.url = nil;
  self.responseStatusLine = nil;
  self.mutableVendorResponseHeadersList = nil;
  self.responseBody = nil;
  self.error = nil;
  self.clientComputedMd5 = nil;
  self.mutableVendorNvPairsList = nil;
  self.mutableClientNvPairsList = nil;
  self.storageContainerAuthorizationToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.url = @"";
    self.responseStatusCode = 0;
    self.responseStatusLine = @"";
    self.responseBody = [NSData data];
    self.error = [ErrorResponseL defaultInstance];
    self.clientComputedMd5 = [NSData data];
    self.storageContainerAuthorizationToken = @"";
  }
  return self;
}
static MethodCompletionInfoL* defaultMethodCompletionInfoLInstance = nil;
+ (void) initialize {
  if (self == [MethodCompletionInfoL class]) {
    defaultMethodCompletionInfoLInstance = [[MethodCompletionInfoL alloc] init];
  }
}
+ (MethodCompletionInfoL*) defaultInstance {
  return defaultMethodCompletionInfoLInstance;
}
- (MethodCompletionInfoL*) defaultInstance {
  return defaultMethodCompletionInfoLInstance;
}
- (NSArray*) vendorResponseHeadersList {
  return mutableVendorResponseHeadersList;
}
- (NameValuePairL*) vendorResponseHeadersAtIndex:(int32_t) index {
  id value = [mutableVendorResponseHeadersList objectAtIndex:index];
  return value;
}
- (NSArray*) vendorNvPairsList {
  return mutableVendorNvPairsList;
}
- (NameValuePairL*) vendorNvPairsAtIndex:(int32_t) index {
  id value = [mutableVendorNvPairsList objectAtIndex:index];
  return value;
}
- (NSArray*) clientNvPairsList {
  return mutableClientNvPairsList;
}
- (NameValuePairL*) clientNvPairsAtIndex:(int32_t) index {
  id value = [mutableClientNvPairsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasUrl) {
    return NO;
  }
  if (!self.hasResponseStatusCode) {
    return NO;
  }
  if (!self.hasStorageContainerAuthorizationToken) {
    return NO;
  }
  for (NameValuePairL* element in self.vendorResponseHeadersList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  if (self.hasError) {
    if (!self.error.isInitialized) {
      return NO;
    }
  }
  for (NameValuePairL* element in self.vendorNvPairsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (NameValuePairL* element in self.clientNvPairsList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasUrl) {
    [output writeString:1 value:self.url];
  }
  if (self.hasResponseStatusCode) {
    [output writeUInt32:2 value:self.responseStatusCode];
  }
  if (self.hasResponseStatusLine) {
    [output writeString:3 value:self.responseStatusLine];
  }
  for (NameValuePairL* element in self.vendorResponseHeadersList) {
    [output writeMessage:4 value:element];
  }
  if (self.hasResponseBody) {
    [output writeData:5 value:self.responseBody];
  }
  if (self.hasError) {
    [output writeMessage:6 value:self.error];
  }
  if (self.hasClientComputedMd5) {
    [output writeData:7 value:self.clientComputedMd5];
  }
  for (NameValuePairL* element in self.vendorNvPairsList) {
    [output writeMessage:8 value:element];
  }
  for (NameValuePairL* element in self.clientNvPairsList) {
    [output writeMessage:9 value:element];
  }
  if (self.hasStorageContainerAuthorizationToken) {
    [output writeString:10 value:self.storageContainerAuthorizationToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasUrl) {
    size += computeStringSize(1, self.url);
  }
  if (self.hasResponseStatusCode) {
    size += computeUInt32Size(2, self.responseStatusCode);
  }
  if (self.hasResponseStatusLine) {
    size += computeStringSize(3, self.responseStatusLine);
  }
  for (NameValuePairL* element in self.vendorResponseHeadersList) {
    size += computeMessageSize(4, element);
  }
  if (self.hasResponseBody) {
    size += computeDataSize(5, self.responseBody);
  }
  if (self.hasError) {
    size += computeMessageSize(6, self.error);
  }
  if (self.hasClientComputedMd5) {
    size += computeDataSize(7, self.clientComputedMd5);
  }
  for (NameValuePairL* element in self.vendorNvPairsList) {
    size += computeMessageSize(8, element);
  }
  for (NameValuePairL* element in self.clientNvPairsList) {
    size += computeMessageSize(9, element);
  }
  if (self.hasStorageContainerAuthorizationToken) {
    size += computeStringSize(10, self.storageContainerAuthorizationToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (MethodCompletionInfoL*) parseFromData:(NSData*) data {
  return (MethodCompletionInfoL*)[[[MethodCompletionInfoL builder] mergeFromData:data] build];
}
+ (MethodCompletionInfoL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoL*)[[[MethodCompletionInfoL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoL*) parseFromInputStream:(NSInputStream*) input {
  return (MethodCompletionInfoL*)[[[MethodCompletionInfoL builder] mergeFromInputStream:input] build];
}
+ (MethodCompletionInfoL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoL*)[[[MethodCompletionInfoL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (MethodCompletionInfoL*)[[[MethodCompletionInfoL builder] mergeFromCodedInputStream:input] build];
}
+ (MethodCompletionInfoL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoL*)[[[MethodCompletionInfoL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoL_Builder*) builder {
  return [[[MethodCompletionInfoL_Builder alloc] init] autorelease];
}
+ (MethodCompletionInfoL_Builder*) builderWithPrototype:(MethodCompletionInfoL*) prototype {
  return [[MethodCompletionInfoL builder] mergeFrom:prototype];
}
- (MethodCompletionInfoL_Builder*) builder {
  return [MethodCompletionInfoL builder];
}
@end

@interface MethodCompletionInfoL_Builder()
@property (retain) MethodCompletionInfoL* result;
@end

@implementation MethodCompletionInfoL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[MethodCompletionInfoL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (MethodCompletionInfoL_Builder*) clear {
  self.result = [[[MethodCompletionInfoL alloc] init] autorelease];
  return self;
}
- (MethodCompletionInfoL_Builder*) clone {
  return [MethodCompletionInfoL builderWithPrototype:result];
}
- (MethodCompletionInfoL*) defaultInstance {
  return [MethodCompletionInfoL defaultInstance];
}
- (MethodCompletionInfoL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (MethodCompletionInfoL*) buildPartial {
  MethodCompletionInfoL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (MethodCompletionInfoL_Builder*) mergeFrom:(MethodCompletionInfoL*) other {
  if (other == [MethodCompletionInfoL defaultInstance]) {
    return self;
  }
  if (other.hasUrl) {
    [self setUrl:other.url];
  }
  if (other.hasResponseStatusCode) {
    [self setResponseStatusCode:other.responseStatusCode];
  }
  if (other.hasResponseStatusLine) {
    [self setResponseStatusLine:other.responseStatusLine];
  }
  if (other.mutableVendorResponseHeadersList.count > 0) {
    if (result.mutableVendorResponseHeadersList == nil) {
      result.mutableVendorResponseHeadersList = [NSMutableArray array];
    }
    [result.mutableVendorResponseHeadersList addObjectsFromArray:other.mutableVendorResponseHeadersList];
  }
  if (other.hasResponseBody) {
    [self setResponseBody:other.responseBody];
  }
  if (other.hasError) {
    [self mergeError:other.error];
  }
  if (other.hasClientComputedMd5) {
    [self setClientComputedMd5:other.clientComputedMd5];
  }
  if (other.mutableVendorNvPairsList.count > 0) {
    if (result.mutableVendorNvPairsList == nil) {
      result.mutableVendorNvPairsList = [NSMutableArray array];
    }
    [result.mutableVendorNvPairsList addObjectsFromArray:other.mutableVendorNvPairsList];
  }
  if (other.mutableClientNvPairsList.count > 0) {
    if (result.mutableClientNvPairsList == nil) {
      result.mutableClientNvPairsList = [NSMutableArray array];
    }
    [result.mutableClientNvPairsList addObjectsFromArray:other.mutableClientNvPairsList];
  }
  if (other.hasStorageContainerAuthorizationToken) {
    [self setStorageContainerAuthorizationToken:other.storageContainerAuthorizationToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (MethodCompletionInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (MethodCompletionInfoL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setUrl:[input readString]];
        break;
      }
      case 16: {
        [self setResponseStatusCode:[input readUInt32]];
        break;
      }
      case 26: {
        [self setResponseStatusLine:[input readString]];
        break;
      }
      case 34: {
        NameValuePairL_Builder* subBuilder = [NameValuePairL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addVendorResponseHeaders:[subBuilder buildPartial]];
        break;
      }
      case 42: {
        [self setResponseBody:[input readData]];
        break;
      }
      case 50: {
        ErrorResponseL_Builder* subBuilder = [ErrorResponseL builder];
        if (self.hasError) {
          [subBuilder mergeFrom:self.error];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setError:[subBuilder buildPartial]];
        break;
      }
      case 58: {
        [self setClientComputedMd5:[input readData]];
        break;
      }
      case 66: {
        NameValuePairL_Builder* subBuilder = [NameValuePairL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addVendorNvPairs:[subBuilder buildPartial]];
        break;
      }
      case 74: {
        NameValuePairL_Builder* subBuilder = [NameValuePairL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addClientNvPairs:[subBuilder buildPartial]];
        break;
      }
      case 82: {
        [self setStorageContainerAuthorizationToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasUrl {
  return result.hasUrl;
}
- (NSString*) url {
  return result.url;
}
- (MethodCompletionInfoL_Builder*) setUrl:(NSString*) value {
  result.hasUrl = YES;
  result.url = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearUrl {
  result.hasUrl = NO;
  result.url = @"";
  return self;
}
- (BOOL) hasResponseStatusCode {
  return result.hasResponseStatusCode;
}
- (int32_t) responseStatusCode {
  return result.responseStatusCode;
}
- (MethodCompletionInfoL_Builder*) setResponseStatusCode:(int32_t) value {
  result.hasResponseStatusCode = YES;
  result.responseStatusCode = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearResponseStatusCode {
  result.hasResponseStatusCode = NO;
  result.responseStatusCode = 0;
  return self;
}
- (BOOL) hasResponseStatusLine {
  return result.hasResponseStatusLine;
}
- (NSString*) responseStatusLine {
  return result.responseStatusLine;
}
- (MethodCompletionInfoL_Builder*) setResponseStatusLine:(NSString*) value {
  result.hasResponseStatusLine = YES;
  result.responseStatusLine = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearResponseStatusLine {
  result.hasResponseStatusLine = NO;
  result.responseStatusLine = @"";
  return self;
}
- (NSArray*) vendorResponseHeadersList {
  if (result.mutableVendorResponseHeadersList == nil) { return [NSArray array]; }
  return result.mutableVendorResponseHeadersList;
}
- (NameValuePairL*) vendorResponseHeadersAtIndex:(int32_t) index {
  return [result vendorResponseHeadersAtIndex:index];
}
- (MethodCompletionInfoL_Builder*) replaceVendorResponseHeadersAtIndex:(int32_t) index with:(NameValuePairL*) value {
  [result.mutableVendorResponseHeadersList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfoL_Builder*) addAllVendorResponseHeaders:(NSArray*) values {
  if (result.mutableVendorResponseHeadersList == nil) {
    result.mutableVendorResponseHeadersList = [NSMutableArray array];
  }
  [result.mutableVendorResponseHeadersList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfoL_Builder*) clearVendorResponseHeadersList {
  result.mutableVendorResponseHeadersList = nil;
  return self;
}
- (MethodCompletionInfoL_Builder*) addVendorResponseHeaders:(NameValuePairL*) value {
  if (result.mutableVendorResponseHeadersList == nil) {
    result.mutableVendorResponseHeadersList = [NSMutableArray array];
  }
  [result.mutableVendorResponseHeadersList addObject:value];
  return self;
}
- (BOOL) hasResponseBody {
  return result.hasResponseBody;
}
- (NSData*) responseBody {
  return result.responseBody;
}
- (MethodCompletionInfoL_Builder*) setResponseBody:(NSData*) value {
  result.hasResponseBody = YES;
  result.responseBody = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearResponseBody {
  result.hasResponseBody = NO;
  result.responseBody = [NSData data];
  return self;
}
- (BOOL) hasError {
  return result.hasError;
}
- (ErrorResponseL*) error {
  return result.error;
}
- (MethodCompletionInfoL_Builder*) setError:(ErrorResponseL*) value {
  result.hasError = YES;
  result.error = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) setErrorBuilder:(ErrorResponseL_Builder*) builderForValue {
  return [self setError:[builderForValue build]];
}
- (MethodCompletionInfoL_Builder*) mergeError:(ErrorResponseL*) value {
  if (result.hasError &&
      result.error != [ErrorResponseL defaultInstance]) {
    result.error =
      [[[ErrorResponseL builderWithPrototype:result.error] mergeFrom:value] buildPartial];
  } else {
    result.error = value;
  }
  result.hasError = YES;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearError {
  result.hasError = NO;
  result.error = [ErrorResponseL defaultInstance];
  return self;
}
- (BOOL) hasClientComputedMd5 {
  return result.hasClientComputedMd5;
}
- (NSData*) clientComputedMd5 {
  return result.clientComputedMd5;
}
- (MethodCompletionInfoL_Builder*) setClientComputedMd5:(NSData*) value {
  result.hasClientComputedMd5 = YES;
  result.clientComputedMd5 = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearClientComputedMd5 {
  result.hasClientComputedMd5 = NO;
  result.clientComputedMd5 = [NSData data];
  return self;
}
- (NSArray*) vendorNvPairsList {
  if (result.mutableVendorNvPairsList == nil) { return [NSArray array]; }
  return result.mutableVendorNvPairsList;
}
- (NameValuePairL*) vendorNvPairsAtIndex:(int32_t) index {
  return [result vendorNvPairsAtIndex:index];
}
- (MethodCompletionInfoL_Builder*) replaceVendorNvPairsAtIndex:(int32_t) index with:(NameValuePairL*) value {
  [result.mutableVendorNvPairsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfoL_Builder*) addAllVendorNvPairs:(NSArray*) values {
  if (result.mutableVendorNvPairsList == nil) {
    result.mutableVendorNvPairsList = [NSMutableArray array];
  }
  [result.mutableVendorNvPairsList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfoL_Builder*) clearVendorNvPairsList {
  result.mutableVendorNvPairsList = nil;
  return self;
}
- (MethodCompletionInfoL_Builder*) addVendorNvPairs:(NameValuePairL*) value {
  if (result.mutableVendorNvPairsList == nil) {
    result.mutableVendorNvPairsList = [NSMutableArray array];
  }
  [result.mutableVendorNvPairsList addObject:value];
  return self;
}
- (NSArray*) clientNvPairsList {
  if (result.mutableClientNvPairsList == nil) { return [NSArray array]; }
  return result.mutableClientNvPairsList;
}
- (NameValuePairL*) clientNvPairsAtIndex:(int32_t) index {
  return [result clientNvPairsAtIndex:index];
}
- (MethodCompletionInfoL_Builder*) replaceClientNvPairsAtIndex:(int32_t) index with:(NameValuePairL*) value {
  [result.mutableClientNvPairsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfoL_Builder*) addAllClientNvPairs:(NSArray*) values {
  if (result.mutableClientNvPairsList == nil) {
    result.mutableClientNvPairsList = [NSMutableArray array];
  }
  [result.mutableClientNvPairsList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfoL_Builder*) clearClientNvPairsList {
  result.mutableClientNvPairsList = nil;
  return self;
}
- (MethodCompletionInfoL_Builder*) addClientNvPairs:(NameValuePairL*) value {
  if (result.mutableClientNvPairsList == nil) {
    result.mutableClientNvPairsList = [NSMutableArray array];
  }
  [result.mutableClientNvPairsList addObject:value];
  return self;
}
- (BOOL) hasStorageContainerAuthorizationToken {
  return result.hasStorageContainerAuthorizationToken;
}
- (NSString*) storageContainerAuthorizationToken {
  return result.storageContainerAuthorizationToken;
}
- (MethodCompletionInfoL_Builder*) setStorageContainerAuthorizationToken:(NSString*) value {
  result.hasStorageContainerAuthorizationToken = YES;
  result.storageContainerAuthorizationToken = value;
  return self;
}
- (MethodCompletionInfoL_Builder*) clearStorageContainerAuthorizationToken {
  result.hasStorageContainerAuthorizationToken = NO;
  result.storageContainerAuthorizationToken = @"";
  return self;
}
@end

@interface MethodCompletionInfoListL ()
@property (retain) NSMutableArray* mutableMethodCompletionInfoDataList;
@end

@implementation MethodCompletionInfoListL

@synthesize mutableMethodCompletionInfoDataList;
- (void) dealloc {
  self.mutableMethodCompletionInfoDataList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static MethodCompletionInfoListL* defaultMethodCompletionInfoListLInstance = nil;
+ (void) initialize {
  if (self == [MethodCompletionInfoListL class]) {
    defaultMethodCompletionInfoListLInstance = [[MethodCompletionInfoListL alloc] init];
  }
}
+ (MethodCompletionInfoListL*) defaultInstance {
  return defaultMethodCompletionInfoListLInstance;
}
- (MethodCompletionInfoListL*) defaultInstance {
  return defaultMethodCompletionInfoListLInstance;
}
- (NSArray*) methodCompletionInfoDataList {
  return mutableMethodCompletionInfoDataList;
}
- (MethodCompletionInfoL*) methodCompletionInfoDataAtIndex:(int32_t) index {
  id value = [mutableMethodCompletionInfoDataList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (MethodCompletionInfoL* element in self.methodCompletionInfoDataList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (MethodCompletionInfoL* element in self.methodCompletionInfoDataList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (MethodCompletionInfoL* element in self.methodCompletionInfoDataList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (MethodCompletionInfoListL*) parseFromData:(NSData*) data {
  return (MethodCompletionInfoListL*)[[[MethodCompletionInfoListL builder] mergeFromData:data] build];
}
+ (MethodCompletionInfoListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoListL*)[[[MethodCompletionInfoListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoListL*) parseFromInputStream:(NSInputStream*) input {
  return (MethodCompletionInfoListL*)[[[MethodCompletionInfoListL builder] mergeFromInputStream:input] build];
}
+ (MethodCompletionInfoListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoListL*)[[[MethodCompletionInfoListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (MethodCompletionInfoListL*)[[[MethodCompletionInfoListL builder] mergeFromCodedInputStream:input] build];
}
+ (MethodCompletionInfoListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (MethodCompletionInfoListL*)[[[MethodCompletionInfoListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (MethodCompletionInfoListL_Builder*) builder {
  return [[[MethodCompletionInfoListL_Builder alloc] init] autorelease];
}
+ (MethodCompletionInfoListL_Builder*) builderWithPrototype:(MethodCompletionInfoListL*) prototype {
  return [[MethodCompletionInfoListL builder] mergeFrom:prototype];
}
- (MethodCompletionInfoListL_Builder*) builder {
  return [MethodCompletionInfoListL builder];
}
@end

@interface MethodCompletionInfoListL_Builder()
@property (retain) MethodCompletionInfoListL* result;
@end

@implementation MethodCompletionInfoListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[MethodCompletionInfoListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (MethodCompletionInfoListL_Builder*) clear {
  self.result = [[[MethodCompletionInfoListL alloc] init] autorelease];
  return self;
}
- (MethodCompletionInfoListL_Builder*) clone {
  return [MethodCompletionInfoListL builderWithPrototype:result];
}
- (MethodCompletionInfoListL*) defaultInstance {
  return [MethodCompletionInfoListL defaultInstance];
}
- (MethodCompletionInfoListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (MethodCompletionInfoListL*) buildPartial {
  MethodCompletionInfoListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (MethodCompletionInfoListL_Builder*) mergeFrom:(MethodCompletionInfoListL*) other {
  if (other == [MethodCompletionInfoListL defaultInstance]) {
    return self;
  }
  if (other.mutableMethodCompletionInfoDataList.count > 0) {
    if (result.mutableMethodCompletionInfoDataList == nil) {
      result.mutableMethodCompletionInfoDataList = [NSMutableArray array];
    }
    [result.mutableMethodCompletionInfoDataList addObjectsFromArray:other.mutableMethodCompletionInfoDataList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (MethodCompletionInfoListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (MethodCompletionInfoListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        MethodCompletionInfoL_Builder* subBuilder = [MethodCompletionInfoL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addMethodCompletionInfoData:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) methodCompletionInfoDataList {
  if (result.mutableMethodCompletionInfoDataList == nil) { return [NSArray array]; }
  return result.mutableMethodCompletionInfoDataList;
}
- (MethodCompletionInfoL*) methodCompletionInfoDataAtIndex:(int32_t) index {
  return [result methodCompletionInfoDataAtIndex:index];
}
- (MethodCompletionInfoListL_Builder*) replaceMethodCompletionInfoDataAtIndex:(int32_t) index with:(MethodCompletionInfoL*) value {
  [result.mutableMethodCompletionInfoDataList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (MethodCompletionInfoListL_Builder*) addAllMethodCompletionInfoData:(NSArray*) values {
  if (result.mutableMethodCompletionInfoDataList == nil) {
    result.mutableMethodCompletionInfoDataList = [NSMutableArray array];
  }
  [result.mutableMethodCompletionInfoDataList addObjectsFromArray:values];
  return self;
}
- (MethodCompletionInfoListL_Builder*) clearMethodCompletionInfoDataList {
  result.mutableMethodCompletionInfoDataList = nil;
  return self;
}
- (MethodCompletionInfoListL_Builder*) addMethodCompletionInfoData:(MethodCompletionInfoL*) value {
  if (result.mutableMethodCompletionInfoDataList == nil) {
    result.mutableMethodCompletionInfoDataList = [NSMutableArray array];
  }
  [result.mutableMethodCompletionInfoDataList addObject:value];
  return self;
}
@end

@interface FileChunkListL ()
@property (retain) NSData* fileChecksum;
@property (retain) NSString* authorization;
@property (retain) NSMutableArray* mutableChunkInfoList;
@end

@implementation FileChunkListL

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
- (BOOL) hasAuthorization {
  return !!hasAuthorization_;
}
- (void) setHasAuthorization:(BOOL) value {
  hasAuthorization_ = !!value;
}
@synthesize authorization;
@synthesize mutableChunkInfoList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.authorization = nil;
  self.mutableChunkInfoList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.authorization = @"";
  }
  return self;
}
static FileChunkListL* defaultFileChunkListLInstance = nil;
+ (void) initialize {
  if (self == [FileChunkListL class]) {
    defaultFileChunkListLInstance = [[FileChunkListL alloc] init];
  }
}
+ (FileChunkListL*) defaultInstance {
  return defaultFileChunkListLInstance;
}
- (FileChunkListL*) defaultInstance {
  return defaultFileChunkListLInstance;
}
- (NSArray*) chunkInfoList {
  return mutableChunkInfoList;
}
- (ChunkInfoL*) chunkInfoAtIndex:(int32_t) index {
  id value = [mutableChunkInfoList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  if (!self.hasAuthorization) {
    return NO;
  }
  for (ChunkInfoL* element in self.chunkInfoList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  if (self.hasAuthorization) {
    [output writeString:2 value:self.authorization];
  }
  for (ChunkInfoL* element in self.chunkInfoList) {
    [output writeMessage:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  if (self.hasAuthorization) {
    size += computeStringSize(2, self.authorization);
  }
  for (ChunkInfoL* element in self.chunkInfoList) {
    size += computeMessageSize(3, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChunkListL*) parseFromData:(NSData*) data {
  return (FileChunkListL*)[[[FileChunkListL builder] mergeFromData:data] build];
}
+ (FileChunkListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkListL*)[[[FileChunkListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChunkListL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChunkListL*)[[[FileChunkListL builder] mergeFromInputStream:input] build];
}
+ (FileChunkListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkListL*)[[[FileChunkListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChunkListL*)[[[FileChunkListL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChunkListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkListL*)[[[FileChunkListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkListL_Builder*) builder {
  return [[[FileChunkListL_Builder alloc] init] autorelease];
}
+ (FileChunkListL_Builder*) builderWithPrototype:(FileChunkListL*) prototype {
  return [[FileChunkListL builder] mergeFrom:prototype];
}
- (FileChunkListL_Builder*) builder {
  return [FileChunkListL builder];
}
@end

@interface FileChunkListL_Builder()
@property (retain) FileChunkListL* result;
@end

@implementation FileChunkListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChunkListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChunkListL_Builder*) clear {
  self.result = [[[FileChunkListL alloc] init] autorelease];
  return self;
}
- (FileChunkListL_Builder*) clone {
  return [FileChunkListL builderWithPrototype:result];
}
- (FileChunkListL*) defaultInstance {
  return [FileChunkListL defaultInstance];
}
- (FileChunkListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChunkListL*) buildPartial {
  FileChunkListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChunkListL_Builder*) mergeFrom:(FileChunkListL*) other {
  if (other == [FileChunkListL defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.hasAuthorization) {
    [self setAuthorization:other.authorization];
  }
  if (other.mutableChunkInfoList.count > 0) {
    if (result.mutableChunkInfoList == nil) {
      result.mutableChunkInfoList = [NSMutableArray array];
    }
    [result.mutableChunkInfoList addObjectsFromArray:other.mutableChunkInfoList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChunkListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChunkListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setAuthorization:[input readString]];
        break;
      }
      case 26: {
        ChunkInfoL_Builder* subBuilder = [ChunkInfoL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkInfo:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChunkListL_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChunkListL_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (BOOL) hasAuthorization {
  return result.hasAuthorization;
}
- (NSString*) authorization {
  return result.authorization;
}
- (FileChunkListL_Builder*) setAuthorization:(NSString*) value {
  result.hasAuthorization = YES;
  result.authorization = value;
  return self;
}
- (FileChunkListL_Builder*) clearAuthorization {
  result.hasAuthorization = NO;
  result.authorization = @"";
  return self;
}
- (NSArray*) chunkInfoList {
  if (result.mutableChunkInfoList == nil) { return [NSArray array]; }
  return result.mutableChunkInfoList;
}
- (ChunkInfoL*) chunkInfoAtIndex:(int32_t) index {
  return [result chunkInfoAtIndex:index];
}
- (FileChunkListL_Builder*) replaceChunkInfoAtIndex:(int32_t) index with:(ChunkInfoL*) value {
  [result.mutableChunkInfoList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChunkListL_Builder*) addAllChunkInfo:(NSArray*) values {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObjectsFromArray:values];
  return self;
}
- (FileChunkListL_Builder*) clearChunkInfoList {
  result.mutableChunkInfoList = nil;
  return self;
}
- (FileChunkListL_Builder*) addChunkInfo:(ChunkInfoL*) value {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObject:value];
  return self;
}
@end

@interface FileChunkListsL ()
@property (retain) NSMutableArray* mutableFileChunkListList;
@end

@implementation FileChunkListsL

@synthesize mutableFileChunkListList;
- (void) dealloc {
  self.mutableFileChunkListList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileChunkListsL* defaultFileChunkListsLInstance = nil;
+ (void) initialize {
  if (self == [FileChunkListsL class]) {
    defaultFileChunkListsLInstance = [[FileChunkListsL alloc] init];
  }
}
+ (FileChunkListsL*) defaultInstance {
  return defaultFileChunkListsLInstance;
}
- (FileChunkListsL*) defaultInstance {
  return defaultFileChunkListsLInstance;
}
- (NSArray*) fileChunkListList {
  return mutableFileChunkListList;
}
- (FileChunkListL*) fileChunkListAtIndex:(int32_t) index {
  id value = [mutableFileChunkListList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (FileChunkListL* element in self.fileChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (FileChunkListL* element in self.fileChunkListList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (FileChunkListL* element in self.fileChunkListList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChunkListsL*) parseFromData:(NSData*) data {
  return (FileChunkListsL*)[[[FileChunkListsL builder] mergeFromData:data] build];
}
+ (FileChunkListsL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkListsL*)[[[FileChunkListsL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChunkListsL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChunkListsL*)[[[FileChunkListsL builder] mergeFromInputStream:input] build];
}
+ (FileChunkListsL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkListsL*)[[[FileChunkListsL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChunkListsL*)[[[FileChunkListsL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChunkListsL*)[[[FileChunkListsL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChunkListsL_Builder*) builder {
  return [[[FileChunkListsL_Builder alloc] init] autorelease];
}
+ (FileChunkListsL_Builder*) builderWithPrototype:(FileChunkListsL*) prototype {
  return [[FileChunkListsL builder] mergeFrom:prototype];
}
- (FileChunkListsL_Builder*) builder {
  return [FileChunkListsL builder];
}
@end

@interface FileChunkListsL_Builder()
@property (retain) FileChunkListsL* result;
@end

@implementation FileChunkListsL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChunkListsL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChunkListsL_Builder*) clear {
  self.result = [[[FileChunkListsL alloc] init] autorelease];
  return self;
}
- (FileChunkListsL_Builder*) clone {
  return [FileChunkListsL builderWithPrototype:result];
}
- (FileChunkListsL*) defaultInstance {
  return [FileChunkListsL defaultInstance];
}
- (FileChunkListsL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChunkListsL*) buildPartial {
  FileChunkListsL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChunkListsL_Builder*) mergeFrom:(FileChunkListsL*) other {
  if (other == [FileChunkListsL defaultInstance]) {
    return self;
  }
  if (other.mutableFileChunkListList.count > 0) {
    if (result.mutableFileChunkListList == nil) {
      result.mutableFileChunkListList = [NSMutableArray array];
    }
    [result.mutableFileChunkListList addObjectsFromArray:other.mutableFileChunkListList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        FileChunkListL_Builder* subBuilder = [FileChunkListL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChunkList:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) fileChunkListList {
  if (result.mutableFileChunkListList == nil) { return [NSArray array]; }
  return result.mutableFileChunkListList;
}
- (FileChunkListL*) fileChunkListAtIndex:(int32_t) index {
  return [result fileChunkListAtIndex:index];
}
- (FileChunkListsL_Builder*) replaceFileChunkListAtIndex:(int32_t) index with:(FileChunkListL*) value {
  [result.mutableFileChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChunkListsL_Builder*) addAllFileChunkList:(NSArray*) values {
  if (result.mutableFileChunkListList == nil) {
    result.mutableFileChunkListList = [NSMutableArray array];
  }
  [result.mutableFileChunkListList addObjectsFromArray:values];
  return self;
}
- (FileChunkListsL_Builder*) clearFileChunkListList {
  result.mutableFileChunkListList = nil;
  return self;
}
- (FileChunkListsL_Builder*) addFileChunkList:(FileChunkListL*) value {
  if (result.mutableFileChunkListList == nil) {
    result.mutableFileChunkListList = [NSMutableArray array];
  }
  [result.mutableFileChunkListList addObject:value];
  return self;
}
@end

@interface StorageContainerChunkListL ()
@property (retain) NSData* storageContainerKey;
@property (retain) HostInfoL* hostInfo;
@property (retain) NSMutableArray* mutableChunkChecksumList;
@property (retain) NSString* storageContainerAuthorizationToken;
@end

@implementation StorageContainerChunkListL

- (BOOL) hasStorageContainerKey {
  return !!hasStorageContainerKey_;
}
- (void) setHasStorageContainerKey:(BOOL) value {
  hasStorageContainerKey_ = !!value;
}
@synthesize storageContainerKey;
- (BOOL) hasHostInfo {
  return !!hasHostInfo_;
}
- (void) setHasHostInfo:(BOOL) value {
  hasHostInfo_ = !!value;
}
@synthesize hostInfo;
@synthesize mutableChunkChecksumList;
- (BOOL) hasStorageContainerAuthorizationToken {
  return !!hasStorageContainerAuthorizationToken_;
}
- (void) setHasStorageContainerAuthorizationToken:(BOOL) value {
  hasStorageContainerAuthorizationToken_ = !!value;
}
@synthesize storageContainerAuthorizationToken;
- (void) dealloc {
  self.storageContainerKey = nil;
  self.hostInfo = nil;
  self.mutableChunkChecksumList = nil;
  self.storageContainerAuthorizationToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.storageContainerKey = [NSData data];
    self.hostInfo = [HostInfoL defaultInstance];
    self.storageContainerAuthorizationToken = @"";
  }
  return self;
}
static StorageContainerChunkListL* defaultStorageContainerChunkListLInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerChunkListL class]) {
    defaultStorageContainerChunkListLInstance = [[StorageContainerChunkListL alloc] init];
  }
}
+ (StorageContainerChunkListL*) defaultInstance {
  return defaultStorageContainerChunkListLInstance;
}
- (StorageContainerChunkListL*) defaultInstance {
  return defaultStorageContainerChunkListLInstance;
}
- (NSArray*) chunkChecksumList {
  return mutableChunkChecksumList;
}
- (NSData*) chunkChecksumAtIndex:(int32_t) index {
  id value = [mutableChunkChecksumList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasStorageContainerKey) {
    return NO;
  }
  if (!self.hasHostInfo) {
    return NO;
  }
  if (!self.hasStorageContainerAuthorizationToken) {
    return NO;
  }
  if (!self.hostInfo.isInitialized) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStorageContainerKey) {
    [output writeData:1 value:self.storageContainerKey];
  }
  if (self.hasHostInfo) {
    [output writeMessage:2 value:self.hostInfo];
  }
  for (NSData* element in self.mutableChunkChecksumList) {
    [output writeData:3 value:element];
  }
  if (self.hasStorageContainerAuthorizationToken) {
    [output writeString:4 value:self.storageContainerAuthorizationToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasStorageContainerKey) {
    size += computeDataSize(1, self.storageContainerKey);
  }
  if (self.hasHostInfo) {
    size += computeMessageSize(2, self.hostInfo);
  }
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableChunkChecksumList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableChunkChecksumList.count;
  }
  if (self.hasStorageContainerAuthorizationToken) {
    size += computeStringSize(4, self.storageContainerAuthorizationToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerChunkListL*) parseFromData:(NSData*) data {
  return (StorageContainerChunkListL*)[[[StorageContainerChunkListL builder] mergeFromData:data] build];
}
+ (StorageContainerChunkListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkListL*)[[[StorageContainerChunkListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkListL*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerChunkListL*)[[[StorageContainerChunkListL builder] mergeFromInputStream:input] build];
}
+ (StorageContainerChunkListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkListL*)[[[StorageContainerChunkListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerChunkListL*)[[[StorageContainerChunkListL builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerChunkListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkListL*)[[[StorageContainerChunkListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkListL_Builder*) builder {
  return [[[StorageContainerChunkListL_Builder alloc] init] autorelease];
}
+ (StorageContainerChunkListL_Builder*) builderWithPrototype:(StorageContainerChunkListL*) prototype {
  return [[StorageContainerChunkListL builder] mergeFrom:prototype];
}
- (StorageContainerChunkListL_Builder*) builder {
  return [StorageContainerChunkListL builder];
}
@end

@interface StorageContainerChunkListL_Builder()
@property (retain) StorageContainerChunkListL* result;
@end

@implementation StorageContainerChunkListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerChunkListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerChunkListL_Builder*) clear {
  self.result = [[[StorageContainerChunkListL alloc] init] autorelease];
  return self;
}
- (StorageContainerChunkListL_Builder*) clone {
  return [StorageContainerChunkListL builderWithPrototype:result];
}
- (StorageContainerChunkListL*) defaultInstance {
  return [StorageContainerChunkListL defaultInstance];
}
- (StorageContainerChunkListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerChunkListL*) buildPartial {
  StorageContainerChunkListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerChunkListL_Builder*) mergeFrom:(StorageContainerChunkListL*) other {
  if (other == [StorageContainerChunkListL defaultInstance]) {
    return self;
  }
  if (other.hasStorageContainerKey) {
    [self setStorageContainerKey:other.storageContainerKey];
  }
  if (other.hasHostInfo) {
    [self mergeHostInfo:other.hostInfo];
  }
  if (other.mutableChunkChecksumList.count > 0) {
    if (result.mutableChunkChecksumList == nil) {
      result.mutableChunkChecksumList = [NSMutableArray array];
    }
    [result.mutableChunkChecksumList addObjectsFromArray:other.mutableChunkChecksumList];
  }
  if (other.hasStorageContainerAuthorizationToken) {
    [self setStorageContainerAuthorizationToken:other.storageContainerAuthorizationToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerChunkListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerChunkListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setStorageContainerKey:[input readData]];
        break;
      }
      case 18: {
        HostInfoL_Builder* subBuilder = [HostInfoL builder];
        if (self.hasHostInfo) {
          [subBuilder mergeFrom:self.hostInfo];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setHostInfo:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        [self addChunkChecksum:[input readData]];
        break;
      }
      case 34: {
        [self setStorageContainerAuthorizationToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasStorageContainerKey {
  return result.hasStorageContainerKey;
}
- (NSData*) storageContainerKey {
  return result.storageContainerKey;
}
- (StorageContainerChunkListL_Builder*) setStorageContainerKey:(NSData*) value {
  result.hasStorageContainerKey = YES;
  result.storageContainerKey = value;
  return self;
}
- (StorageContainerChunkListL_Builder*) clearStorageContainerKey {
  result.hasStorageContainerKey = NO;
  result.storageContainerKey = [NSData data];
  return self;
}
- (BOOL) hasHostInfo {
  return result.hasHostInfo;
}
- (HostInfoL*) hostInfo {
  return result.hostInfo;
}
- (StorageContainerChunkListL_Builder*) setHostInfo:(HostInfoL*) value {
  result.hasHostInfo = YES;
  result.hostInfo = value;
  return self;
}
- (StorageContainerChunkListL_Builder*) setHostInfoBuilder:(HostInfoL_Builder*) builderForValue {
  return [self setHostInfo:[builderForValue build]];
}
- (StorageContainerChunkListL_Builder*) mergeHostInfo:(HostInfoL*) value {
  if (result.hasHostInfo &&
      result.hostInfo != [HostInfoL defaultInstance]) {
    result.hostInfo =
      [[[HostInfoL builderWithPrototype:result.hostInfo] mergeFrom:value] buildPartial];
  } else {
    result.hostInfo = value;
  }
  result.hasHostInfo = YES;
  return self;
}
- (StorageContainerChunkListL_Builder*) clearHostInfo {
  result.hasHostInfo = NO;
  result.hostInfo = [HostInfoL defaultInstance];
  return self;
}
- (NSArray*) chunkChecksumList {
  if (result.mutableChunkChecksumList == nil) {
    return [NSArray array];
  }
  return result.mutableChunkChecksumList;
}
- (NSData*) chunkChecksumAtIndex:(int32_t) index {
  return [result chunkChecksumAtIndex:index];
}
- (StorageContainerChunkListL_Builder*) replaceChunkChecksumAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableChunkChecksumList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerChunkListL_Builder*) addChunkChecksum:(NSData*) value {
  if (result.mutableChunkChecksumList == nil) {
    result.mutableChunkChecksumList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumList addObject:value];
  return self;
}
- (StorageContainerChunkListL_Builder*) addAllChunkChecksum:(NSArray*) values {
  if (result.mutableChunkChecksumList == nil) {
    result.mutableChunkChecksumList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumList addObjectsFromArray:values];
  return self;
}
- (StorageContainerChunkListL_Builder*) clearChunkChecksumList {
  result.mutableChunkChecksumList = nil;
  return self;
}
- (BOOL) hasStorageContainerAuthorizationToken {
  return result.hasStorageContainerAuthorizationToken;
}
- (NSString*) storageContainerAuthorizationToken {
  return result.storageContainerAuthorizationToken;
}
- (StorageContainerChunkListL_Builder*) setStorageContainerAuthorizationToken:(NSString*) value {
  result.hasStorageContainerAuthorizationToken = YES;
  result.storageContainerAuthorizationToken = value;
  return self;
}
- (StorageContainerChunkListL_Builder*) clearStorageContainerAuthorizationToken {
  result.hasStorageContainerAuthorizationToken = NO;
  result.storageContainerAuthorizationToken = @"";
  return self;
}
@end

@interface StorageContainerChunkListsL ()
@property (retain) NSMutableArray* mutableStorageContainerChunkListList;
@property (retain) NSMutableArray* mutableFileErrorList;
@property int32_t verbosityLevel;
@end

@implementation StorageContainerChunkListsL

@synthesize mutableStorageContainerChunkListList;
@synthesize mutableFileErrorList;
- (BOOL) hasVerbosityLevel {
  return !!hasVerbosityLevel_;
}
- (void) setHasVerbosityLevel:(BOOL) value {
  hasVerbosityLevel_ = !!value;
}
@synthesize verbosityLevel;
- (void) dealloc {
  self.mutableStorageContainerChunkListList = nil;
  self.mutableFileErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.verbosityLevel = 0;
  }
  return self;
}
static StorageContainerChunkListsL* defaultStorageContainerChunkListsLInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerChunkListsL class]) {
    defaultStorageContainerChunkListsLInstance = [[StorageContainerChunkListsL alloc] init];
  }
}
+ (StorageContainerChunkListsL*) defaultInstance {
  return defaultStorageContainerChunkListsLInstance;
}
- (StorageContainerChunkListsL*) defaultInstance {
  return defaultStorageContainerChunkListsLInstance;
}
- (NSArray*) storageContainerChunkListList {
  return mutableStorageContainerChunkListList;
}
- (StorageContainerChunkListL*) storageContainerChunkListAtIndex:(int32_t) index {
  id value = [mutableStorageContainerChunkListList objectAtIndex:index];
  return value;
}
- (NSArray*) fileErrorList {
  return mutableFileErrorList;
}
- (FileErrorL*) fileErrorAtIndex:(int32_t) index {
  id value = [mutableFileErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageContainerChunkListL* element in self.storageContainerChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileErrorL* element in self.fileErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageContainerChunkListL* element in self.storageContainerChunkListList) {
    [output writeMessage:1 value:element];
  }
  for (FileErrorL* element in self.fileErrorList) {
    [output writeMessage:2 value:element];
  }
  if (self.hasVerbosityLevel) {
    [output writeUInt32:3 value:self.verbosityLevel];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageContainerChunkListL* element in self.storageContainerChunkListList) {
    size += computeMessageSize(1, element);
  }
  for (FileErrorL* element in self.fileErrorList) {
    size += computeMessageSize(2, element);
  }
  if (self.hasVerbosityLevel) {
    size += computeUInt32Size(3, self.verbosityLevel);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerChunkListsL*) parseFromData:(NSData*) data {
  return (StorageContainerChunkListsL*)[[[StorageContainerChunkListsL builder] mergeFromData:data] build];
}
+ (StorageContainerChunkListsL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkListsL*)[[[StorageContainerChunkListsL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkListsL*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerChunkListsL*)[[[StorageContainerChunkListsL builder] mergeFromInputStream:input] build];
}
+ (StorageContainerChunkListsL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkListsL*)[[[StorageContainerChunkListsL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerChunkListsL*)[[[StorageContainerChunkListsL builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerChunkListsL*)[[[StorageContainerChunkListsL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerChunkListsL_Builder*) builder {
  return [[[StorageContainerChunkListsL_Builder alloc] init] autorelease];
}
+ (StorageContainerChunkListsL_Builder*) builderWithPrototype:(StorageContainerChunkListsL*) prototype {
  return [[StorageContainerChunkListsL builder] mergeFrom:prototype];
}
- (StorageContainerChunkListsL_Builder*) builder {
  return [StorageContainerChunkListsL builder];
}
@end

@interface StorageContainerChunkListsL_Builder()
@property (retain) StorageContainerChunkListsL* result;
@end

@implementation StorageContainerChunkListsL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerChunkListsL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerChunkListsL_Builder*) clear {
  self.result = [[[StorageContainerChunkListsL alloc] init] autorelease];
  return self;
}
- (StorageContainerChunkListsL_Builder*) clone {
  return [StorageContainerChunkListsL builderWithPrototype:result];
}
- (StorageContainerChunkListsL*) defaultInstance {
  return [StorageContainerChunkListsL defaultInstance];
}
- (StorageContainerChunkListsL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerChunkListsL*) buildPartial {
  StorageContainerChunkListsL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerChunkListsL_Builder*) mergeFrom:(StorageContainerChunkListsL*) other {
  if (other == [StorageContainerChunkListsL defaultInstance]) {
    return self;
  }
  if (other.mutableStorageContainerChunkListList.count > 0) {
    if (result.mutableStorageContainerChunkListList == nil) {
      result.mutableStorageContainerChunkListList = [NSMutableArray array];
    }
    [result.mutableStorageContainerChunkListList addObjectsFromArray:other.mutableStorageContainerChunkListList];
  }
  if (other.mutableFileErrorList.count > 0) {
    if (result.mutableFileErrorList == nil) {
      result.mutableFileErrorList = [NSMutableArray array];
    }
    [result.mutableFileErrorList addObjectsFromArray:other.mutableFileErrorList];
  }
  if (other.hasVerbosityLevel) {
    [self setVerbosityLevel:other.verbosityLevel];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageContainerChunkListL_Builder* subBuilder = [StorageContainerChunkListL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageContainerChunkList:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        FileErrorL_Builder* subBuilder = [FileErrorL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileError:[subBuilder buildPartial]];
        break;
      }
      case 24: {
        [self setVerbosityLevel:[input readUInt32]];
        break;
      }
    }
  }
}
- (NSArray*) storageContainerChunkListList {
  if (result.mutableStorageContainerChunkListList == nil) { return [NSArray array]; }
  return result.mutableStorageContainerChunkListList;
}
- (StorageContainerChunkListL*) storageContainerChunkListAtIndex:(int32_t) index {
  return [result storageContainerChunkListAtIndex:index];
}
- (StorageContainerChunkListsL_Builder*) replaceStorageContainerChunkListAtIndex:(int32_t) index with:(StorageContainerChunkListL*) value {
  [result.mutableStorageContainerChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerChunkListsL_Builder*) addAllStorageContainerChunkList:(NSArray*) values {
  if (result.mutableStorageContainerChunkListList == nil) {
    result.mutableStorageContainerChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageContainerChunkListList addObjectsFromArray:values];
  return self;
}
- (StorageContainerChunkListsL_Builder*) clearStorageContainerChunkListList {
  result.mutableStorageContainerChunkListList = nil;
  return self;
}
- (StorageContainerChunkListsL_Builder*) addStorageContainerChunkList:(StorageContainerChunkListL*) value {
  if (result.mutableStorageContainerChunkListList == nil) {
    result.mutableStorageContainerChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageContainerChunkListList addObject:value];
  return self;
}
- (NSArray*) fileErrorList {
  if (result.mutableFileErrorList == nil) { return [NSArray array]; }
  return result.mutableFileErrorList;
}
- (FileErrorL*) fileErrorAtIndex:(int32_t) index {
  return [result fileErrorAtIndex:index];
}
- (StorageContainerChunkListsL_Builder*) replaceFileErrorAtIndex:(int32_t) index with:(FileErrorL*) value {
  [result.mutableFileErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerChunkListsL_Builder*) addAllFileError:(NSArray*) values {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObjectsFromArray:values];
  return self;
}
- (StorageContainerChunkListsL_Builder*) clearFileErrorList {
  result.mutableFileErrorList = nil;
  return self;
}
- (StorageContainerChunkListsL_Builder*) addFileError:(FileErrorL*) value {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObject:value];
  return self;
}
- (BOOL) hasVerbosityLevel {
  return result.hasVerbosityLevel;
}
- (int32_t) verbosityLevel {
  return result.verbosityLevel;
}
- (StorageContainerChunkListsL_Builder*) setVerbosityLevel:(int32_t) value {
  result.hasVerbosityLevel = YES;
  result.verbosityLevel = value;
  return self;
}
- (StorageContainerChunkListsL_Builder*) clearVerbosityLevel {
  result.hasVerbosityLevel = NO;
  result.verbosityLevel = 0;
  return self;
}
@end

@interface StorageContainerErrorListL ()
@property (retain) NSMutableArray* mutableStorageContainerErrorDataList;
@end

@implementation StorageContainerErrorListL

@synthesize mutableStorageContainerErrorDataList;
- (void) dealloc {
  self.mutableStorageContainerErrorDataList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static StorageContainerErrorListL* defaultStorageContainerErrorListLInstance = nil;
+ (void) initialize {
  if (self == [StorageContainerErrorListL class]) {
    defaultStorageContainerErrorListLInstance = [[StorageContainerErrorListL alloc] init];
  }
}
+ (StorageContainerErrorListL*) defaultInstance {
  return defaultStorageContainerErrorListLInstance;
}
- (StorageContainerErrorListL*) defaultInstance {
  return defaultStorageContainerErrorListLInstance;
}
- (NSArray*) storageContainerErrorDataList {
  return mutableStorageContainerErrorDataList;
}
- (StorageContainerErrorL*) storageContainerErrorDataAtIndex:(int32_t) index {
  id value = [mutableStorageContainerErrorDataList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageContainerErrorL* element in self.storageContainerErrorDataList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageContainerErrorL* element in self.storageContainerErrorDataList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageContainerErrorL* element in self.storageContainerErrorDataList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageContainerErrorListL*) parseFromData:(NSData*) data {
  return (StorageContainerErrorListL*)[[[StorageContainerErrorListL builder] mergeFromData:data] build];
}
+ (StorageContainerErrorListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorListL*)[[[StorageContainerErrorListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorListL*) parseFromInputStream:(NSInputStream*) input {
  return (StorageContainerErrorListL*)[[[StorageContainerErrorListL builder] mergeFromInputStream:input] build];
}
+ (StorageContainerErrorListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorListL*)[[[StorageContainerErrorListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageContainerErrorListL*)[[[StorageContainerErrorListL builder] mergeFromCodedInputStream:input] build];
}
+ (StorageContainerErrorListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageContainerErrorListL*)[[[StorageContainerErrorListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageContainerErrorListL_Builder*) builder {
  return [[[StorageContainerErrorListL_Builder alloc] init] autorelease];
}
+ (StorageContainerErrorListL_Builder*) builderWithPrototype:(StorageContainerErrorListL*) prototype {
  return [[StorageContainerErrorListL builder] mergeFrom:prototype];
}
- (StorageContainerErrorListL_Builder*) builder {
  return [StorageContainerErrorListL builder];
}
@end

@interface StorageContainerErrorListL_Builder()
@property (retain) StorageContainerErrorListL* result;
@end

@implementation StorageContainerErrorListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageContainerErrorListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageContainerErrorListL_Builder*) clear {
  self.result = [[[StorageContainerErrorListL alloc] init] autorelease];
  return self;
}
- (StorageContainerErrorListL_Builder*) clone {
  return [StorageContainerErrorListL builderWithPrototype:result];
}
- (StorageContainerErrorListL*) defaultInstance {
  return [StorageContainerErrorListL defaultInstance];
}
- (StorageContainerErrorListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageContainerErrorListL*) buildPartial {
  StorageContainerErrorListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageContainerErrorListL_Builder*) mergeFrom:(StorageContainerErrorListL*) other {
  if (other == [StorageContainerErrorListL defaultInstance]) {
    return self;
  }
  if (other.mutableStorageContainerErrorDataList.count > 0) {
    if (result.mutableStorageContainerErrorDataList == nil) {
      result.mutableStorageContainerErrorDataList = [NSMutableArray array];
    }
    [result.mutableStorageContainerErrorDataList addObjectsFromArray:other.mutableStorageContainerErrorDataList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageContainerErrorListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageContainerErrorListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageContainerErrorL_Builder* subBuilder = [StorageContainerErrorL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageContainerErrorData:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) storageContainerErrorDataList {
  if (result.mutableStorageContainerErrorDataList == nil) { return [NSArray array]; }
  return result.mutableStorageContainerErrorDataList;
}
- (StorageContainerErrorL*) storageContainerErrorDataAtIndex:(int32_t) index {
  return [result storageContainerErrorDataAtIndex:index];
}
- (StorageContainerErrorListL_Builder*) replaceStorageContainerErrorDataAtIndex:(int32_t) index with:(StorageContainerErrorL*) value {
  [result.mutableStorageContainerErrorDataList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageContainerErrorListL_Builder*) addAllStorageContainerErrorData:(NSArray*) values {
  if (result.mutableStorageContainerErrorDataList == nil) {
    result.mutableStorageContainerErrorDataList = [NSMutableArray array];
  }
  [result.mutableStorageContainerErrorDataList addObjectsFromArray:values];
  return self;
}
- (StorageContainerErrorListL_Builder*) clearStorageContainerErrorDataList {
  result.mutableStorageContainerErrorDataList = nil;
  return self;
}
- (StorageContainerErrorListL_Builder*) addStorageContainerErrorData:(StorageContainerErrorL*) value {
  if (result.mutableStorageContainerErrorDataList == nil) {
    result.mutableStorageContainerErrorDataList = [NSMutableArray array];
  }
  [result.mutableStorageContainerErrorDataList addObject:value];
  return self;
}
@end

@interface FileChecksumAuthorizationL ()
@property (retain) NSData* fileChecksum;
@property (retain) NSString* authorization;
@property (retain) NSMutableArray* mutableChunkChecksumsList;
@end

@implementation FileChecksumAuthorizationL

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
- (BOOL) hasAuthorization {
  return !!hasAuthorization_;
}
- (void) setHasAuthorization:(BOOL) value {
  hasAuthorization_ = !!value;
}
@synthesize authorization;
@synthesize mutableChunkChecksumsList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.authorization = nil;
  self.mutableChunkChecksumsList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
    self.authorization = @"";
  }
  return self;
}
static FileChecksumAuthorizationL* defaultFileChecksumAuthorizationLInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumAuthorizationL class]) {
    defaultFileChecksumAuthorizationLInstance = [[FileChecksumAuthorizationL alloc] init];
  }
}
+ (FileChecksumAuthorizationL*) defaultInstance {
  return defaultFileChecksumAuthorizationLInstance;
}
- (FileChecksumAuthorizationL*) defaultInstance {
  return defaultFileChecksumAuthorizationLInstance;
}
- (NSArray*) chunkChecksumsList {
  return mutableChunkChecksumsList;
}
- (NSData*) chunkChecksumsAtIndex:(int32_t) index {
  id value = [mutableChunkChecksumsList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  if (!self.hasAuthorization) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  if (self.hasAuthorization) {
    [output writeString:2 value:self.authorization];
  }
  for (NSData* element in self.mutableChunkChecksumsList) {
    [output writeData:3 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  if (self.hasAuthorization) {
    size += computeStringSize(2, self.authorization);
  }
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableChunkChecksumsList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableChunkChecksumsList.count;
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumAuthorizationL*) parseFromData:(NSData*) data {
  return (FileChecksumAuthorizationL*)[[[FileChecksumAuthorizationL builder] mergeFromData:data] build];
}
+ (FileChecksumAuthorizationL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationL*)[[[FileChecksumAuthorizationL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumAuthorizationL*)[[[FileChecksumAuthorizationL builder] mergeFromInputStream:input] build];
}
+ (FileChecksumAuthorizationL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationL*)[[[FileChecksumAuthorizationL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumAuthorizationL*)[[[FileChecksumAuthorizationL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumAuthorizationL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationL*)[[[FileChecksumAuthorizationL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationL_Builder*) builder {
  return [[[FileChecksumAuthorizationL_Builder alloc] init] autorelease];
}
+ (FileChecksumAuthorizationL_Builder*) builderWithPrototype:(FileChecksumAuthorizationL*) prototype {
  return [[FileChecksumAuthorizationL builder] mergeFrom:prototype];
}
- (FileChecksumAuthorizationL_Builder*) builder {
  return [FileChecksumAuthorizationL builder];
}
@end

@interface FileChecksumAuthorizationL_Builder()
@property (retain) FileChecksumAuthorizationL* result;
@end

@implementation FileChecksumAuthorizationL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumAuthorizationL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumAuthorizationL_Builder*) clear {
  self.result = [[[FileChecksumAuthorizationL alloc] init] autorelease];
  return self;
}
- (FileChecksumAuthorizationL_Builder*) clone {
  return [FileChecksumAuthorizationL builderWithPrototype:result];
}
- (FileChecksumAuthorizationL*) defaultInstance {
  return [FileChecksumAuthorizationL defaultInstance];
}
- (FileChecksumAuthorizationL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumAuthorizationL*) buildPartial {
  FileChecksumAuthorizationL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumAuthorizationL_Builder*) mergeFrom:(FileChecksumAuthorizationL*) other {
  if (other == [FileChecksumAuthorizationL defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.hasAuthorization) {
    [self setAuthorization:other.authorization];
  }
  if (other.mutableChunkChecksumsList.count > 0) {
    if (result.mutableChunkChecksumsList == nil) {
      result.mutableChunkChecksumsList = [NSMutableArray array];
    }
    [result.mutableChunkChecksumsList addObjectsFromArray:other.mutableChunkChecksumsList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumAuthorizationL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumAuthorizationL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        [self setAuthorization:[input readString]];
        break;
      }
      case 26: {
        [self addChunkChecksums:[input readData]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChecksumAuthorizationL_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChecksumAuthorizationL_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (BOOL) hasAuthorization {
  return result.hasAuthorization;
}
- (NSString*) authorization {
  return result.authorization;
}
- (FileChecksumAuthorizationL_Builder*) setAuthorization:(NSString*) value {
  result.hasAuthorization = YES;
  result.authorization = value;
  return self;
}
- (FileChecksumAuthorizationL_Builder*) clearAuthorization {
  result.hasAuthorization = NO;
  result.authorization = @"";
  return self;
}
- (NSArray*) chunkChecksumsList {
  if (result.mutableChunkChecksumsList == nil) {
    return [NSArray array];
  }
  return result.mutableChunkChecksumsList;
}
- (NSData*) chunkChecksumsAtIndex:(int32_t) index {
  return [result chunkChecksumsAtIndex:index];
}
- (FileChecksumAuthorizationL_Builder*) replaceChunkChecksumsAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableChunkChecksumsList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumAuthorizationL_Builder*) addChunkChecksums:(NSData*) value {
  if (result.mutableChunkChecksumsList == nil) {
    result.mutableChunkChecksumsList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumsList addObject:value];
  return self;
}
- (FileChecksumAuthorizationL_Builder*) addAllChunkChecksums:(NSArray*) values {
  if (result.mutableChunkChecksumsList == nil) {
    result.mutableChunkChecksumsList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumsList addObjectsFromArray:values];
  return self;
}
- (FileChecksumAuthorizationL_Builder*) clearChunkChecksumsList {
  result.mutableChunkChecksumsList = nil;
  return self;
}
@end

@interface FileChecksumAuthorizationListL ()
@property (retain) NSMutableArray* mutableFileChecksumAuthorizationDataList;
@end

@implementation FileChecksumAuthorizationListL

@synthesize mutableFileChecksumAuthorizationDataList;
- (void) dealloc {
  self.mutableFileChecksumAuthorizationDataList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileChecksumAuthorizationListL* defaultFileChecksumAuthorizationListLInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumAuthorizationListL class]) {
    defaultFileChecksumAuthorizationListLInstance = [[FileChecksumAuthorizationListL alloc] init];
  }
}
+ (FileChecksumAuthorizationListL*) defaultInstance {
  return defaultFileChecksumAuthorizationListLInstance;
}
- (FileChecksumAuthorizationListL*) defaultInstance {
  return defaultFileChecksumAuthorizationListLInstance;
}
- (NSArray*) fileChecksumAuthorizationDataList {
  return mutableFileChecksumAuthorizationDataList;
}
- (FileChecksumAuthorizationL*) fileChecksumAuthorizationDataAtIndex:(int32_t) index {
  id value = [mutableFileChecksumAuthorizationDataList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (FileChecksumAuthorizationL* element in self.fileChecksumAuthorizationDataList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (FileChecksumAuthorizationL* element in self.fileChecksumAuthorizationDataList) {
    [output writeMessage:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (FileChecksumAuthorizationL* element in self.fileChecksumAuthorizationDataList) {
    size += computeMessageSize(1, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumAuthorizationListL*) parseFromData:(NSData*) data {
  return (FileChecksumAuthorizationListL*)[[[FileChecksumAuthorizationListL builder] mergeFromData:data] build];
}
+ (FileChecksumAuthorizationListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationListL*)[[[FileChecksumAuthorizationListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationListL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumAuthorizationListL*)[[[FileChecksumAuthorizationListL builder] mergeFromInputStream:input] build];
}
+ (FileChecksumAuthorizationListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationListL*)[[[FileChecksumAuthorizationListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumAuthorizationListL*)[[[FileChecksumAuthorizationListL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumAuthorizationListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumAuthorizationListL*)[[[FileChecksumAuthorizationListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumAuthorizationListL_Builder*) builder {
  return [[[FileChecksumAuthorizationListL_Builder alloc] init] autorelease];
}
+ (FileChecksumAuthorizationListL_Builder*) builderWithPrototype:(FileChecksumAuthorizationListL*) prototype {
  return [[FileChecksumAuthorizationListL builder] mergeFrom:prototype];
}
- (FileChecksumAuthorizationListL_Builder*) builder {
  return [FileChecksumAuthorizationListL builder];
}
@end

@interface FileChecksumAuthorizationListL_Builder()
@property (retain) FileChecksumAuthorizationListL* result;
@end

@implementation FileChecksumAuthorizationListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumAuthorizationListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumAuthorizationListL_Builder*) clear {
  self.result = [[[FileChecksumAuthorizationListL alloc] init] autorelease];
  return self;
}
- (FileChecksumAuthorizationListL_Builder*) clone {
  return [FileChecksumAuthorizationListL builderWithPrototype:result];
}
- (FileChecksumAuthorizationListL*) defaultInstance {
  return [FileChecksumAuthorizationListL defaultInstance];
}
- (FileChecksumAuthorizationListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumAuthorizationListL*) buildPartial {
  FileChecksumAuthorizationListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumAuthorizationListL_Builder*) mergeFrom:(FileChecksumAuthorizationListL*) other {
  if (other == [FileChecksumAuthorizationListL defaultInstance]) {
    return self;
  }
  if (other.mutableFileChecksumAuthorizationDataList.count > 0) {
    if (result.mutableFileChecksumAuthorizationDataList == nil) {
      result.mutableFileChecksumAuthorizationDataList = [NSMutableArray array];
    }
    [result.mutableFileChecksumAuthorizationDataList addObjectsFromArray:other.mutableFileChecksumAuthorizationDataList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumAuthorizationListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumAuthorizationListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        FileChecksumAuthorizationL_Builder* subBuilder = [FileChecksumAuthorizationL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChecksumAuthorizationData:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) fileChecksumAuthorizationDataList {
  if (result.mutableFileChecksumAuthorizationDataList == nil) { return [NSArray array]; }
  return result.mutableFileChecksumAuthorizationDataList;
}
- (FileChecksumAuthorizationL*) fileChecksumAuthorizationDataAtIndex:(int32_t) index {
  return [result fileChecksumAuthorizationDataAtIndex:index];
}
- (FileChecksumAuthorizationListL_Builder*) replaceFileChecksumAuthorizationDataAtIndex:(int32_t) index with:(FileChecksumAuthorizationL*) value {
  [result.mutableFileChecksumAuthorizationDataList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumAuthorizationListL_Builder*) addAllFileChecksumAuthorizationData:(NSArray*) values {
  if (result.mutableFileChecksumAuthorizationDataList == nil) {
    result.mutableFileChecksumAuthorizationDataList = [NSMutableArray array];
  }
  [result.mutableFileChecksumAuthorizationDataList addObjectsFromArray:values];
  return self;
}
- (FileChecksumAuthorizationListL_Builder*) clearFileChecksumAuthorizationDataList {
  result.mutableFileChecksumAuthorizationDataList = nil;
  return self;
}
- (FileChecksumAuthorizationListL_Builder*) addFileChecksumAuthorizationData:(FileChecksumAuthorizationL*) value {
  if (result.mutableFileChecksumAuthorizationDataList == nil) {
    result.mutableFileChecksumAuthorizationDataList = [NSMutableArray array];
  }
  [result.mutableFileChecksumAuthorizationDataList addObject:value];
  return self;
}
@end

@interface ChunkReferenceL ()
@property int64_t containerIndex;
@property int64_t chunkIndex;
@end

@implementation ChunkReferenceL

- (BOOL) hasContainerIndex {
  return !!hasContainerIndex_;
}
- (void) setHasContainerIndex:(BOOL) value {
  hasContainerIndex_ = !!value;
}
@synthesize containerIndex;
- (BOOL) hasChunkIndex {
  return !!hasChunkIndex_;
}
- (void) setHasChunkIndex:(BOOL) value {
  hasChunkIndex_ = !!value;
}
@synthesize chunkIndex;
- (void) dealloc {
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.containerIndex = 0L;
    self.chunkIndex = 0L;
  }
  return self;
}
static ChunkReferenceL* defaultChunkReferenceLInstance = nil;
+ (void) initialize {
  if (self == [ChunkReferenceL class]) {
    defaultChunkReferenceLInstance = [[ChunkReferenceL alloc] init];
  }
}
+ (ChunkReferenceL*) defaultInstance {
  return defaultChunkReferenceLInstance;
}
- (ChunkReferenceL*) defaultInstance {
  return defaultChunkReferenceLInstance;
}
- (BOOL) isInitialized {
  if (!self.hasContainerIndex) {
    return NO;
  }
  if (!self.hasChunkIndex) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasContainerIndex) {
    [output writeUInt64:1 value:self.containerIndex];
  }
  if (self.hasChunkIndex) {
    [output writeUInt64:2 value:self.chunkIndex];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasContainerIndex) {
    size += computeUInt64Size(1, self.containerIndex);
  }
  if (self.hasChunkIndex) {
    size += computeUInt64Size(2, self.chunkIndex);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkReferenceL*) parseFromData:(NSData*) data {
  return (ChunkReferenceL*)[[[ChunkReferenceL builder] mergeFromData:data] build];
}
+ (ChunkReferenceL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkReferenceL*)[[[ChunkReferenceL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkReferenceL*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkReferenceL*)[[[ChunkReferenceL builder] mergeFromInputStream:input] build];
}
+ (ChunkReferenceL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkReferenceL*)[[[ChunkReferenceL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkReferenceL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkReferenceL*)[[[ChunkReferenceL builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkReferenceL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkReferenceL*)[[[ChunkReferenceL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkReferenceL_Builder*) builder {
  return [[[ChunkReferenceL_Builder alloc] init] autorelease];
}
+ (ChunkReferenceL_Builder*) builderWithPrototype:(ChunkReferenceL*) prototype {
  return [[ChunkReferenceL builder] mergeFrom:prototype];
}
- (ChunkReferenceL_Builder*) builder {
  return [ChunkReferenceL builder];
}
@end

@interface ChunkReferenceL_Builder()
@property (retain) ChunkReferenceL* result;
@end

@implementation ChunkReferenceL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkReferenceL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkReferenceL_Builder*) clear {
  self.result = [[[ChunkReferenceL alloc] init] autorelease];
  return self;
}
- (ChunkReferenceL_Builder*) clone {
  return [ChunkReferenceL builderWithPrototype:result];
}
- (ChunkReferenceL*) defaultInstance {
  return [ChunkReferenceL defaultInstance];
}
- (ChunkReferenceL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkReferenceL*) buildPartial {
  ChunkReferenceL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkReferenceL_Builder*) mergeFrom:(ChunkReferenceL*) other {
  if (other == [ChunkReferenceL defaultInstance]) {
    return self;
  }
  if (other.hasContainerIndex) {
    [self setContainerIndex:other.containerIndex];
  }
  if (other.hasChunkIndex) {
    [self setChunkIndex:other.chunkIndex];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkReferenceL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkReferenceL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setContainerIndex:[input readUInt64]];
        break;
      }
      case 16: {
        [self setChunkIndex:[input readUInt64]];
        break;
      }
    }
  }
}
- (BOOL) hasContainerIndex {
  return result.hasContainerIndex;
}
- (int64_t) containerIndex {
  return result.containerIndex;
}
- (ChunkReferenceL_Builder*) setContainerIndex:(int64_t) value {
  result.hasContainerIndex = YES;
  result.containerIndex = value;
  return self;
}
- (ChunkReferenceL_Builder*) clearContainerIndex {
  result.hasContainerIndex = NO;
  result.containerIndex = 0L;
  return self;
}
- (BOOL) hasChunkIndex {
  return result.hasChunkIndex;
}
- (int64_t) chunkIndex {
  return result.chunkIndex;
}
- (ChunkReferenceL_Builder*) setChunkIndex:(int64_t) value {
  result.hasChunkIndex = YES;
  result.chunkIndex = value;
  return self;
}
- (ChunkReferenceL_Builder*) clearChunkIndex {
  result.hasChunkIndex = NO;
  result.chunkIndex = 0L;
  return self;
}
@end

@interface FileChecksumChunkReferencesL ()
@property (retain) NSData* fileChecksum;
@property (retain) NSMutableArray* mutableChunkReferencesList;
@end

@implementation FileChecksumChunkReferencesL

- (BOOL) hasFileChecksum {
  return !!hasFileChecksum_;
}
- (void) setHasFileChecksum:(BOOL) value {
  hasFileChecksum_ = !!value;
}
@synthesize fileChecksum;
@synthesize mutableChunkReferencesList;
- (void) dealloc {
  self.fileChecksum = nil;
  self.mutableChunkReferencesList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.fileChecksum = [NSData data];
  }
  return self;
}
static FileChecksumChunkReferencesL* defaultFileChecksumChunkReferencesLInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumChunkReferencesL class]) {
    defaultFileChecksumChunkReferencesLInstance = [[FileChecksumChunkReferencesL alloc] init];
  }
}
+ (FileChecksumChunkReferencesL*) defaultInstance {
  return defaultFileChecksumChunkReferencesLInstance;
}
- (FileChecksumChunkReferencesL*) defaultInstance {
  return defaultFileChecksumChunkReferencesLInstance;
}
- (NSArray*) chunkReferencesList {
  return mutableChunkReferencesList;
}
- (ChunkReferenceL*) chunkReferencesAtIndex:(int32_t) index {
  id value = [mutableChunkReferencesList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasFileChecksum) {
    return NO;
  }
  for (ChunkReferenceL* element in self.chunkReferencesList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasFileChecksum) {
    [output writeData:1 value:self.fileChecksum];
  }
  for (ChunkReferenceL* element in self.chunkReferencesList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasFileChecksum) {
    size += computeDataSize(1, self.fileChecksum);
  }
  for (ChunkReferenceL* element in self.chunkReferencesList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumChunkReferencesL*) parseFromData:(NSData*) data {
  return (FileChecksumChunkReferencesL*)[[[FileChecksumChunkReferencesL builder] mergeFromData:data] build];
}
+ (FileChecksumChunkReferencesL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumChunkReferencesL*)[[[FileChecksumChunkReferencesL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumChunkReferencesL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumChunkReferencesL*)[[[FileChecksumChunkReferencesL builder] mergeFromInputStream:input] build];
}
+ (FileChecksumChunkReferencesL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumChunkReferencesL*)[[[FileChecksumChunkReferencesL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumChunkReferencesL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumChunkReferencesL*)[[[FileChecksumChunkReferencesL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumChunkReferencesL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumChunkReferencesL*)[[[FileChecksumChunkReferencesL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumChunkReferencesL_Builder*) builder {
  return [[[FileChecksumChunkReferencesL_Builder alloc] init] autorelease];
}
+ (FileChecksumChunkReferencesL_Builder*) builderWithPrototype:(FileChecksumChunkReferencesL*) prototype {
  return [[FileChecksumChunkReferencesL builder] mergeFrom:prototype];
}
- (FileChecksumChunkReferencesL_Builder*) builder {
  return [FileChecksumChunkReferencesL builder];
}
@end

@interface FileChecksumChunkReferencesL_Builder()
@property (retain) FileChecksumChunkReferencesL* result;
@end

@implementation FileChecksumChunkReferencesL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumChunkReferencesL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumChunkReferencesL_Builder*) clear {
  self.result = [[[FileChecksumChunkReferencesL alloc] init] autorelease];
  return self;
}
- (FileChecksumChunkReferencesL_Builder*) clone {
  return [FileChecksumChunkReferencesL builderWithPrototype:result];
}
- (FileChecksumChunkReferencesL*) defaultInstance {
  return [FileChecksumChunkReferencesL defaultInstance];
}
- (FileChecksumChunkReferencesL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumChunkReferencesL*) buildPartial {
  FileChecksumChunkReferencesL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumChunkReferencesL_Builder*) mergeFrom:(FileChecksumChunkReferencesL*) other {
  if (other == [FileChecksumChunkReferencesL defaultInstance]) {
    return self;
  }
  if (other.hasFileChecksum) {
    [self setFileChecksum:other.fileChecksum];
  }
  if (other.mutableChunkReferencesList.count > 0) {
    if (result.mutableChunkReferencesList == nil) {
      result.mutableChunkReferencesList = [NSMutableArray array];
    }
    [result.mutableChunkReferencesList addObjectsFromArray:other.mutableChunkReferencesList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumChunkReferencesL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumChunkReferencesL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setFileChecksum:[input readData]];
        break;
      }
      case 18: {
        ChunkReferenceL_Builder* subBuilder = [ChunkReferenceL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkReferences:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasFileChecksum {
  return result.hasFileChecksum;
}
- (NSData*) fileChecksum {
  return result.fileChecksum;
}
- (FileChecksumChunkReferencesL_Builder*) setFileChecksum:(NSData*) value {
  result.hasFileChecksum = YES;
  result.fileChecksum = value;
  return self;
}
- (FileChecksumChunkReferencesL_Builder*) clearFileChecksum {
  result.hasFileChecksum = NO;
  result.fileChecksum = [NSData data];
  return self;
}
- (NSArray*) chunkReferencesList {
  if (result.mutableChunkReferencesList == nil) { return [NSArray array]; }
  return result.mutableChunkReferencesList;
}
- (ChunkReferenceL*) chunkReferencesAtIndex:(int32_t) index {
  return [result chunkReferencesAtIndex:index];
}
- (FileChecksumChunkReferencesL_Builder*) replaceChunkReferencesAtIndex:(int32_t) index with:(ChunkReferenceL*) value {
  [result.mutableChunkReferencesList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumChunkReferencesL_Builder*) addAllChunkReferences:(NSArray*) values {
  if (result.mutableChunkReferencesList == nil) {
    result.mutableChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableChunkReferencesList addObjectsFromArray:values];
  return self;
}
- (FileChecksumChunkReferencesL_Builder*) clearChunkReferencesList {
  result.mutableChunkReferencesList = nil;
  return self;
}
- (FileChecksumChunkReferencesL_Builder*) addChunkReferences:(ChunkReferenceL*) value {
  if (result.mutableChunkReferencesList == nil) {
    result.mutableChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableChunkReferencesList addObject:value];
  return self;
}
@end

@interface FileChecksumStorageHostChunkListsL ()
@property (retain) NSMutableArray* mutableStorageHostChunkListList;
@property (retain) NSMutableArray* mutableFileChecksumChunkReferencesList;
@end

@implementation FileChecksumStorageHostChunkListsL

@synthesize mutableStorageHostChunkListList;
@synthesize mutableFileChecksumChunkReferencesList;
- (void) dealloc {
  self.mutableStorageHostChunkListList = nil;
  self.mutableFileChecksumChunkReferencesList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static FileChecksumStorageHostChunkListsL* defaultFileChecksumStorageHostChunkListsLInstance = nil;
+ (void) initialize {
  if (self == [FileChecksumStorageHostChunkListsL class]) {
    defaultFileChecksumStorageHostChunkListsLInstance = [[FileChecksumStorageHostChunkListsL alloc] init];
  }
}
+ (FileChecksumStorageHostChunkListsL*) defaultInstance {
  return defaultFileChecksumStorageHostChunkListsLInstance;
}
- (FileChecksumStorageHostChunkListsL*) defaultInstance {
  return defaultFileChecksumStorageHostChunkListsLInstance;
}
- (NSArray*) storageHostChunkListList {
  return mutableStorageHostChunkListList;
}
- (StorageHostChunkListL*) storageHostChunkListAtIndex:(int32_t) index {
  id value = [mutableStorageHostChunkListList objectAtIndex:index];
  return value;
}
- (NSArray*) fileChecksumChunkReferencesList {
  return mutableFileChecksumChunkReferencesList;
}
- (FileChecksumChunkReferencesL*) fileChecksumChunkReferencesAtIndex:(int32_t) index {
  id value = [mutableFileChecksumChunkReferencesList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageHostChunkListL* element in self.storageHostChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileChecksumChunkReferencesL* element in self.fileChecksumChunkReferencesList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageHostChunkListL* element in self.storageHostChunkListList) {
    [output writeMessage:1 value:element];
  }
  for (FileChecksumChunkReferencesL* element in self.fileChecksumChunkReferencesList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageHostChunkListL* element in self.storageHostChunkListList) {
    size += computeMessageSize(1, element);
  }
  for (FileChecksumChunkReferencesL* element in self.fileChecksumChunkReferencesList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileChecksumStorageHostChunkListsL*) parseFromData:(NSData*) data {
  return (FileChecksumStorageHostChunkListsL*)[[[FileChecksumStorageHostChunkListsL builder] mergeFromData:data] build];
}
+ (FileChecksumStorageHostChunkListsL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumStorageHostChunkListsL*)[[[FileChecksumStorageHostChunkListsL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumStorageHostChunkListsL*) parseFromInputStream:(NSInputStream*) input {
  return (FileChecksumStorageHostChunkListsL*)[[[FileChecksumStorageHostChunkListsL builder] mergeFromInputStream:input] build];
}
+ (FileChecksumStorageHostChunkListsL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumStorageHostChunkListsL*)[[[FileChecksumStorageHostChunkListsL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumStorageHostChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileChecksumStorageHostChunkListsL*)[[[FileChecksumStorageHostChunkListsL builder] mergeFromCodedInputStream:input] build];
}
+ (FileChecksumStorageHostChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileChecksumStorageHostChunkListsL*)[[[FileChecksumStorageHostChunkListsL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileChecksumStorageHostChunkListsL_Builder*) builder {
  return [[[FileChecksumStorageHostChunkListsL_Builder alloc] init] autorelease];
}
+ (FileChecksumStorageHostChunkListsL_Builder*) builderWithPrototype:(FileChecksumStorageHostChunkListsL*) prototype {
  return [[FileChecksumStorageHostChunkListsL builder] mergeFrom:prototype];
}
- (FileChecksumStorageHostChunkListsL_Builder*) builder {
  return [FileChecksumStorageHostChunkListsL builder];
}
@end

@interface FileChecksumStorageHostChunkListsL_Builder()
@property (retain) FileChecksumStorageHostChunkListsL* result;
@end

@implementation FileChecksumStorageHostChunkListsL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileChecksumStorageHostChunkListsL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileChecksumStorageHostChunkListsL_Builder*) clear {
  self.result = [[[FileChecksumStorageHostChunkListsL alloc] init] autorelease];
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) clone {
  return [FileChecksumStorageHostChunkListsL builderWithPrototype:result];
}
- (FileChecksumStorageHostChunkListsL*) defaultInstance {
  return [FileChecksumStorageHostChunkListsL defaultInstance];
}
- (FileChecksumStorageHostChunkListsL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileChecksumStorageHostChunkListsL*) buildPartial {
  FileChecksumStorageHostChunkListsL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileChecksumStorageHostChunkListsL_Builder*) mergeFrom:(FileChecksumStorageHostChunkListsL*) other {
  if (other == [FileChecksumStorageHostChunkListsL defaultInstance]) {
    return self;
  }
  if (other.mutableStorageHostChunkListList.count > 0) {
    if (result.mutableStorageHostChunkListList == nil) {
      result.mutableStorageHostChunkListList = [NSMutableArray array];
    }
    [result.mutableStorageHostChunkListList addObjectsFromArray:other.mutableStorageHostChunkListList];
  }
  if (other.mutableFileChecksumChunkReferencesList.count > 0) {
    if (result.mutableFileChecksumChunkReferencesList == nil) {
      result.mutableFileChecksumChunkReferencesList = [NSMutableArray array];
    }
    [result.mutableFileChecksumChunkReferencesList addObjectsFromArray:other.mutableFileChecksumChunkReferencesList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileChecksumStorageHostChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageHostChunkListL_Builder* subBuilder = [StorageHostChunkListL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageHostChunkList:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        FileChecksumChunkReferencesL_Builder* subBuilder = [FileChecksumChunkReferencesL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChecksumChunkReferences:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) storageHostChunkListList {
  if (result.mutableStorageHostChunkListList == nil) { return [NSArray array]; }
  return result.mutableStorageHostChunkListList;
}
- (StorageHostChunkListL*) storageHostChunkListAtIndex:(int32_t) index {
  return [result storageHostChunkListAtIndex:index];
}
- (FileChecksumStorageHostChunkListsL_Builder*) replaceStorageHostChunkListAtIndex:(int32_t) index with:(StorageHostChunkListL*) value {
  [result.mutableStorageHostChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) addAllStorageHostChunkList:(NSArray*) values {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObjectsFromArray:values];
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) clearStorageHostChunkListList {
  result.mutableStorageHostChunkListList = nil;
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) addStorageHostChunkList:(StorageHostChunkListL*) value {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObject:value];
  return self;
}
- (NSArray*) fileChecksumChunkReferencesList {
  if (result.mutableFileChecksumChunkReferencesList == nil) { return [NSArray array]; }
  return result.mutableFileChecksumChunkReferencesList;
}
- (FileChecksumChunkReferencesL*) fileChecksumChunkReferencesAtIndex:(int32_t) index {
  return [result fileChecksumChunkReferencesAtIndex:index];
}
- (FileChecksumStorageHostChunkListsL_Builder*) replaceFileChecksumChunkReferencesAtIndex:(int32_t) index with:(FileChecksumChunkReferencesL*) value {
  [result.mutableFileChecksumChunkReferencesList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) addAllFileChecksumChunkReferences:(NSArray*) values {
  if (result.mutableFileChecksumChunkReferencesList == nil) {
    result.mutableFileChecksumChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableFileChecksumChunkReferencesList addObjectsFromArray:values];
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) clearFileChecksumChunkReferencesList {
  result.mutableFileChecksumChunkReferencesList = nil;
  return self;
}
- (FileChecksumStorageHostChunkListsL_Builder*) addFileChecksumChunkReferences:(FileChecksumChunkReferencesL*) value {
  if (result.mutableFileChecksumChunkReferencesList == nil) {
    result.mutableFileChecksumChunkReferencesList = [NSMutableArray array];
  }
  [result.mutableFileChecksumChunkReferencesList addObject:value];
  return self;
}
@end

@interface FileGroupsL ()
@property (retain) NSMutableArray* mutableFileGroupsDataList;
@property (retain) NSMutableArray* mutableFileErrorList;
@property (retain) NSMutableArray* mutableFileChunkErrorList;
@property int32_t verbosityLevel;
@end

@implementation FileGroupsL

@synthesize mutableFileGroupsDataList;
@synthesize mutableFileErrorList;
@synthesize mutableFileChunkErrorList;
- (BOOL) hasVerbosityLevel {
  return !!hasVerbosityLevel_;
}
- (void) setHasVerbosityLevel:(BOOL) value {
  hasVerbosityLevel_ = !!value;
}
@synthesize verbosityLevel;
- (void) dealloc {
  self.mutableFileGroupsDataList = nil;
  self.mutableFileErrorList = nil;
  self.mutableFileChunkErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.verbosityLevel = 0;
  }
  return self;
}
static FileGroupsL* defaultFileGroupsLInstance = nil;
+ (void) initialize {
  if (self == [FileGroupsL class]) {
    defaultFileGroupsLInstance = [[FileGroupsL alloc] init];
  }
}
+ (FileGroupsL*) defaultInstance {
  return defaultFileGroupsLInstance;
}
- (FileGroupsL*) defaultInstance {
  return defaultFileGroupsLInstance;
}
- (NSArray*) fileGroupsDataList {
  return mutableFileGroupsDataList;
}
- (FileChecksumStorageHostChunkListsL*) fileGroupsDataAtIndex:(int32_t) index {
  id value = [mutableFileGroupsDataList objectAtIndex:index];
  return value;
}
- (NSArray*) fileErrorList {
  return mutableFileErrorList;
}
- (FileErrorL*) fileErrorAtIndex:(int32_t) index {
  id value = [mutableFileErrorList objectAtIndex:index];
  return value;
}
- (NSArray*) fileChunkErrorList {
  return mutableFileChunkErrorList;
}
- (FileChunkErrorL*) fileChunkErrorAtIndex:(int32_t) index {
  id value = [mutableFileChunkErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (FileChecksumStorageHostChunkListsL* element in self.fileGroupsDataList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileErrorL* element in self.fileErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (FileChunkErrorL* element in self.fileChunkErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (FileChecksumStorageHostChunkListsL* element in self.fileGroupsDataList) {
    [output writeMessage:1 value:element];
  }
  for (FileErrorL* element in self.fileErrorList) {
    [output writeMessage:2 value:element];
  }
  for (FileChunkErrorL* element in self.fileChunkErrorList) {
    [output writeMessage:3 value:element];
  }
  if (self.hasVerbosityLevel) {
    [output writeUInt32:4 value:self.verbosityLevel];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (FileChecksumStorageHostChunkListsL* element in self.fileGroupsDataList) {
    size += computeMessageSize(1, element);
  }
  for (FileErrorL* element in self.fileErrorList) {
    size += computeMessageSize(2, element);
  }
  for (FileChunkErrorL* element in self.fileChunkErrorList) {
    size += computeMessageSize(3, element);
  }
  if (self.hasVerbosityLevel) {
    size += computeUInt32Size(4, self.verbosityLevel);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (FileGroupsL*) parseFromData:(NSData*) data {
  return (FileGroupsL*)[[[FileGroupsL builder] mergeFromData:data] build];
}
+ (FileGroupsL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileGroupsL*)[[[FileGroupsL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (FileGroupsL*) parseFromInputStream:(NSInputStream*) input {
  return (FileGroupsL*)[[[FileGroupsL builder] mergeFromInputStream:input] build];
}
+ (FileGroupsL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileGroupsL*)[[[FileGroupsL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileGroupsL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (FileGroupsL*)[[[FileGroupsL builder] mergeFromCodedInputStream:input] build];
}
+ (FileGroupsL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (FileGroupsL*)[[[FileGroupsL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (FileGroupsL_Builder*) builder {
  return [[[FileGroupsL_Builder alloc] init] autorelease];
}
+ (FileGroupsL_Builder*) builderWithPrototype:(FileGroupsL*) prototype {
  return [[FileGroupsL builder] mergeFrom:prototype];
}
- (FileGroupsL_Builder*) builder {
  return [FileGroupsL builder];
}
@end

@interface FileGroupsL_Builder()
@property (retain) FileGroupsL* result;
@end

@implementation FileGroupsL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[FileGroupsL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (FileGroupsL_Builder*) clear {
  self.result = [[[FileGroupsL alloc] init] autorelease];
  return self;
}
- (FileGroupsL_Builder*) clone {
  return [FileGroupsL builderWithPrototype:result];
}
- (FileGroupsL*) defaultInstance {
  return [FileGroupsL defaultInstance];
}
- (FileGroupsL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (FileGroupsL*) buildPartial {
  FileGroupsL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (FileGroupsL_Builder*) mergeFrom:(FileGroupsL*) other {
  if (other == [FileGroupsL defaultInstance]) {
    return self;
  }
  if (other.mutableFileGroupsDataList.count > 0) {
    if (result.mutableFileGroupsDataList == nil) {
      result.mutableFileGroupsDataList = [NSMutableArray array];
    }
    [result.mutableFileGroupsDataList addObjectsFromArray:other.mutableFileGroupsDataList];
  }
  if (other.mutableFileErrorList.count > 0) {
    if (result.mutableFileErrorList == nil) {
      result.mutableFileErrorList = [NSMutableArray array];
    }
    [result.mutableFileErrorList addObjectsFromArray:other.mutableFileErrorList];
  }
  if (other.mutableFileChunkErrorList.count > 0) {
    if (result.mutableFileChunkErrorList == nil) {
      result.mutableFileChunkErrorList = [NSMutableArray array];
    }
    [result.mutableFileChunkErrorList addObjectsFromArray:other.mutableFileChunkErrorList];
  }
  if (other.hasVerbosityLevel) {
    [self setVerbosityLevel:other.verbosityLevel];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (FileGroupsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (FileGroupsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        FileChecksumStorageHostChunkListsL_Builder* subBuilder = [FileChecksumStorageHostChunkListsL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileGroupsData:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        FileErrorL_Builder* subBuilder = [FileErrorL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileError:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        FileChunkErrorL_Builder* subBuilder = [FileChunkErrorL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addFileChunkError:[subBuilder buildPartial]];
        break;
      }
      case 32: {
        [self setVerbosityLevel:[input readUInt32]];
        break;
      }
    }
  }
}
- (NSArray*) fileGroupsDataList {
  if (result.mutableFileGroupsDataList == nil) { return [NSArray array]; }
  return result.mutableFileGroupsDataList;
}
- (FileChecksumStorageHostChunkListsL*) fileGroupsDataAtIndex:(int32_t) index {
  return [result fileGroupsDataAtIndex:index];
}
- (FileGroupsL_Builder*) replaceFileGroupsDataAtIndex:(int32_t) index with:(FileChecksumStorageHostChunkListsL*) value {
  [result.mutableFileGroupsDataList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileGroupsL_Builder*) addAllFileGroupsData:(NSArray*) values {
  if (result.mutableFileGroupsDataList == nil) {
    result.mutableFileGroupsDataList = [NSMutableArray array];
  }
  [result.mutableFileGroupsDataList addObjectsFromArray:values];
  return self;
}
- (FileGroupsL_Builder*) clearFileGroupsDataList {
  result.mutableFileGroupsDataList = nil;
  return self;
}
- (FileGroupsL_Builder*) addFileGroupsData:(FileChecksumStorageHostChunkListsL*) value {
  if (result.mutableFileGroupsDataList == nil) {
    result.mutableFileGroupsDataList = [NSMutableArray array];
  }
  [result.mutableFileGroupsDataList addObject:value];
  return self;
}
- (NSArray*) fileErrorList {
  if (result.mutableFileErrorList == nil) { return [NSArray array]; }
  return result.mutableFileErrorList;
}
- (FileErrorL*) fileErrorAtIndex:(int32_t) index {
  return [result fileErrorAtIndex:index];
}
- (FileGroupsL_Builder*) replaceFileErrorAtIndex:(int32_t) index with:(FileErrorL*) value {
  [result.mutableFileErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileGroupsL_Builder*) addAllFileError:(NSArray*) values {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObjectsFromArray:values];
  return self;
}
- (FileGroupsL_Builder*) clearFileErrorList {
  result.mutableFileErrorList = nil;
  return self;
}
- (FileGroupsL_Builder*) addFileError:(FileErrorL*) value {
  if (result.mutableFileErrorList == nil) {
    result.mutableFileErrorList = [NSMutableArray array];
  }
  [result.mutableFileErrorList addObject:value];
  return self;
}
- (NSArray*) fileChunkErrorList {
  if (result.mutableFileChunkErrorList == nil) { return [NSArray array]; }
  return result.mutableFileChunkErrorList;
}
- (FileChunkErrorL*) fileChunkErrorAtIndex:(int32_t) index {
  return [result fileChunkErrorAtIndex:index];
}
- (FileGroupsL_Builder*) replaceFileChunkErrorAtIndex:(int32_t) index with:(FileChunkErrorL*) value {
  [result.mutableFileChunkErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (FileGroupsL_Builder*) addAllFileChunkError:(NSArray*) values {
  if (result.mutableFileChunkErrorList == nil) {
    result.mutableFileChunkErrorList = [NSMutableArray array];
  }
  [result.mutableFileChunkErrorList addObjectsFromArray:values];
  return self;
}
- (FileGroupsL_Builder*) clearFileChunkErrorList {
  result.mutableFileChunkErrorList = nil;
  return self;
}
- (FileGroupsL_Builder*) addFileChunkError:(FileChunkErrorL*) value {
  if (result.mutableFileChunkErrorList == nil) {
    result.mutableFileChunkErrorList = [NSMutableArray array];
  }
  [result.mutableFileChunkErrorList addObject:value];
  return self;
}
- (BOOL) hasVerbosityLevel {
  return result.hasVerbosityLevel;
}
- (int32_t) verbosityLevel {
  return result.verbosityLevel;
}
- (FileGroupsL_Builder*) setVerbosityLevel:(int32_t) value {
  result.hasVerbosityLevel = YES;
  result.verbosityLevel = value;
  return self;
}
- (FileGroupsL_Builder*) clearVerbosityLevel {
  result.hasVerbosityLevel = NO;
  result.verbosityLevel = 0;
  return self;
}
@end

@interface ChunkChecksumListL ()
@property (retain) NSMutableArray* mutableChunkChecksumDataList;
@end

@implementation ChunkChecksumListL

@synthesize mutableChunkChecksumDataList;
- (void) dealloc {
  self.mutableChunkChecksumDataList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static ChunkChecksumListL* defaultChunkChecksumListLInstance = nil;
+ (void) initialize {
  if (self == [ChunkChecksumListL class]) {
    defaultChunkChecksumListLInstance = [[ChunkChecksumListL alloc] init];
  }
}
+ (ChunkChecksumListL*) defaultInstance {
  return defaultChunkChecksumListLInstance;
}
- (ChunkChecksumListL*) defaultInstance {
  return defaultChunkChecksumListLInstance;
}
- (NSArray*) chunkChecksumDataList {
  return mutableChunkChecksumDataList;
}
- (NSData*) chunkChecksumDataAtIndex:(int32_t) index {
  id value = [mutableChunkChecksumDataList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (NSData* element in self.mutableChunkChecksumDataList) {
    [output writeData:1 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  {
    int32_t dataSize = 0;
    for (NSData* element in self.mutableChunkChecksumDataList) {
      dataSize += computeDataSizeNoTag(element);
    }
    size += dataSize;
    size += 1 * self.mutableChunkChecksumDataList.count;
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (ChunkChecksumListL*) parseFromData:(NSData*) data {
  return (ChunkChecksumListL*)[[[ChunkChecksumListL builder] mergeFromData:data] build];
}
+ (ChunkChecksumListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkChecksumListL*)[[[ChunkChecksumListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (ChunkChecksumListL*) parseFromInputStream:(NSInputStream*) input {
  return (ChunkChecksumListL*)[[[ChunkChecksumListL builder] mergeFromInputStream:input] build];
}
+ (ChunkChecksumListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkChecksumListL*)[[[ChunkChecksumListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkChecksumListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (ChunkChecksumListL*)[[[ChunkChecksumListL builder] mergeFromCodedInputStream:input] build];
}
+ (ChunkChecksumListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (ChunkChecksumListL*)[[[ChunkChecksumListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (ChunkChecksumListL_Builder*) builder {
  return [[[ChunkChecksumListL_Builder alloc] init] autorelease];
}
+ (ChunkChecksumListL_Builder*) builderWithPrototype:(ChunkChecksumListL*) prototype {
  return [[ChunkChecksumListL builder] mergeFrom:prototype];
}
- (ChunkChecksumListL_Builder*) builder {
  return [ChunkChecksumListL builder];
}
@end

@interface ChunkChecksumListL_Builder()
@property (retain) ChunkChecksumListL* result;
@end

@implementation ChunkChecksumListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[ChunkChecksumListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (ChunkChecksumListL_Builder*) clear {
  self.result = [[[ChunkChecksumListL alloc] init] autorelease];
  return self;
}
- (ChunkChecksumListL_Builder*) clone {
  return [ChunkChecksumListL builderWithPrototype:result];
}
- (ChunkChecksumListL*) defaultInstance {
  return [ChunkChecksumListL defaultInstance];
}
- (ChunkChecksumListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (ChunkChecksumListL*) buildPartial {
  ChunkChecksumListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (ChunkChecksumListL_Builder*) mergeFrom:(ChunkChecksumListL*) other {
  if (other == [ChunkChecksumListL defaultInstance]) {
    return self;
  }
  if (other.mutableChunkChecksumDataList.count > 0) {
    if (result.mutableChunkChecksumDataList == nil) {
      result.mutableChunkChecksumDataList = [NSMutableArray array];
    }
    [result.mutableChunkChecksumDataList addObjectsFromArray:other.mutableChunkChecksumDataList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (ChunkChecksumListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (ChunkChecksumListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self addChunkChecksumData:[input readData]];
        break;
      }
    }
  }
}
- (NSArray*) chunkChecksumDataList {
  if (result.mutableChunkChecksumDataList == nil) {
    return [NSArray array];
  }
  return result.mutableChunkChecksumDataList;
}
- (NSData*) chunkChecksumDataAtIndex:(int32_t) index {
  return [result chunkChecksumDataAtIndex:index];
}
- (ChunkChecksumListL_Builder*) replaceChunkChecksumDataAtIndex:(int32_t) index with:(NSData*) value {
  [result.mutableChunkChecksumDataList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (ChunkChecksumListL_Builder*) addChunkChecksumData:(NSData*) value {
  if (result.mutableChunkChecksumDataList == nil) {
    result.mutableChunkChecksumDataList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumDataList addObject:value];
  return self;
}
- (ChunkChecksumListL_Builder*) addAllChunkChecksumData:(NSArray*) values {
  if (result.mutableChunkChecksumDataList == nil) {
    result.mutableChunkChecksumDataList = [NSMutableArray array];
  }
  [result.mutableChunkChecksumDataList addObjectsFromArray:values];
  return self;
}
- (ChunkChecksumListL_Builder*) clearChunkChecksumDataList {
  result.mutableChunkChecksumDataList = nil;
  return self;
}
@end

@interface StorageHostChunkListL ()
@property (retain) HostInfoL* hostInfo;
@property (retain) NSMutableArray* mutableChunkInfoList;
@property (retain) NSString* storageContainerKey;
@property (retain) NSString* storageContainerAuthorizationToken;
@end

@implementation StorageHostChunkListL

- (BOOL) hasHostInfo {
  return !!hasHostInfo_;
}
- (void) setHasHostInfo:(BOOL) value {
  hasHostInfo_ = !!value;
}
@synthesize hostInfo;
@synthesize mutableChunkInfoList;
- (BOOL) hasStorageContainerKey {
  return !!hasStorageContainerKey_;
}
- (void) setHasStorageContainerKey:(BOOL) value {
  hasStorageContainerKey_ = !!value;
}
@synthesize storageContainerKey;
- (BOOL) hasStorageContainerAuthorizationToken {
  return !!hasStorageContainerAuthorizationToken_;
}
- (void) setHasStorageContainerAuthorizationToken:(BOOL) value {
  hasStorageContainerAuthorizationToken_ = !!value;
}
@synthesize storageContainerAuthorizationToken;
- (void) dealloc {
  self.hostInfo = nil;
  self.mutableChunkInfoList = nil;
  self.storageContainerKey = nil;
  self.storageContainerAuthorizationToken = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.hostInfo = [HostInfoL defaultInstance];
    self.storageContainerKey = @"";
    self.storageContainerAuthorizationToken = @"";
  }
  return self;
}
static StorageHostChunkListL* defaultStorageHostChunkListLInstance = nil;
+ (void) initialize {
  if (self == [StorageHostChunkListL class]) {
    defaultStorageHostChunkListLInstance = [[StorageHostChunkListL alloc] init];
  }
}
+ (StorageHostChunkListL*) defaultInstance {
  return defaultStorageHostChunkListLInstance;
}
- (StorageHostChunkListL*) defaultInstance {
  return defaultStorageHostChunkListLInstance;
}
- (NSArray*) chunkInfoList {
  return mutableChunkInfoList;
}
- (ChunkInfoL*) chunkInfoAtIndex:(int32_t) index {
  id value = [mutableChunkInfoList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  if (!self.hasHostInfo) {
    return NO;
  }
  if (!self.hasStorageContainerKey) {
    return NO;
  }
  if (!self.hasStorageContainerAuthorizationToken) {
    return NO;
  }
  if (!self.hostInfo.isInitialized) {
    return NO;
  }
  for (ChunkInfoL* element in self.chunkInfoList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasHostInfo) {
    [output writeMessage:1 value:self.hostInfo];
  }
  for (ChunkInfoL* element in self.chunkInfoList) {
    [output writeMessage:2 value:element];
  }
  if (self.hasStorageContainerKey) {
    [output writeString:3 value:self.storageContainerKey];
  }
  if (self.hasStorageContainerAuthorizationToken) {
    [output writeString:4 value:self.storageContainerAuthorizationToken];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasHostInfo) {
    size += computeMessageSize(1, self.hostInfo);
  }
  for (ChunkInfoL* element in self.chunkInfoList) {
    size += computeMessageSize(2, element);
  }
  if (self.hasStorageContainerKey) {
    size += computeStringSize(3, self.storageContainerKey);
  }
  if (self.hasStorageContainerAuthorizationToken) {
    size += computeStringSize(4, self.storageContainerAuthorizationToken);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageHostChunkListL*) parseFromData:(NSData*) data {
  return (StorageHostChunkListL*)[[[StorageHostChunkListL builder] mergeFromData:data] build];
}
+ (StorageHostChunkListL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkListL*)[[[StorageHostChunkListL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkListL*) parseFromInputStream:(NSInputStream*) input {
  return (StorageHostChunkListL*)[[[StorageHostChunkListL builder] mergeFromInputStream:input] build];
}
+ (StorageHostChunkListL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkListL*)[[[StorageHostChunkListL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkListL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageHostChunkListL*)[[[StorageHostChunkListL builder] mergeFromCodedInputStream:input] build];
}
+ (StorageHostChunkListL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkListL*)[[[StorageHostChunkListL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkListL_Builder*) builder {
  return [[[StorageHostChunkListL_Builder alloc] init] autorelease];
}
+ (StorageHostChunkListL_Builder*) builderWithPrototype:(StorageHostChunkListL*) prototype {
  return [[StorageHostChunkListL builder] mergeFrom:prototype];
}
- (StorageHostChunkListL_Builder*) builder {
  return [StorageHostChunkListL builder];
}
@end

@interface StorageHostChunkListL_Builder()
@property (retain) StorageHostChunkListL* result;
@end

@implementation StorageHostChunkListL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageHostChunkListL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageHostChunkListL_Builder*) clear {
  self.result = [[[StorageHostChunkListL alloc] init] autorelease];
  return self;
}
- (StorageHostChunkListL_Builder*) clone {
  return [StorageHostChunkListL builderWithPrototype:result];
}
- (StorageHostChunkListL*) defaultInstance {
  return [StorageHostChunkListL defaultInstance];
}
- (StorageHostChunkListL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageHostChunkListL*) buildPartial {
  StorageHostChunkListL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageHostChunkListL_Builder*) mergeFrom:(StorageHostChunkListL*) other {
  if (other == [StorageHostChunkListL defaultInstance]) {
    return self;
  }
  if (other.hasHostInfo) {
    [self mergeHostInfo:other.hostInfo];
  }
  if (other.mutableChunkInfoList.count > 0) {
    if (result.mutableChunkInfoList == nil) {
      result.mutableChunkInfoList = [NSMutableArray array];
    }
    [result.mutableChunkInfoList addObjectsFromArray:other.mutableChunkInfoList];
  }
  if (other.hasStorageContainerKey) {
    [self setStorageContainerKey:other.storageContainerKey];
  }
  if (other.hasStorageContainerAuthorizationToken) {
    [self setStorageContainerAuthorizationToken:other.storageContainerAuthorizationToken];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageHostChunkListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageHostChunkListL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        HostInfoL_Builder* subBuilder = [HostInfoL builder];
        if (self.hasHostInfo) {
          [subBuilder mergeFrom:self.hostInfo];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setHostInfo:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        ChunkInfoL_Builder* subBuilder = [ChunkInfoL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkInfo:[subBuilder buildPartial]];
        break;
      }
      case 26: {
        [self setStorageContainerKey:[input readString]];
        break;
      }
      case 34: {
        [self setStorageContainerAuthorizationToken:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasHostInfo {
  return result.hasHostInfo;
}
- (HostInfoL*) hostInfo {
  return result.hostInfo;
}
- (StorageHostChunkListL_Builder*) setHostInfo:(HostInfoL*) value {
  result.hasHostInfo = YES;
  result.hostInfo = value;
  return self;
}
- (StorageHostChunkListL_Builder*) setHostInfoBuilder:(HostInfoL_Builder*) builderForValue {
  return [self setHostInfo:[builderForValue build]];
}
- (StorageHostChunkListL_Builder*) mergeHostInfo:(HostInfoL*) value {
  if (result.hasHostInfo &&
      result.hostInfo != [HostInfoL defaultInstance]) {
    result.hostInfo =
      [[[HostInfoL builderWithPrototype:result.hostInfo] mergeFrom:value] buildPartial];
  } else {
    result.hostInfo = value;
  }
  result.hasHostInfo = YES;
  return self;
}
- (StorageHostChunkListL_Builder*) clearHostInfo {
  result.hasHostInfo = NO;
  result.hostInfo = [HostInfoL defaultInstance];
  return self;
}
- (NSArray*) chunkInfoList {
  if (result.mutableChunkInfoList == nil) { return [NSArray array]; }
  return result.mutableChunkInfoList;
}
- (ChunkInfoL*) chunkInfoAtIndex:(int32_t) index {
  return [result chunkInfoAtIndex:index];
}
- (StorageHostChunkListL_Builder*) replaceChunkInfoAtIndex:(int32_t) index with:(ChunkInfoL*) value {
  [result.mutableChunkInfoList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageHostChunkListL_Builder*) addAllChunkInfo:(NSArray*) values {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObjectsFromArray:values];
  return self;
}
- (StorageHostChunkListL_Builder*) clearChunkInfoList {
  result.mutableChunkInfoList = nil;
  return self;
}
- (StorageHostChunkListL_Builder*) addChunkInfo:(ChunkInfoL*) value {
  if (result.mutableChunkInfoList == nil) {
    result.mutableChunkInfoList = [NSMutableArray array];
  }
  [result.mutableChunkInfoList addObject:value];
  return self;
}
- (BOOL) hasStorageContainerKey {
  return result.hasStorageContainerKey;
}
- (NSString*) storageContainerKey {
  return result.storageContainerKey;
}
- (StorageHostChunkListL_Builder*) setStorageContainerKey:(NSString*) value {
  result.hasStorageContainerKey = YES;
  result.storageContainerKey = value;
  return self;
}
- (StorageHostChunkListL_Builder*) clearStorageContainerKey {
  result.hasStorageContainerKey = NO;
  result.storageContainerKey = @"";
  return self;
}
- (BOOL) hasStorageContainerAuthorizationToken {
  return result.hasStorageContainerAuthorizationToken;
}
- (NSString*) storageContainerAuthorizationToken {
  return result.storageContainerAuthorizationToken;
}
- (StorageHostChunkListL_Builder*) setStorageContainerAuthorizationToken:(NSString*) value {
  result.hasStorageContainerAuthorizationToken = YES;
  result.storageContainerAuthorizationToken = value;
  return self;
}
- (StorageHostChunkListL_Builder*) clearStorageContainerAuthorizationToken {
  result.hasStorageContainerAuthorizationToken = NO;
  result.storageContainerAuthorizationToken = @"";
  return self;
}
@end

@interface StorageHostChunkListsL ()
@property (retain) NSMutableArray* mutableStorageHostChunkListList;
@property (retain) NSMutableArray* mutableChunkErrorList;
@end

@implementation StorageHostChunkListsL

@synthesize mutableStorageHostChunkListList;
@synthesize mutableChunkErrorList;
- (void) dealloc {
  self.mutableStorageHostChunkListList = nil;
  self.mutableChunkErrorList = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
  }
  return self;
}
static StorageHostChunkListsL* defaultStorageHostChunkListsLInstance = nil;
+ (void) initialize {
  if (self == [StorageHostChunkListsL class]) {
    defaultStorageHostChunkListsLInstance = [[StorageHostChunkListsL alloc] init];
  }
}
+ (StorageHostChunkListsL*) defaultInstance {
  return defaultStorageHostChunkListsLInstance;
}
- (StorageHostChunkListsL*) defaultInstance {
  return defaultStorageHostChunkListsLInstance;
}
- (NSArray*) storageHostChunkListList {
  return mutableStorageHostChunkListList;
}
- (StorageHostChunkListL*) storageHostChunkListAtIndex:(int32_t) index {
  id value = [mutableStorageHostChunkListList objectAtIndex:index];
  return value;
}
- (NSArray*) chunkErrorList {
  return mutableChunkErrorList;
}
- (ChunkErrorL*) chunkErrorAtIndex:(int32_t) index {
  id value = [mutableChunkErrorList objectAtIndex:index];
  return value;
}
- (BOOL) isInitialized {
  for (StorageHostChunkListL* element in self.storageHostChunkListList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  for (ChunkErrorL* element in self.chunkErrorList) {
    if (!element.isInitialized) {
      return NO;
    }
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  for (StorageHostChunkListL* element in self.storageHostChunkListList) {
    [output writeMessage:1 value:element];
  }
  for (ChunkErrorL* element in self.chunkErrorList) {
    [output writeMessage:2 value:element];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  for (StorageHostChunkListL* element in self.storageHostChunkListList) {
    size += computeMessageSize(1, element);
  }
  for (ChunkErrorL* element in self.chunkErrorList) {
    size += computeMessageSize(2, element);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (StorageHostChunkListsL*) parseFromData:(NSData*) data {
  return (StorageHostChunkListsL*)[[[StorageHostChunkListsL builder] mergeFromData:data] build];
}
+ (StorageHostChunkListsL*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkListsL*)[[[StorageHostChunkListsL builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkListsL*) parseFromInputStream:(NSInputStream*) input {
  return (StorageHostChunkListsL*)[[[StorageHostChunkListsL builder] mergeFromInputStream:input] build];
}
+ (StorageHostChunkListsL*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkListsL*)[[[StorageHostChunkListsL builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (StorageHostChunkListsL*)[[[StorageHostChunkListsL builder] mergeFromCodedInputStream:input] build];
}
+ (StorageHostChunkListsL*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (StorageHostChunkListsL*)[[[StorageHostChunkListsL builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (StorageHostChunkListsL_Builder*) builder {
  return [[[StorageHostChunkListsL_Builder alloc] init] autorelease];
}
+ (StorageHostChunkListsL_Builder*) builderWithPrototype:(StorageHostChunkListsL*) prototype {
  return [[StorageHostChunkListsL builder] mergeFrom:prototype];
}
- (StorageHostChunkListsL_Builder*) builder {
  return [StorageHostChunkListsL builder];
}
@end

@interface StorageHostChunkListsL_Builder()
@property (retain) StorageHostChunkListsL* result;
@end

@implementation StorageHostChunkListsL_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[StorageHostChunkListsL alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (StorageHostChunkListsL_Builder*) clear {
  self.result = [[[StorageHostChunkListsL alloc] init] autorelease];
  return self;
}
- (StorageHostChunkListsL_Builder*) clone {
  return [StorageHostChunkListsL builderWithPrototype:result];
}
- (StorageHostChunkListsL*) defaultInstance {
  return [StorageHostChunkListsL defaultInstance];
}
- (StorageHostChunkListsL*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (StorageHostChunkListsL*) buildPartial {
  StorageHostChunkListsL* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (StorageHostChunkListsL_Builder*) mergeFrom:(StorageHostChunkListsL*) other {
  if (other == [StorageHostChunkListsL defaultInstance]) {
    return self;
  }
  if (other.mutableStorageHostChunkListList.count > 0) {
    if (result.mutableStorageHostChunkListList == nil) {
      result.mutableStorageHostChunkListList = [NSMutableArray array];
    }
    [result.mutableStorageHostChunkListList addObjectsFromArray:other.mutableStorageHostChunkListList];
  }
  if (other.mutableChunkErrorList.count > 0) {
    if (result.mutableChunkErrorList == nil) {
      result.mutableChunkErrorList = [NSMutableArray array];
    }
    [result.mutableChunkErrorList addObjectsFromArray:other.mutableChunkErrorList];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (StorageHostChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (StorageHostChunkListsL_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        StorageHostChunkListL_Builder* subBuilder = [StorageHostChunkListL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addStorageHostChunkList:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        ChunkErrorL_Builder* subBuilder = [ChunkErrorL builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addChunkError:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSArray*) storageHostChunkListList {
  if (result.mutableStorageHostChunkListList == nil) { return [NSArray array]; }
  return result.mutableStorageHostChunkListList;
}
- (StorageHostChunkListL*) storageHostChunkListAtIndex:(int32_t) index {
  return [result storageHostChunkListAtIndex:index];
}
- (StorageHostChunkListsL_Builder*) replaceStorageHostChunkListAtIndex:(int32_t) index with:(StorageHostChunkListL*) value {
  [result.mutableStorageHostChunkListList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageHostChunkListsL_Builder*) addAllStorageHostChunkList:(NSArray*) values {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObjectsFromArray:values];
  return self;
}
- (StorageHostChunkListsL_Builder*) clearStorageHostChunkListList {
  result.mutableStorageHostChunkListList = nil;
  return self;
}
- (StorageHostChunkListsL_Builder*) addStorageHostChunkList:(StorageHostChunkListL*) value {
  if (result.mutableStorageHostChunkListList == nil) {
    result.mutableStorageHostChunkListList = [NSMutableArray array];
  }
  [result.mutableStorageHostChunkListList addObject:value];
  return self;
}
- (NSArray*) chunkErrorList {
  if (result.mutableChunkErrorList == nil) { return [NSArray array]; }
  return result.mutableChunkErrorList;
}
- (ChunkErrorL*) chunkErrorAtIndex:(int32_t) index {
  return [result chunkErrorAtIndex:index];
}
- (StorageHostChunkListsL_Builder*) replaceChunkErrorAtIndex:(int32_t) index with:(ChunkErrorL*) value {
  [result.mutableChunkErrorList replaceObjectAtIndex:index withObject:value];
  return self;
}
- (StorageHostChunkListsL_Builder*) addAllChunkError:(NSArray*) values {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObjectsFromArray:values];
  return self;
}
- (StorageHostChunkListsL_Builder*) clearChunkErrorList {
  result.mutableChunkErrorList = nil;
  return self;
}
- (StorageHostChunkListsL_Builder*) addChunkError:(ChunkErrorL*) value {
  if (result.mutableChunkErrorList == nil) {
    result.mutableChunkErrorList = [NSMutableArray array];
  }
  [result.mutableChunkErrorList addObject:value];
  return self;
}
@end

